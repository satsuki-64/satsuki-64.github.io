<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【CSharp系列】托管堆与垃圾回收（1）-- 托管堆</title>
    <url>/2023/08/4b26dd1d757b.html</url>
    <content><![CDATA[<ul>
<li><ol>
<li>为什么要有托管堆</li>
</ol>
</li>
<li><ol start="2">
<li>什么是托管堆</li>
</ol>
</li>
<li><ol start="3">
<li>垃圾回收算法</li>
</ol>
<ul>
<li><ol>
<li>引用计数算法</li>
</ol>
</li>
<li><ol start="2">
<li>引用跟踪算法<span id="more"></span></li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="1-为什么要有托管堆"><a href="#1-为什么要有托管堆" class="headerlink" title="1.为什么要有托管堆"></a>1.为什么要有托管堆</h1><h2 id="1-1-面向对象与资源分配"><a href="#1-1-面向对象与资源分配" class="headerlink" title="1.1 面向对象与资源分配"></a>1.1 面向对象与资源分配</h2><p><strong>面向对象中的资源</strong><br>概念：在面向对象的环境中，任何一种类型都代表了计算机中可供程序使用的一种资源。如果要使用这种资源，就需要为这种资源分配一定的内存；</p>
<p><strong>资源分配步骤</strong></p>
<ul>
<li>第一步<ul>
<li>调用IL代码<code>newobj</code>，为代表资源的类型分配内存；</li>
<li>此步骤通常由new操作符来触发并完成；</li>
</ul>
</li>
<li>第二步<ul>
<li>根据类型的状态设置，初始化内存，设置资源的初始状态并使得此资源可用；</li>
<li>由类型的实例构造函数来设置初始状态；</li>
</ul>
</li>
<li>第三步<ul>
<li>访问类型的成员来使用此资源</li>
</ul>
</li>
<li>第四步<ul>
<li>摧毁资源的状态，以进行垃圾的清理</li>
</ul>
</li>
<li>第五步<ul>
<li>由GC回收期释放内存</li>
</ul>
</li>
</ul>
<h2 id="1-2-为什么需要托管堆来进行垃圾回收"><a href="#1-2-为什么需要托管堆来进行垃圾回收" class="headerlink" title="1.2 为什么需要托管堆来进行垃圾回收"></a>1.2 为什么需要托管堆来进行垃圾回收</h2><p><strong>C++中的例子</strong><br>在需要程序员手动管理内存的语言中（比如当C++不使用shareptr或其他基于对象的指针时），程序员经常会产生两种错误：</p>
<ol>
<li>忘记释放不再需要的内存，进而造成内存泄漏；</li>
<li>尝试使用已经释放的内存，造成安全漏洞；<br>由于这两种错误经常是在程序运行时才能发现，因此程序发生异常时调试困难。</li>
</ol>
<p><strong>解决方法：可验证的、类型安全的代码</strong><br>在资源分配阶段中的【第四步】，此步骤若不是由程序员来完成，而是交给程序的托管堆和垃圾回收器来自动进行时，此时程序就能进一步的保证安全；</p>
<ul>
<li>托管堆会自动完成垃圾的回收，并且当需要手动进行回收时，托管堆还提供了一个简化的模型；</li>
</ul>
<p><strong>补充：需要特殊清理的类型</strong><br>部分包装了本机资源的类型，比如对文件、Socket、数据库连接资源的类型，可能无法使用自动进行的垃圾回收，而是需要程序员使用GC的手动触发；</p>
<h1 id="2-什么是托管堆"><a href="#2-什么是托管堆" class="headerlink" title="2.什么是托管堆"></a>2.什么是托管堆</h1><h2 id="2-1-托管堆基本概念"><a href="#2-1-托管堆基本概念" class="headerlink" title="2.1 托管堆基本概念"></a>2.1 托管堆基本概念</h2><p><strong>托管堆</strong><br>在C#中，托管堆是一种用于存储和管理托管对象（即运行在CLR中的对象）的内存区域。它是CLR的一部分，为托管对象提供动态内存分配和释放的功能。托管堆是一种自动化内存管理机制，它通过垃圾回收器自动回收不再使用的对象，从而释放内存并确保内存的正确使用。</p>
<p><strong>NextObjPtr</strong><br>CLR会在程序的托管堆中管理一个指针NextObjPtr，此指针会一直指向下一个对象在队中分配的位置。在最开始时，此指针指向地址空间的基地址；</p>
<p><strong>内存自动扩张</strong><br>在一个区域的内存备非垃圾对象填满之后，CLR会自动分配更多的区域。此过程会一直进行，直到进程的地址空间被填满；</p>
<h2 id="2-2-CLR中的new行为"><a href="#2-2-CLR中的new行为" class="headerlink" title="2.2 CLR中的new行为"></a>2.2 CLR中的new行为</h2><p><strong>执行行为</strong><br>C#的new操作符将导致CLR执行以下步骤：</p>
<ul>
<li>第一步<ul>
<li>计算类型的字段(包括从基类型继承的字段)所需的字节数。</li>
</ul>
</li>
<li>第二步<ul>
<li>加上对象额外所需的两部分开销所需的字节数；</li>
<li>每个对象都有两个开销字段：<ul>
<li>类型对象指针</li>
<li>同步块索引</li>
</ul>
</li>
<li>对于32位应用程序，这两个字段各自需要 32位，所以每个对象要增加8字节。对于64位应用程序，这两个字段各自需要64位，所以每个对象要增加16字节；</li>
</ul>
</li>
<li>第三步<ul>
<li>检查阶段：<ul>
<li>CLR检查区域中是否有分配对象所需的字节数。如果托管堆有足够的可用空间，就在NextObiPtr 指针指向的地址处放入对象，为对象分配的字节会被清零；</li>
</ul>
</li>
<li>调用阶段<ul>
<li>调用类型的构造器，为类型构造器中的this参数传递当前NextObiPtr指向的对象，new操作符返回对象引用；</li>
<li>在返回这个引用之前，NextObjiPtr指针的值会加上对象占用的字节数来得到一个新值，即下个对象放入托管堆时的地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>分配之后的内存，在空间中形式如下简图：<br><img src="/../../image/Pasted%20image%2020230828103459.png" alt="新初始化的托管堆，其中构造了3个对象"></p>
<h2 id="2-3-托管堆与空间局部化"><a href="#2-3-托管堆与空间局部化" class="headerlink" title="2.3 托管堆与空间局部化"></a>2.3 托管堆与空间局部化</h2><p><strong>空间局部化</strong><br>由于托管堆的分配是在指针之上加一个值，因此其分配的速度非常的快；差不多同时分配的对象彼此间有较强的联系，而且经常差不多在同一时间访问；</p>
<ul>
<li><strong>由于托管堆在内存中连续分配这些对象，所以会因为引用的“局部化”(locality)而获得性能上的提升</strong></li>
</ul>
<p><strong>具体的优点</strong></p>
<ul>
<li>优点一<ul>
<li>进程的工作集会非常小，应用程序只需使用很少的内存，从而提高了速度；</li>
</ul>
</li>
<li>优点二<ul>
<li>代码使用的对象可以全部驻留在 CPU 的缓存中。应用程序能以非常快的速度访问这些对象，因为CPU在执行大多数操作不会因Cache Miss而被迫访问较慢的 RAM；</li>
</ul>
</li>
</ul>
<h1 id="3-垃圾回收算法"><a href="#3-垃圾回收算法" class="headerlink" title="3.垃圾回收算法"></a>3.垃圾回收算法</h1><p>在应用程序调用new操作符创建对象时，可能会没有足够地址空间来分配该对象，此时CLR就需要执行垃圾回收。</p>
<h2 id="3-1-引用计数算法"><a href="#3-1-引用计数算法" class="headerlink" title="3.1 引用计数算法"></a>3.1 引用计数算法</h2><p><strong>什么是引用计数算法</strong><br>对于对象生存期的管理，有些系统使用的是引用计数算法；<em>比如微软的COM</em></p>
<p><strong>算法内容</strong><br>堆上的每个对象都维护着一个内存字段，用于统计程序中多少部分正在使用对象。随着每一部分到达代码中某个不再需要对象的地方，就递减对象的计数字段。当计数字段变成0，对象就可以从内存中删除；</p>
<p><strong>算法问题：循环引用</strong><br>在一些GUI应用程序中，窗口对象将容纳对子UI对象的引用，而子UI对象将容纳对父窗口对象的引用；<br>这种引用会阻止两个对象的计数器达到 0，所以两个对象永远不会删除，即使应用程序本身不再需要窗口。</p>
<ul>
<li>CLR不使用引用计数算法，而是使用<strong>引用跟踪算法</strong>；</li>
</ul>
<h2 id="3-2-引用跟踪算法"><a href="#3-2-引用跟踪算法" class="headerlink" title="3.2 引用跟踪算法"></a>3.2 引用跟踪算法</h2><p><strong>算法特点</strong><br>引用跟踪算法只关心引用类型的变量，不关心值类型变量。因为只有引用类型的变量才能引用堆上的对象，而值类型变量直接包含值类型实例本身。</p>
<p><strong>基础概念：根</strong><br>在CLR中，将所有引用类型的变量称为<strong>根</strong>；<br>引用类型变量可以在许多场合使用：</p>
<ul>
<li>类的静态字段</li>
<li>类的实例字段</li>
<li>方法参数</li>
<li>局部变量<br>这些内容都可以成为根。</li>
</ul>
<h3 id="3-2-1-算法实现"><a href="#3-2-1-算法实现" class="headerlink" title="3.2.1 算法实现"></a>3.2.1 算法实现</h3><p><strong>第一阶段：暂停阶段</strong><br>暂停进程中的所有线程。这防止线程在CLR检查期间访问对象并更改其状态；</p>
<p><strong>第二阶段：标记阶段</strong></p>
<ul>
<li>CLR 遍历堆中的所有对象，将同步块索引字段中的一位设为 0；<em>当此位设为 0 时，表示此对象应该被删除；为 1 时表示不用删除；</em></li>
<li>设置为 0 之后，表明所有对象都应删除。然后，CLR 检查所有活动根，查看它们引用了哪些对象。如果一个根包含null，CLR忽略这个根并继续检查下个根；</li>
<li>任何根如果引用了堆上的对象，CLR 都会标记那个对象，也就是将该对象的同步块索引中的位设为 1。一个对象被标记后，CLR 会检查那个对象中的根，标记它们引用的对象。如果发现对象已经标记，就不重新检查对象的字段。这就避免了因为循环引用而产生死循环。</li>
<li>全部检查完毕后，堆中的对象要么已标记，要么未标记。<ul>
<li>已标记的对象不能被垃圾回收，因为至少有一个根在引用它。这种对象是<strong>可达reachable</strong>的对象。因为应用程序代码可通过仍在引用它的变量抵达它；</li>
<li>未标记的对象是<strong>不可达unreachable</strong>的，因为应用程序中不存在使对象能被再次访问的根；</li>
</ul>
</li>
</ul>
<p>图示为回收之前的托管堆：<br><img src="/../../image/Pasted%20image%2020230828105510.png" alt="回收之前的托管堆"></p>
<p><strong>第三阶段：压缩阶段</strong><br>CLR对堆中已标记的对象进行“内存位置的转移，压缩所有幸存下来的对象，使它们占用连续的内存空间，如图所示：<br><img src="/../../image/Pasted%20image%2020230828105609.png" alt="垃圾回收之后的托管堆"></p>
<ul>
<li>压缩的好处：<ul>
<li>所有幸存对象在内存中紧挨在一起，恢复了引用的“局部化”，减小了应用程序的工作集，从而提升了将来访问这些对象时的性能；</li>
<li>解决了原生堆的空间碎片化问题；</li>
</ul>
</li>
<li>内存偏移<ul>
<li>在内存中移动了对象之后有一个问题待解决：引用幸存对象的根现在引用的还是对象最初在内存中的位置，而非移动之后的位置；</li>
<li>CLR要从每个根减去所引用的对象在内存中偏移的字节数，保证每个根还是引用和之前一样的对象–只是对象在内存中变换了位置；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>垃圾回收</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】1. CLR执行模型</title>
    <url>/2023/08/5aed3da140f6.html</url>
    <content><![CDATA[<p>将源代码编译成托管模块<br><strong>定义：公共语言运行时（Common Language Runtime，CLR）</strong><br>描绘：是一个可以由多种编程语言使用的”运行时”，其核心功能包括：</p>
<ol>
<li>内存管理</li>
<li>程序集加载</li>
<li>安全性</li>
<li>异常处理</li>
<li>线程同步<span id="more"></span></li>
</ol>
<h2 id="1-1-将源代码编译成托管模块"><a href="#1-1-将源代码编译成托管模块" class="headerlink" title="1.1 将源代码编译成托管模块"></a>1.1 将源代码编译成托管模块</h2><p><strong>定义：公共语言运行时（Common Language Runtime，CLR）</strong><br>描绘：是一个可以由多种编程语言使用的”运行时”，其核心功能包括：</p>
<ol>
<li>内存管理</li>
<li>程序集加载</li>
<li>安全性</li>
<li>异常处理</li>
<li>线程同步<br>这些功能可以由所有面向CLR的语言使用。基于CLR的托管语言和非托管C++语言，在系统层面后者可以进行更低级别的控制，可以完全按照自己的想法管理内存。而CLR不管开发者使用哪一种编程语言写源代码，只要其是面向CLR的。因此，CLR提供了其他技术所无法媲美的集成度，使得混合语言编程成为了开发者可以考虑的一个选项。<br>为了执行包含托管代码以及托管数据的模块，用户必须在自己的计算机上安装好CLR（目前作为.NET Framework的一部分被提供）</li>
</ol>
<p>补充：可将编译器是为语法检查其和“正确代码分析器”。</p>
<p><strong>定义：托管模块（managed module）</strong><br>描述：托管模块是标准的32位（PE32）或者64位（PE32+）的Microsoft Windows可移植体文件，基于CLR来运行。<br>托管模块四大部分：</p>
<ol>
<li>PE32 或 PE32+头：如果是依赖于本机CPU的代码，此项会包含和本机CPU相关的信息。</li>
<li>CLR头：包含使这个模块成为托管模块的信息，比如CLR版本，Main方法位置，MethodDef数据，模块元数据等</li>
<li>元数据：源代码的定义数据，源代码的引用数据</li>
<li>IL代码：编译器编译源代码时生成的代码，运行时CLR将IL编译成编辑CPU代码</li>
<li></li>
</ol>
<p><strong>定义：托管代码（managed code）</strong><br>描述：每个面向CLR的编译器生成的代码，都是IL代码（中间代码），IL代码又被称作托管代码。<br>IL代码比大部分CPU机器语言都更加高级，其可以访问和操作对象的类型，并且提供了指令来创建和初始化对象那个、调用对象上的虚方法以及直接操作数组元素。在此意义上，可以将IL理解成是一种<strong>面向对象的机器语言</strong>。<br>补充：使用高级语言只能使用CLR全部功能当中的一个子集，但IL汇编语言运行开发人员访问CLR全部功能。<br>逻辑关系：<br>![[Chapter 1：CLR执行模型 2023-03-07 19.16.22.excalidraw]]</p>
<h2 id="1-2-将托管模块合并成程序集"><a href="#1-2-将托管模块合并成程序集" class="headerlink" title="1.2 将托管模块合并成程序集"></a>1.2 将托管模块合并成程序集</h2><p><strong>定义：程序集（assembly）</strong><br>描述：CLR实际上并不和托管模块工作，而是和程序集工作。生成的程序集既可以时可执行文件，也可以是DLL，最终由CLR管理这些程序集中的代码的执行。<br>内容：</p>
<ol>
<li>程序集是一个或者多个模块&#x2F;资源文件的逻辑性分组；</li>
<li>程序集是重用、安全性以及版本控制的最小单元；</li>
<li>利用程序集，可以将一组文件作为一个单独的实体来对待；<br>优势：程序集把文件的逻辑表示和物理表示区分开，利用程序集可以在不同的地方部署文件，在使用到其时再进行下载，不使用其时可以无需下载，但是在对待程序集时确依然将其视为一个整体</li>
</ol>
<p>逻辑关系：<br>![[Chapter 1：CLR执行模型 2023-03-07 19.30.58.excalidraw]]</p>
<h2 id="1-3-加载公共语言运行时"><a href="#1-3-加载公共语言运行时" class="headerlink" title="1.3 加载公共语言运行时"></a>1.3 加载公共语言运行时</h2><p><strong>简介</strong><br>在CLR运行之前，需要设置其平台选项指定最后生成的程序集能够在指定的平台上运行。</p>
<p><strong>CLR运行前设置：设置不同CPU版本</strong><br>在CLR加载之前，C#编译器提供了一个&#x2F;platform的命令行选项，允许指定最后生成的程序集能够在指定的平台上运行。<br>取决于&#x2F;platform开关选项，C#编译器生成的程序集要么包含PE32，要么是PE32+，在可执行文件运行前，Windows会检查文件头，判断需要的是32位还是64位的地址空间。<br>之后，Windows检查EXE文件头，决定创建32位或者64位进程，并在进程地址空间加载MSCorEE.dll的x86、x64或者ARM版本。</p>
<p><strong>MSCorEE.dll</strong><br>进程在Windows当中检查文件头后，需要决定创建32位或者64位进程，之后会在进程的地址空间内加载MSCorEE.dll的对应CPU版本，其不同版本都在<code>%SystemRoot%\System32</code>或者<code>%SystemRoot%\SysWow64</code>目录中。之后进程的主线程调用MSCorEE当中的定义的一个方法，此方法初始化CLR，并加载EXE程序集，调用入口方法Main。</p>
<p><strong>加载CLR</strong></p>
<ol>
<li>可执行文件运行前，Windows会检查文件头，判断需要的是32位还是64位的地址空间。</li>
<li>Windows检查EXE文件头，决定创建32位或者64位进程，并在进程地址空间加载MSCorEE.dll的x86、x64或者ARM版本。</li>
<li>进程的主线程调用MSCorEE.dll中定义的一个方法，此方法初始化CLR，加载EXE程序集，调用其入口方法Main，然后托管应用程序启动并运行。</li>
</ol>
<p>![[Chapter 1：CLR执行模型 2023-03-07 20.10.16.excalidraw]]</p>
<h2 id="1-4-执行程序集的代码"><a href="#1-4-执行程序集的代码" class="headerlink" title="1.4 执行程序集的代码"></a>1.4 执行程序集的代码</h2><p>定义：即时编译器（Just in time，JIT）<br>描述：在执行程序集中IL代码的方法后，需要将IL代码转换成本机（native）指令，此时就由CLR当中的JIT编译器来实现。JIT编译器动态的将本机CPU代码存储到动态内存中，因此一旦应用程序停止，编译好的代码也会被丢弃，之后再次启动或者存在两个实例时需要在此编译。</p>
<p>定义：记录项<br>描述：CLR会分配一个内部的数据结构来管理对引用类型的访问。CLR将引用的类型当中的每个方法都设置一个记录项，这个记录项都含有一个地址，此地址指向该方法的具体实现。当JIT访问记录项，想编译对应函数时，即可顺着此记录项找到对应IL代码。</p>
<p><strong>执行过程</strong><br>在Main方法执行之前，CLR检测出Main代码引用的所有类型，导致CLR分配一个内部的数据结构来管理对引用类型的访问。CLR将引用的类型当中的每个方法都设置一个记录项， CLR将每个记录项设置为包含在CLR内部的一个未编档函数，此函数为JITCompiler。在调用对应方法时，JITCompiler被调用，查询元数据找到IL代码，并且将此IL代码编译成本机CPU指令。<br>本机CPU代码动态分配到内存块当中，然后JITCompiler回到CLR为类型创建的内部数据结构，找到被调用方法对应的那条记录，将其修改（原本为对JITCompiler的引用）为指向CPU代码的内存块。第二次验证时，会跳过JITCompiler函数，直接执行内存块当中的代码。因为第二次调用不需要编译，因此只有在首次调用时有一些性能损失。</p>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>CLR</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】托管堆与垃圾回收（2）-- 基于代的垃圾回收算法</title>
    <url>/2023/08/2d466e9f916b.html</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="1-垃圾回收的基本假设"><a href="#1-垃圾回收的基本假设" class="headerlink" title="1.垃圾回收的基本假设"></a>1.垃圾回收的基本假设</h1><p>由于CLR的GC是基于代的垃圾回收器算法，因此其对代码做出了以下几点假设：</p>
<ul>
<li><ol>
<li>对象越新，生存期越短；</li>
</ol>
</li>
<li><ol start="2">
<li>对象越老，生存期越长；</li>
</ol>
</li>
<li><ol start="3">
<li>回收堆的一部分，速度快于回收整个堆；<br>以上假设对于大部分的现代应用程序都成立，其影响了下面GC算法的实现。</li>
</ol>
</li>
</ul>
<h1 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h1><h2 id="2-1-初始化堆与第0代对象"><a href="#2-1-初始化堆与第0代对象" class="headerlink" title="2.1 初始化堆与第0代对象"></a>2.1 初始化堆与第0代对象</h2><p><strong>实现过程</strong></p>
<ul>
<li>预算容量<ul>
<li>CLR初始化时，为第0代对象选择一个预算容量。</li>
</ul>
</li>
<li>启动垃圾回收<ul>
<li>如果分配一个新对象造成第0代超过预算，就必须立马就启动一次垃圾回收。</li>
<li>假设此时初始化时分配的对象刚好用完第0代的空间，那么分配下一个对象就必须启动垃圾回收。</li>
</ul>
</li>
<li>压缩对象<ul>
<li>垃圾回收器判断对象C和E是垃圾，所以会压缩对象D，使之与对象B相邻。</li>
</ul>
</li>
<li>进入第1代<ul>
<li>在垃圾回收中存活的对象A，B和D现在成为第1代对象。第1代对象已经经历了垃圾回收器的一次检查；</li>
<li>此时第0代不包含任何对象，当下一次再分配内存时，新对象会被继续分配到第0代之中；</li>
</ul>
</li>
</ul>
<p><strong>图片展示</strong><br>初始化堆：<br><img src="/../../image/Pasted%20image%2020230829101037.png"></p>
<p>启动垃圾回收+压缩对象+进入第1代：<br><img src="/../../image/Pasted%20image%2020230829101102.png"></p>
<h2 id="2-2-从第0代对象到第1代对象"><a href="#2-2-从第0代对象到第1代对象" class="headerlink" title="2.2 从第0代对象到第1代对象"></a>2.2 从第0代对象到第1代对象</h2><p><strong>实现过程</strong></p>
<ul>
<li>继续分配<ul>
<li>新分配的对象继续进入第0代；</li>
<li>部分对象（包含第1代与第0代）在程序运行时，逐渐变得不可达；</li>
</ul>
</li>
<li>启动垃圾回收<ul>
<li>新对象造成第0代超出预算；</li>
</ul>
</li>
<li>决定GC检查代<ul>
<li>垃圾回收器必须决定检查哪些代。开始一次垃圾回收时，垃圾回收器除了检查第0代时，还会检查第1代占用了多少内存。</li>
<li>在下图中，由于第1代占用的内存远少于预算，所以垃圾回收器只检查第0代中的对象；</li>
</ul>
</li>
</ul>
<p><strong>基本假设与基于代的GC</strong></p>
<ul>
<li>假设一：对象越新，生存期越短<ul>
<li>因为新的对象在第0代中，并且第0代包含更多垃圾的可能性很大，在GC时能回收更多的内存；</li>
<li>即<strong>对象越新，生存期越短</strong></li>
<li>并且由于忽略了第1代中的对象，所以加快了垃圾回收速度</li>
</ul>
</li>
<li>假设三：回收堆的一部分，速度快于回收整个堆<ul>
<li>忽略第1代中的对象能提升垃圾回收器的性能。对性能有更大提振作用的是：现在不必遍历托管堆中的每个对象；</li>
<li>如果根或对象引用了老一代的某个对象，垃圾回收器就可以忽略老对象内部的所有引用，能在更短的时间内构造好可达对象图；</li>
</ul>
</li>
</ul>
<p><strong>图片展示</strong><br>产生新对象，垃圾产生：<br><img src="/../../image/Pasted%20image%2020230829101709.png"></p>
<p>垃圾回收，对象压缩：<br><img src="/../../image/Pasted%20image%2020230829101728.png"></p>
<h2 id="2-3-从第1代对象到第2代对象"><a href="#2-3-从第1代对象到第2代对象" class="headerlink" title="2.3 从第1代对象到第2代对象"></a>2.3 从第1代对象到第2代对象</h2><p><strong>实现过程</strong></p>
<ul>
<li>全部预算已满<ul>
<li>假定第1代的增长导致它的所有对象占用了全部预算。此时应用程序继续运行并分配对象，使第0代对象达到它的预算容量；</li>
<li>此时由于第0代已满，必须进行垃圾回收；</li>
<li>此次垃圾回收时发现第1代占用太多空间，导致全部预算用完（并且第1代当中已经有很多对象变得不可达）；</li>
<li>此次垃圾回收需要堆第0代以及第1代对象进行回收；</li>
</ul>
</li>
<li>产生第2代<ul>
<li>经过垃圾回收，产生第2代对象；第0代继续空余出来；</li>
<li><strong>只有在第1代超出预算时才会检查第1代中的对象</strong></li>
</ul>
</li>
</ul>
<p><strong>托管堆与代</strong></p>
<ul>
<li>3代托管堆<ul>
<li>托管堆只支持三代：第0代、第1代和第2代，没有第3代。</li>
</ul>
</li>
<li>代与预算<ul>
<li>CLR初始化时，会为每一代选择预算；</li>
</ul>
</li>
<li>CLR 的垃圾回收器是自调节的<ul>
<li>垃圾回收器会在执行垃圾回收的过程中了解应用程序的行为；<ul>
<li>假定应用程序构造了许多对象，但每个对象用的时间都很短。在这种情况下，对第0代的垃圾回收会回收大量内存；</li>
<li>事实上，第0代的所有对象都可能被回收；</li>
</ul>
</li>
<li><strong>当GC发现回收0代后存活下来的对象很少，就可能减少第0代的预算，反之增加预算</strong>。这种启发式的算法对第1代以及第2代通用适用；</li>
<li>每当垃圾回收进行后，会检查存活下来的对象多少，进而增大或减小这些代的预算；</li>
</ul>
</li>
</ul>
<h1 id="3-垃圾回收触发条件"><a href="#3-垃圾回收触发条件" class="headerlink" title="3.垃圾回收触发条件"></a>3.垃圾回收触发条件</h1><p><strong>垃圾回收可以有以下几种触发条件</strong></p>
<ol>
<li>CLR检测垃圾回收超出代的预算；</li>
<li>代码显示调用System.GC的静态方法Collect；</li>
<li>Windows报告低内存情况；</li>
<li>CLR卸载AppDomain；</li>
<li>CLR关闭；</li>
</ol>
<p><strong>强制垃圾回收</strong><br>System.GC类型允许应用程序对垃圾回收器进行一些直接控制。可以用Collect进行强制垃圾回收，但大部分情况下不推荐。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Collect</span>(<span class="params">Int32 generation,GCCollectionMode mode,Boolean blocking</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>generation<ul>
<li>表示回收第几代的垃圾</li>
</ul>
</li>
<li>GCCollectionMode<ul>
<li>Default：不传递任何符号名称；</li>
<li>Forced：强制回收指定的代(以及低于它的所有代)；</li>
<li>Optimized：只有在能释放大量内存或者能减少碎片化的前提下，才执行回收（强制执行Collect时，尽可能使用这种模式）；</li>
</ul>
</li>
</ul>
<h2 id="3-1-监视垃圾回收内存使用"><a href="#3-1-监视垃圾回收内存使用" class="headerlink" title="3.1 监视垃圾回收内存使用"></a>3.1 监视垃圾回收内存使用</h2><p><strong>监视用方法</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">Int32 <span class="title">CollectionCount</span>(<span class="params">Int32 generation</span>)</span>;</span><br><span class="line"><span class="function">Int64 <span class="title">GetTotalMemory</span>(<span class="params">Boolean forceFullCollection</span>)</span>;</span><br></pre></td></tr></table></figure>
<h1 id="4-大对象"><a href="#4-大对象" class="headerlink" title="4.大对象"></a>4.大对象</h1><p><strong>什么是大对象</strong><br>在CLR当中，将对象分为大对象和小对象，大于85000字节的对象是大对象；</p>
<p><strong>大对象特点</strong></p>
<ul>
<li>大对象在进程地址空间其他地方分配；</li>
<li>目前的GC不压缩大对象；</li>
<li>大对象总是第2代的，不可能为第0、1代；</li>
</ul>
<h1 id="5-垃圾回收模式"><a href="#5-垃圾回收模式" class="headerlink" title="5.垃圾回收模式"></a>5.垃圾回收模式</h1><p><strong>两种基本的GC模式</strong></p>
<ul>
<li>工作站模式<ul>
<li>该模式针对客户端应用程序优化GC；</li>
<li><strong>CLR默认以工作站模式运行</strong></li>
<li>GC造成的延时很低，应用程序的线程挂起时间短，并且GC假定机器上运行的其他应用程序都不会消耗太多的CPU资源；</li>
</ul>
</li>
<li>服务器模式<ul>
<li>该模式针对服务器端应用程序优化GC；</li>
<li>被优化的主要是吞吐量和资源利用。GC假定机器上没有运行其他应用程序，并假定机器的所有CPU都可用来辅助完成GC；</li>
<li>该模式造成托管堆被拆分成几个区域，每个CPU一个；</li>
<li>开始垃圾回收时，垃圾回收器在每个CPU上都运行一个特殊线程，每个线程都和其他线程并发回收它自己的区域；</li>
<li>这个功能要求应用程序在多CPU计算机上运行使线程能真正地同时工作，从而获得性能的提升。</li>
</ul>
</li>
</ul>
<p><strong>切换工作模式</strong><br>GCLatencyMode定义四种模式：</p>
<ol>
<li>Batch：服务器GC模式的默认值，关闭并发GC；</li>
<li>Interactive：工作站GC模式的默认值，打开并发GC；</li>
<li>LowLatency：此模式时，GC将全力避免第2代垃圾的回收。更容易抛出内存溢出异常；</li>
<li>SustainedLowLatency；</li>
</ol>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>垃圾回收</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 10：状态机模型的应用</title>
    <url>/2023/08/f8b821c31d0a.html</url>
    <content><![CDATA[<ul>
<li>状态机的确定性<ul>
<li>概念<ul>
<li>每一个状态都有一个确定的下一个状态</li>
<li>不确定的状态机，状态之后会有不同的分支状态</li>
</ul>
</li>
<li>宏观物理世界<ul>
<li>近似于决定性的状态机，状态之间用于牛顿机械式的逻辑关系</li>
<li>例子：Game Of Life</li>
</ul>
</li>
<li>微观物理世界<span id="more"></span></li>
</ul>
</li>
</ul>
<h2 id="10-1-状态机模型的物理世界应用"><a href="#10-1-状态机模型的物理世界应用" class="headerlink" title="10.1 状态机模型的物理世界应用"></a>10.1 状态机模型的物理世界应用</h2><h3 id="10-1-1-世界状态的确定性分析"><a href="#10-1-1-世界状态的确定性分析" class="headerlink" title="10.1.1 世界状态的确定性分析"></a>10.1.1 世界状态的确定性分析</h3><ul>
<li>状态机的确定性<ul>
<li>概念<ul>
<li>每一个状态都有一个确定的下一个状态</li>
<li>不确定的状态机，状态之后会有不同的分支状态</li>
</ul>
</li>
<li>宏观物理世界<ul>
<li>近似于决定性的状态机，状态之间用于牛顿机械式的逻辑关系</li>
<li>例子：Game Of Life</li>
</ul>
</li>
<li>微观物理世界</li>
</ul>
</li>
</ul>
<h3 id="10-1-2-状态机模型的应用"><a href="#10-1-2-状态机模型的应用" class="headerlink" title="10.1.2 状态机模型的应用"></a>10.1.2 状态机模型的应用</h3><p>这里不知道为什么会出现问题。。。</p>
<h2 id="在决定性的数学公理体系下，状态机模型的使用1-数学严谨的体系下，解释平行宇宙2-细胞的状态分析与还原"><a href="#在决定性的数学公理体系下，状态机模型的使用1-数学严谨的体系下，解释平行宇宙2-细胞的状态分析与还原" class="headerlink" title="在决定性的数学公理体系下，状态机模型的使用1. 数学严谨的体系下，解释平行宇宙2. 细胞的状态分析与还原"></a>在决定性的数学公理体系下，状态机模型的使用<br>1. 数学严谨的体系下，解释平行宇宙<br>2. 细胞的状态分析与还原</h2><h2 id="10-2-状态机模型下的编译器和现代CPU"><a href="#10-2-状态机模型下的编译器和现代CPU" class="headerlink" title="10.2 状态机模型下的编译器和现代CPU"></a>10.2 状态机模型下的编译器和现代CPU</h2><h3 id="10-2-1-编译器模型"><a href="#10-2-1-编译器模型" class="headerlink" title="10.2.1 编译器模型"></a>10.2.1 编译器模型</h3><h2 id="编译器：从源代码S（状态机）-二进制代码C（状态机）在不同的SystemCall之中，保证语义一致性（保证结果的最终一致）-10-2-2-编译器优化的正确性核心：源代码状态机和二进制状态机的可观测行为的一致性例子：现代的CPU在一个时钟周期当中可以执行两条指令甚至更多-10-2-3-查看状态机执行程序执行-状态机执行例子：通过strace观测系统调用的行为以及所花费的时间。-查看所有的状态机行为-方法：使用GDB进行调试-单步调试-反汇编调试-通过调试器展示的状态的一部分-寄存器-内存-变量状态机视角下，Debug可进行的行为：1-复制当前状态机的状态2-回溯状态机的上一个状态3-进入状态机的下一个状态4-记录一个状态机的完整执行-状态机的状态回溯-概念：-虽然当前程序的状态机的状态可能十分复杂，但是在不同指令之间进行执行时，如果只是将指令的行为记录下来，即可回走-每次状态切换时更改的内容有效-例子：-在一个用于随机情况的方法条件下，可以通过gcc的record将状态记录下来-，当想要还原这个随机性的Bug时只需要恢复当时的状态即可实现-记录状态机的完整执行-决定性程序：-如果程序是完全决定性的，只要程序的初始状态知道，之后的状态都可以据此由此复现出来-拥有系统调用、Random的程序：-待记录内容：-1-指令数-2-结果-3-n份以上内容-可使用此功能-指令：-rr-record-想记录下函数的全部行为：-需要知道从上一条指令到下一条指令有多少决定性的指-令-程序的io-程序的中断-程序可以完整的记录程序的执行-例子：老游戏的replay"><a href="#编译器：从源代码S（状态机）-二进制代码C（状态机）在不同的SystemCall之中，保证语义一致性（保证结果的最终一致）-10-2-2-编译器优化的正确性核心：源代码状态机和二进制状态机的可观测行为的一致性例子：现代的CPU在一个时钟周期当中可以执行两条指令甚至更多-10-2-3-查看状态机执行程序执行-状态机执行例子：通过strace观测系统调用的行为以及所花费的时间。-查看所有的状态机行为-方法：使用GDB进行调试-单步调试-反汇编调试-通过调试器展示的状态的一部分-寄存器-内存-变量状态机视角下，Debug可进行的行为：1-复制当前状态机的状态2-回溯状态机的上一个状态3-进入状态机的下一个状态4-记录一个状态机的完整执行-状态机的状态回溯-概念：-虽然当前程序的状态机的状态可能十分复杂，但是在不同指令之间进行执行时，如果只是将指令的行为记录下来，即可回走-每次状态切换时更改的内容有效-例子：-在一个用于随机情况的方法条件下，可以通过gcc的record将状态记录下来-，当想要还原这个随机性的Bug时只需要恢复当时的状态即可实现-记录状态机的完整执行-决定性程序：-如果程序是完全决定性的，只要程序的初始状态知道，之后的状态都可以据此由此复现出来-拥有系统调用、Random的程序：-待记录内容：-1-指令数-2-结果-3-n份以上内容-可使用此功能-指令：-rr-record-想记录下函数的全部行为：-需要知道从上一条指令到下一条指令有多少决定性的指-令-程序的io-程序的中断-程序可以完整的记录程序的执行-例子：老游戏的replay" class="headerlink" title="编译器：从源代码S（状态机）-&gt; 二进制代码C（状态机）在不同的SystemCall之中，保证语义一致性（保证结果的最终一致）### 10.2.2 编译器优化的正确性核心：源代码状态机和二进制状态机的可观测行为的一致性例子：现代的CPU在一个时钟周期当中可以执行两条指令甚至更多### 10.2.3 查看状态机执行程序执行 &#x3D; 状态机执行例子：通过strace观测系统调用的行为以及所花费的时间。+ 查看所有的状态机行为    + 方法：使用GDB进行调试        + 单步调试        + 反汇编调试    + 通过调试器展示的状态的一部分        + 寄存器        + 内存        + 变量状态机视角下，Debug可进行的行为：1. 复制当前状态机的状态2. 回溯状态机的上一个状态3. 进入状态机的下一个状态4. 记录一个状态机的完整执行+ 状态机的状态回溯    + 概念：        + 虽然当前程序的状态机的状态可能十分复杂，但是在不同指令之间进行执行时，如果只是将指令的行为记录下来，即可回走        + 每次状态切换时更改的内容有效    + 例子：        + 在一个用于随机情况的方法条件下，可以通过gcc的record将状态记录下来 ，当想要还原这个随机性的Bug时只需要恢复当时的状态即可实现+ 记录状态机的完整执行    + 决定性程序：        + 如果程序是完全决定性的，只要程序的初始状态知道，之后的状态都可以据此由此复现出来    + 拥有系统调用、Random的程序：        + 待记录内容：        + 1. 指令数        + 2. 结果        + 3. n份以上内容    + 可使用此功能        + 指令：            + rr record        + 想记录下函数的全部行为：            + 需要知道从上一条指令到下一条指令有多少决定性的指 令            + 程序的io            + 程序的中断        + 程序可以完整的记录程序的执行            + 例子：老游戏的replay"></a>编译器：从源代码S（状态机）-&gt; 二进制代码C（状态机）<br>在不同的SystemCall之中，保证语义一致性（保证结果的最终一致）<br>### 10.2.2 编译器优化的正确性<br><strong>核心：源代码状态机和二进制状态机的可观测行为的一致性</strong><br>例子：现代的CPU在一个时钟周期当中可以执行两条指令甚至更多<br>### 10.2.3 查看状态机执行<br>程序执行 &#x3D; 状态机执行<br>例子：通过strace观测系统调用的行为以及所花费的时间。<br>+ 查看所有的状态机行为<br>    + 方法：使用GDB进行调试<br>        + 单步调试<br>        + 反汇编调试<br>    + 通过调试器展示的状态的一部分<br>        + 寄存器<br>        + 内存<br>        + 变量<br>状态机视角下，Debug可进行的行为：<br>1. 复制当前状态机的状态<br>2. 回溯状态机的上一个状态<br>3. 进入状态机的下一个状态<br>4. 记录一个状态机的完整执行<br>+ 状态机的状态回溯<br>    + 概念：<br>        + 虽然当前程序的状态机的状态可能十分复杂，但是在不同指令之间进行执行时，如果只是将指令的行为记录下来，即可回走<br>        + 每次状态切换时更改的内容有效<br>    + 例子：<br>        + 在一个用于随机情况的方法条件下，可以通过gcc的record将状态记录下来 ，当想要还原这个随机性的Bug时只需要恢复当时的状态即可实现<br>+ 记录状态机的完整执行<br>    + 决定性程序：<br>        + 如果程序是完全决定性的，只要程序的初始状态知道，之后的状态都可以据此由此复现出来<br>    + 拥有系统调用、Random的程序：<br>        + 待记录内容：<br>        + 1. 指令数<br>        + 2. 结果<br>        + 3. n份以上内容<br>    + 可使用此功能<br>        + 指令：<br>            + rr record<br>        + 想记录下函数的全部行为：<br>            + 需要知道从上一条指令到下一条指令有多少决定性的指 令<br>            + 程序的io<br>            + 程序的中断<br>        + 程序可以完整的记录程序的执行<br>            + 例子：老游戏的replay</h2><h2 id="10-3-状态机与性能分析"><a href="#10-3-状态机与性能分析" class="headerlink" title="10.3 状态机与性能分析"></a>10.3 状态机与性能分析</h2><h3 id="10-3-1-采样状态机的执行"><a href="#10-3-1-采样状态机的执行" class="headerlink" title="10.3.1 采样状态机的执行"></a>10.3.1 采样状态机的执行</h3><h2 id="每当想进行性能优化的时候，总是要停下来想想，当下是否适合作性能优化。性能分析的核心原则：Premature-optimization-is-the-root-of-all-exil-问题：如何在代价很低的方法下，获得程序的summary（）？即获得性能摘要-性能优化的时机-分析程序在时间和空间上的调用-时间-空间-10-3-2-Profiler和性能摘要单点调试的问题：当使用gdb单点调试时，程序需要在每个指令下停止下来，无法测算每个指令执行的速度。此时只需要关注状态机的整体行为，观察程序在某一段时间中的关键信息（CPU、GPU、内存）数据。实现此步骤的方法是：中断-中断-概念：基于中断的机制，程序此时会进入到OS的代码。此时OS的代码可以访问到程序中断前的状态，并将此状态进行采样与输出-10-3-2-1-基于gcc进行性能摘要输出当前程序性能摘要：结果：-Pasted-image-20230222163118-png-将整个程序的Profiler记录，并打开报告：获得的每一条指令的时间：-Pasted-image-20230222163358-png-10-3-3-实际中的性能优化百分之八十的时间都消耗在了百分之二十的代码上-工业界面到的性能优化-实际情况：木桶效应-每个部分都已经优化到了局部最优解"><a href="#每当想进行性能优化的时候，总是要停下来想想，当下是否适合作性能优化。性能分析的核心原则：Premature-optimization-is-the-root-of-all-exil-问题：如何在代价很低的方法下，获得程序的summary（）？即获得性能摘要-性能优化的时机-分析程序在时间和空间上的调用-时间-空间-10-3-2-Profiler和性能摘要单点调试的问题：当使用gdb单点调试时，程序需要在每个指令下停止下来，无法测算每个指令执行的速度。此时只需要关注状态机的整体行为，观察程序在某一段时间中的关键信息（CPU、GPU、内存）数据。实现此步骤的方法是：中断-中断-概念：基于中断的机制，程序此时会进入到OS的代码。此时OS的代码可以访问到程序中断前的状态，并将此状态进行采样与输出-10-3-2-1-基于gcc进行性能摘要输出当前程序性能摘要：结果：-Pasted-image-20230222163118-png-将整个程序的Profiler记录，并打开报告：获得的每一条指令的时间：-Pasted-image-20230222163358-png-10-3-3-实际中的性能优化百分之八十的时间都消耗在了百分之二十的代码上-工业界面到的性能优化-实际情况：木桶效应-每个部分都已经优化到了局部最优解" class="headerlink" title="每当想进行性能优化的时候，总是要停下来想想，当下是否适合作性能优化。性能分析的核心原则：Premature optimization is the root of all exil.问题：如何在代价很低的方法下，获得程序的summary（）？即获得性能摘要+ 性能优化的时机    + 分析程序在时间和空间上的调用    + 时间    + 空间### 10.3.2 Profiler和性能摘要单点调试的问题：当使用gdb单点调试时，程序需要在每个指令下停止下来，无法测算每个指令执行的速度。此时只需要关注状态机的整体行为，观察程序在某一段时间中的关键信息（CPU、GPU、内存）数据。实现此步骤的方法是：中断+ 中断    + 概念：基于中断的机制，程序此时会进入到OS的代码。此时OS的代码可以访问到程序中断前的状态，并将此状态进行采样与输出#### 10.3.2.1 基于gcc进行性能摘要输出当前程序性能摘要：结果：![[Pasted image 20230222163118.png]]将整个程序的Profiler记录，并打开报告：获得的每一条指令的时间：![[Pasted image 20230222163358.png]]### 10.3.3 实际中的性能优化百分之八十的时间都消耗在了百分之二十的代码上+ 工业界面到的性能优化    + 实际情况：木桶效应    + 每个部分都已经优化到了局部最优解"></a>每当想进行性能优化的时候，总是要停下来想想，当下是否适合作性能优化。<br><em>性能分析的核心原则：Premature optimization is the root of all exil.</em><br>问题：如何在代价很低的方法下，获得程序的summary（）？即获得性能摘要<br>+ 性能优化的时机<br>    + 分析程序在时间和空间上的调用<br>    + 时间<br>    + 空间<br>### 10.3.2 Profiler和性能摘要<br><strong>单点调试的问题：</strong><br>当使用gdb单点调试时，程序需要在每个指令下停止下来，无法测算每个指令执行的速度。此时只需要关注状态机的整体行为，观察程序在某一段时间中的关键信息（CPU、GPU、内存）数据。<br>实现此步骤的方法是：中断<br>+ 中断<br>    + 概念：基于中断的机制，程序此时会进入到OS的代码。此时OS的代码可以访问到程序中断前的状态，并将此状态进行采样与输出<br>#### 10.3.2.1 基于gcc进行性能摘要<br>输出当前程序性能摘要：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">perf stat ./a.out </span><br></pre></td></tr></table></figure><br>结果：<br>![[Pasted image 20230222163118.png]]<br>将整个程序的Profiler记录，并打开报告：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">perf record ./a.out</span><br><span class="line">perf report</span><br></pre></td></tr></table></figure><br>获得的每一条指令的时间：<br>![[Pasted image 20230222163358.png]]<br>### 10.3.3 实际中的性能优化<br>百分之八十的时间都消耗在了百分之二十的代码上<br>+ 工业界面到的性能优化<br>    + 实际情况：木桶效应<br>    + 每个部分都已经优化到了局部最优解</h2><h2 id="10-4-状态机与程序验证"><a href="#10-4-状态机与程序验证" class="headerlink" title="10.4 状态机与程序验证"></a>10.4 状态机与程序验证</h2><h3 id="10-4-1-现在的Model-Check工具"><a href="#10-4-1-现在的Model-Check工具" class="headerlink" title="10.4.1 现在的Model Check工具"></a>10.4.1 现在的Model Check工具</h3><p>概念：状态机模型可以用于证明程序的正确性。使用bfs便利所有的状态，再使用execute给定一个并发程序的调度。<br>例子：for程序的并发Bug<br>**学术界的Model Check工具</p>
<ol>
<li>NASA的Java PathFinder：把Model Check扩充到了所有的Java代码</li>
<li>Spin：只可以使用其自己定义的语言</li>
<li>TLA Plus：用于亚马逊的并发式程序的正确性验证</li>
</ol>
<ul>
<li>现在的Model Check在分布式系统上的应用<ul>
<li>并发系统：<ul>
<li>分布式系统也是一种并发系统，但是其问题更大</li>
<li>并发系统假设其所有的节点都能够正常工作</li>
</ul>
</li>
<li>分布式系统<ul>
<li>在分布式系统中，必须假设所有的节点都可能出错（丢失）</li>
<li>在节点丢失的情况下还能进行tutorial</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="10-4-2-Model-Check可以做什么"><a href="#10-4-2-Model-Check可以做什么" class="headerlink" title="10.4.2 Model Check可以做什么"></a>10.4.2 Model Check可以做什么</h3><p>当探索不确定性程序的执行时，Model Check可以检查任何程序的执行；<br>Model Check可以检测当前不确定程序的任何一种可能性，并检查出Bug。</p>
<ul>
<li>不确定<ul>
<li>输入不确定</li>
<li>随机函数不确定<br>面对不确定性程序，可以检测程序的所有可能性空间<br><strong>问题：程序的状态空间太大</strong></li>
</ul>
</li>
</ul>
<ol>
<li>如何将这个状态的可能性减少？</li>
<li>如何将状态合并？</li>
<li>如何将状态往后延迟？</li>
</ol>
<ul>
<li>状态坍缩<ul>
<li>将大量可能性的状态转换为分支，延迟状态的展开，将状态合并，直到发现Bug再将其反向展开</li>
<li>分支成立：<ul>
<li>再检测有没有分支<ul>
<li>分支成立：<ul>
<li>在检测有没有分支：<ul>
<li>分支成立：<ul>
<li>当前红色的状态是否可达？</li>
<li>用约束求解器来计算</li>
<li>计算出当前程序的状态，此状态为Bug</li>
</ul>
</li>
<li>分支不成立：</li>
</ul>
</li>
</ul>
</li>
<li>分支不成立：</li>
</ul>
</li>
</ul>
</li>
<li>分支不成立：</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 11：操作系统上的进程</title>
    <url>/2023/08/5b1cbd3ab6e9.html</url>
    <content><![CDATA[<blockquote>
<pre><code>1. 操作系统启动后做了什么？
2. 操作系统如何管理进程？
</code></pre>
</blockquote>
<span id="more"></span>
<h2 id="11-1-进程与Linux"><a href="#11-1-进程与Linux" class="headerlink" title="11.1 进程与Linux"></a>11.1 进程与Linux</h2><h3 id="11-1-1-操作系统的第一个进程"><a href="#11-1-1-操作系统的第一个进程" class="headerlink" title="11.1.1 操作系统的第一个进程"></a>11.1.1 操作系统的第一个进程</h3><p>操作系统的第一条程序执行之后，接下来的行为就是创建其他的程序，然后就把操作系统的全部控制权交给程序，即操作系统树根上的程序。<br>操作系统只是创建第一个树根进程，然后其他进程由此树根进程创建。</p>
<p><strong>Linux进入之后加载第一个程序的代码：</strong><br>![[Pasted image 20230223142644.png]]</p>
<h4 id="11-1-1-1-gcc观看进程结构"><a href="#11-1-1-1-gcc观看进程结构" class="headerlink" title="11.1.1.1 gcc观看进程结构"></a>11.1.1.1 gcc观看进程结构</h4><p>以下shell指令执行后，将会输出当前OS的所有进程，而这些所有进程都是由根进程所创建：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pstree</span><br><span class="line">systemd ---..其他进程</span><br></pre></td></tr></table></figure>
<p>![[Pasted image 20230223142425.png]]</p>
<h3 id="11-1-2-最小Linux实现"><a href="#11-1-2-最小Linux实现" class="headerlink" title="11.1.2 最小Linux实现"></a>11.1.2 最小Linux实现</h3><p>最小Linux的树状结构：<br>![[Pasted image 20230223142955.png]]<br>initramfs打包选项：<br>![[Pasted image 20230223143107.png]]<br>Linux 运行：</p>
<ol>
<li>无图形界面</li>
<li>128m内存</li>
<li>linux内核</li>
<li>将initramfs<br>![[Pasted image 20230223143146.png]]<br>使用<code>make run</code>启动程序后，当前OS内核当中只有一个init在执行，此进程不可返回，不然OS就会发生Crash</li>
</ol>
<h4 id="11-1-2-1-OS内核链接至BusyBox"><a href="#11-1-2-1-OS内核链接至BusyBox" class="headerlink" title="11.1.2.1 OS内核链接至BusyBox"></a>11.1.2.1 OS内核链接至BusyBox</h4><p>将busybox链接至OS的<code>/bin/</code>目录下，生成的链接文件的名称为ps、arch、pst等这些Linux常见命令的名称，此时在OS中就可以直接使用这些程序。<br>只要当前程序是静态链接的，就可以被链接到OS当中</p>
<h3 id="11-1-3-略复杂一些的OS实现"><a href="#11-1-3-略复杂一些的OS实现" class="headerlink" title="11.1.3 略复杂一些的OS实现"></a>11.1.3 略复杂一些的OS实现</h3><p>内容：</p>
<ol>
<li>当中有更多挂载的磁盘</li>
<li>执行switch root系统调用，将initramfs销毁<br>把初始的文件系统销毁，然后创建一个新的文件系统</li>
</ol>
<p><strong>系统调用的三大类型</strong></p>
<ol>
<li>进程管理</li>
<li>文件管理</li>
<li>内存管理<br>有这三类系统调用，就可以实现整个OS世界</li>
</ol>
<hr>
<h2 id="11-2-进程与fork"><a href="#11-2-进程与fork" class="headerlink" title="11.2 进程与fork()"></a>11.2 进程与fork()</h2><p>OS必须要有一个创建进程的API，在Init加载了第一个进程后，使用fork()创建其他的进程</p>
<h3 id="11-2-1-什么是fork"><a href="#11-2-1-什么是fork" class="headerlink" title="11.2.1 什么是fork()"></a>11.2.1 什么是fork()</h3><p>当前进程有一个执行流，当执行到了fork()之后当前程序的执行流变成两条，完成分叉<br><strong>如何理解？</strong><br>操作系统在加载之后就创建了init这个状态机。当init执行了fork()后，执行流就会陷入到内核当中执行OS代码，fork会把当前进程状态机的状态完整复制一份，然后创建一个新的执行流</p>
<ul>
<li>完全一致的进程<ul>
<li>两个进程在内存上一模一样，寄存器一样</li>
<li>只有返回的值不一样：<ul>
<li>每一个进程都有一个唯一的编号</li>
<li>除了编号之外一切相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>当操作系统新创建了进程之后，就变成了一个并发程序。OS每一次可以选择一个进程执行一次（如果每一个时刻CPU只能执行一个）</p>
<h3 id="11-2-2-Fork-Bomb"><a href="#11-2-2-Fork-Bomb" class="headerlink" title="11.2.2 Fork Bomb"></a>11.2.2 Fork Bomb</h3><p>可以创建一个无限创建进程的程序，一开始的fork变成两个fork，每个创建的fork又可以创建fork，无休止创建下去。</p>
<h3 id="11-2-3-Fork行为分析"><a href="#11-2-3-Fork行为分析" class="headerlink" title="11.2.3 Fork行为分析"></a>11.2.3 Fork行为分析</h3><p>对于Fork创建进程的行为进行分析<br><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">2</span> ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fork();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i&lt;n ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行行为：</strong><br>第一次i &#x3D; 0时，进入for然后执行一次fork()，此时进程会进行分叉变成两个进程，两个进程拥有完全一致的状态，因此都会进入printf然后输出。<br>第二次i&#x3D;1时，当前已经有了两个fork，而这两个fork都会各自进行复制，因此会有四个进程取执行printf()然后输出Hello</p>
<p><strong>Printf行为分析：</strong><br>第一点：fork就只是一个无情的拷贝状态的机器<br>第二点：因为fork只是一个无情的状态拷贝机器，因此其会把库函数内部的状态也给其复制一份。<br>将Printf直接打印到屏幕上面：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>
<p>如果不适用fflush，库函数会先将其放在buffer当中。</p>
<ul>
<li>line buffer<ul>
<li>直接把每一行buffer输出出来</li>
</ul>
</li>
<li>full buffer<ul>
<li>只有满足buffer大小要求后才输出出来，不然就先给到buffer</li>
</ul>
</li>
</ul>
<p>fork的问题：多个线程下，fork的行为问题</p>
<h2 id="11-3-进程与execve"><a href="#11-3-进程与execve" class="headerlink" title="11.3 进程与execve()"></a>11.3 进程与execve()</h2><h3 id="11-3-1-execve行为"><a href="#11-3-1-execve行为" class="headerlink" title="11.3.1 execve行为"></a>11.3.1 execve行为</h3><p>fork创建了新的进程之后，可以检查其pid是否等于0，如果不为0则执行，进入背景现成，如果为0则为父进程，此时执行execve()，接着就会重置状态机，将当前运行的状态机重置为另一个程序的初始状态。<br>定义：execute the program referred to by pathname.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">exceve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span>* cons envp[])</span>;</span><br></pre></td></tr></table></figure>
<p>使用代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* <span class="type">const</span> argv[] = </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;env&quot;</span>,<span class="literal">NULL</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* <span class="type">const</span> envp[] = </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;HELLO=WORLD&quot;</span>,<span class="literal">NULL</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	execve(argv[<span class="number">0</span>],argv,envp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello,World\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-3-2-环境变量"><a href="#11-3-2-环境变量" class="headerlink" title="11.3.2 环境变量"></a>11.3.2 环境变量</h3><p>环境变量就是应用程序执行的环境，当状态机重置时，其他状态不变，当前状态机的状态被更改。<br>所有程序执行的第一行总是execvve，新的状态的启动总是要被重置，即使用execve</p>
<ul>
<li>环境变量<ul>
<li>PATH<ul>
<li>程序执行路径的环境变量</li>
</ul>
</li>
<li>PWD<ul>
<li>当前路径</li>
</ul>
</li>
<li>HOME<ul>
<li>HOME目录</li>
</ul>
</li>
<li>DISPLAY<ul>
<li>图形输出</li>
</ul>
</li>
<li>PS1<ul>
<li>shell提示符</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>LINUX也只不过是在这些环境变量当中找到 内容，然后执行</p>
<p><strong>PATH环境变量</strong><br>PATH就是可执行文件的搜索路径。当执行gcc之后，此时gcc的系统调用就是寻找其当前程序有可能的可执行文件的目录，搜索顺序就是PATH中指定的顺序。</p>
<hr>
<h2 id="11-4-进程与exit"><a href="#11-4-进程与exit" class="headerlink" title="11.4 进程与exit()"></a>11.4 进程与exit()</h2><p>进程需要进行销毁，当前状态机世界当中所有的状态都不变，除了当前执行exit()的进程直接从OS当中消失</p>
<ul>
<li>问题<ul>
<li>多线程的程序，exit的行为如何？</li>
<li>是所有线程结束还是只结束调用的线程？</li>
</ul>
</li>
<li>多种exit<ul>
<li>stdlib当中的exit</li>
<li>glibc当中的_exit(0)</li>
<li>syscall(SES_exit,0)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 12：进程的地址空间</title>
    <url>/2023/08/d03400aa93d7.html</url>
    <content><![CDATA[<p>程序就是状态机，C语言的状态机被转换成汇编语言的状态机，在汇编语言的状态机当中直接看到内存地址空间。</p>
<span id="more"></span>
<h2 id="12-1-动-静态链接程序地址空间"><a href="#12-1-动-静态链接程序地址空间" class="headerlink" title="12.1 动&#x2F;静态链接程序地址空间"></a>12.1 动&#x2F;静态链接程序地址空间</h2><p>当指针指向一个不合法的位置时会直接得到一个错误，如果往一个合法的地址无权限的写入，也会获得一个访问错误。但就指针本身而言，其可以指向任何地方。如果想要真正知道哪些地方是可读的，即当前程序的地址空间，如何实现?</p>
<h3 id="12-1-1-最小C程序的地址空间"><a href="#12-1-1-最小C程序的地址空间" class="headerlink" title="12.1.1 最小C程序的地址空间"></a>12.1.1 最小C程序的地址空间</h3><p>在gdb下获得进程的进程号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info inferiors</span><br></pre></td></tr></table></figure>

<p>查看某一个进程地址空间代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pmap 37491</span><br></pre></td></tr></table></figure>
<p>当中的37491为进程的id。</p>
<p><strong>查看结果：</strong><br>![[Pasted image 20230224190930.png]]</p>
<p><strong>可以使用strace指令来获取pmap指令的系统调用：</strong><br>当中一条系统调用：<br>![[Pasted image 20230224191620.png]]<br>除了可以用pmap之外，还可以直接在文件系统的proc中查看进程内存映射的关键信息。proc当中有进程的编号，命令行从属的父子关系，还有当前进程内存映射的关键信息</p>
<p><strong>37491进程更详细的信息：</strong><br>![[Pasted image 20230224191818.png]]<br>相关手册：<code>mam 5 proc</code></p>
<h4 id="12-1-1-1-将strace信息以Vim打开"><a href="#12-1-1-1-将strace信息以Vim打开" class="headerlink" title="12.1.1.1 将strace信息以Vim打开"></a>12.1.1.1 将strace信息以Vim打开</h4><p>代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace ./a.out &amp;| vim -A</span><br></pre></td></tr></table></figure>

<h3 id="12-1-2-静态链接程序的地址空间"><a href="#12-1-2-静态链接程序的地址空间" class="headerlink" title="12.1.2 静态链接程序的地址空间"></a>12.1.2 静态链接程序的地址空间</h3><p>以下是在proc当中读取的地址空间信息：<br>![[Pasted image 20230224192252.png]]<br>信息相比于前面最小的C程序要更多；<br>第一行：ELF文件头<br>第二行：因为有x表示可执行，所以为可执行代码<br>第三行：因为为只可读的数据，所以应该为字符串常量<br>第五行：可读可写，堆区</p>
<p>将以上读取的信息和其ELF信息比较着来看：<br>![[Pasted image 20230224192640.png]]</p>
<h3 id="12-1-3-动态链接程序的地址空间"><a href="#12-1-3-动态链接程序的地址空间" class="headerlink" title="12.1.3 动态链接程序的地址空间"></a>12.1.3 动态链接程序的地址空间</h3><p><strong>变化：</strong><br>相比于静态链接，动态链接程序的地址空间明显变得更复杂。并且其进程空间开始的地址相比于之前发生了较大的变化，因为OS进程地址随机化的机制，每一次动态链接程序的执行，其首地址空间位置都可能发生变化。<br>除此之外，还多了更多的映射区域。<br>以及一些没有文件的（但是可读可写）内存？是不是未初始化数据？如果在C程序当中分配一大段数组内存，此段空间将会承载此内容。<br><strong>通过改变程序的行为，观察程序的地址空间并且验证自己的假设。</strong></p>
<hr>
<h2 id="12-2-进程的地址空间管理"><a href="#12-2-进程的地址空间管理" class="headerlink" title="12.2 进程的地址空间管理"></a>12.2 进程的地址空间管理</h2><h3 id="12-2-1-VDSO、系统调用与非陷入式调用"><a href="#12-2-1-VDSO、系统调用与非陷入式调用" class="headerlink" title="12.2.1 VDSO、系统调用与非陷入式调用"></a>12.2.1 VDSO、系统调用与非陷入式调用</h3><p>操作系统上的程序是状态机，在程序当中有一类特殊的程序为SYSCALL系统调用，此指令会进入到操作系统内核执行，此时SYSCALL会因为转台的切换，带来更大的开销。<br>如何实现不进入OS内核的系统调用？</p>
<p>进程与时钟：<br>OS当中的进程是不知道时钟的，时钟本身是由OS维护的，这个时间原则上只有OS知道</p>
<p>程序中的time函数：<br>time函数没有进入libc，而是停在了vdso，把当前的地址相减寻址，得到一个不可访问的其他进程的地址。在执行了time函数之后，获得了一个极大的数值。<br>time函数可以在不进入操作系统内核的前提下，完成一个系统调用。因为在一片地址空间中，OS单独设置一块vvar，使得不进入OS的系统调用可以实现。因为这部分已经由OS提供了。</p>
<h3 id="12-2-2-系统调用的实现"><a href="#12-2-2-系统调用的实现" class="headerlink" title="12.2.2 系统调用的实现"></a>12.2.2 系统调用的实现</h3><p>一般教科书任何，需要通过中断来实现系统调用。但SYSCALL不需要int指令，就可以实现地址调用，甚至有更多</p>
<h3 id="12-2-3-mmap"><a href="#12-2-3-mmap" class="headerlink" title="12.2.3 mmap()"></a>12.2.3 mmap()</h3><p>操作系统需要提供一个机制来帮助我们管理地址空间;<br>OS需要提供相关指令，使得在程序执行的时候，在当前OS当中已有的内存当中找到一片新的内存，为其改变程序的地址空间，分配一片新的空间;<br>这个指令就是mmap；</p>
<p><strong>概念：</strong><br>mmap可以帮助程序在其状态当中，映射新的地址空间或者把已有的地址空间分配出去。在一个地址（addr）上面，映射一片长度为length的空间，向其传递访问的权限（prot），地址映射的方式（flags）。</p>
<p><strong>定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="type">int</span> fd,<span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>mmap与程序加载器</strong><br>由于在Linux的设计哲学当中，一切都是文件，因此mmap当中有一个fd，有一个offset，就可以直接把一个非常大的文件直接映射到地址空间当中，然后再后背访问多少再进行加载多少。</p>
<h3 id="12-2-4-程序基于mmap的加载行为"><a href="#12-2-4-程序基于mmap的加载行为" class="headerlink" title="12.2.4 程序基于mmap的加载行为"></a>12.2.4 程序基于mmap的加载行为</h3><p>当程序想要加载某些文件，比如libc库时，此时只需要读取程序的ELF头文件（当中包含了这些文件的地址，要加载到什么位置），得到需要映射的文件信息，然后使用mmap将这些信息映射到当前程序的地址空间，即可完成加载。</p>
<h3 id="12-2-5-应用：使用mmap申请大内存"><a href="#12-2-5-应用：使用mmap申请大内存" class="headerlink" title="12.2.5 应用：使用mmap申请大内存"></a>12.2.5 应用：使用mmap申请大内存</h3><p>在申请太多内存的时候，OS会直接拒绝此行为。<br>代码：<br>![[Pasted image 20230227174912.png]]</p>
<p><strong>代码解析：</strong><br>申请了3GB大小的内存，fd描述为1，读写它，一瞬间就完成。<br>使用strace观察行为可以知道，其只是使用mmap标记上了这段内存，在实际使用到的时候再进行加载。</p>
<h2 id="12-3-地址空间的隔离"><a href="#12-3-地址空间的隔离" class="headerlink" title="12.3 地址空间的隔离"></a>12.3 地址空间的隔离</h2><p>每一个指针只能访问当前进程的地址空间，mmap就是在当前程序的地址空间扩充一块，即mmap帮助了地址空间隔离的机制。</p>
<h3 id="12-3-1-老游戏修改器实现"><a href="#12-3-1-老游戏修改器实现" class="headerlink" title="12.3.1 老游戏修改器实现"></a>12.3.1 老游戏修改器实现</h3><p>命令与政府修改器实现的大致逻辑：</p>
<ul>
<li>第一步：获得游戏进程的PID（进程号）</li>
<li>第二步：由于Linux下的proc机制，其将程序的整个地址空间作为文件全部暴露出来了。可以将其作为文件使用<code>popen()</code>打开再扫过每一段内存。</li>
<li>第三步：使用解析代码<code>fscanf()</code>，找到每一段可读的内存</li>
<li>第四步：遍历此段内存，找到关键词数据</li>
<li>第五步：修改被关键字标记的内存</li>
</ul>
<h3 id="12-3-2-按键精灵-变速齿轮"><a href="#12-3-2-按键精灵-变速齿轮" class="headerlink" title="12.3.2 按键精灵&amp;变速齿轮"></a>12.3.2 按键精灵&amp;变速齿轮</h3><p>制作假的驱动，利用操作系统API模拟按下。<br>把游戏放在虚拟机上执行，可以任意调整时钟周期。</p>
<h3 id="12-3-3-代码注入"><a href="#12-3-3-代码注入" class="headerlink" title="12.3.3 代码注入"></a>12.3.3 代码注入</h3><p>在OS下，既可以改内存，也可以改代码。</p>
<h4 id="12-3-3-1-代码热更新原理"><a href="#12-3-3-1-代码热更新原理" class="headerlink" title="12.3.3.1 代码热更新原理"></a>12.3.3.1 代码热更新原理</h4><p>当程序当中有以下代码的时候，两次函数会输出一样的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is old function&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo_new</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is new function&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	foo();</span><br><span class="line">	foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果代码执行热更新后，可以在运行时动态更改当前函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DSU</span><span class="params">(<span class="type">void</span>* old , <span class="type">void</span>* new)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ROUNDDOWN(ptr) ((void*)(((uintptr_t)ptr) &amp;~0xfff))</span></span><br><span class="line">	<span class="type">size_t</span> pg_size = ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>![[Pasted image 20230227204316.png]]<br>在原本的代码区中，将部分需要更新的代码更改为其他代码。<br>获得原本的代码地址，使用mprotect()函数将这片地址只读属性改成读写属性，然后再把新的地址（新函数的地址）给填写进去。</p>
<h4 id="12-3-3-2-基于人工智能的游戏外挂"><a href="#12-3-3-2-基于人工智能的游戏外挂" class="headerlink" title="12.3.3.2 基于人工智能的游戏外挂"></a>12.3.3.2 基于人工智能的游戏外挂</h4><p>使用深度学习算法，分析画面当中出现的特征画面，然后再抓取游戏引擎向底层OpenGL发出的渲染指令，分析其指令和画面的特征关系，从而抓取到其对应的代码，然后对其进行代码注入。</p>
<h3 id="12-3-4-地址空间Hack的攻与防"><a href="#12-3-4-地址空间Hack的攻与防" class="headerlink" title="12.3.4 地址空间Hack的攻与防"></a>12.3.4 地址空间Hack的攻与防</h3><p>概念一：保证控制&#x2F;数据 流的完整性；对独立的进程以及驱动进行完整性检验，保证部分区域的数据无法被读取，当用户尝试读取这部分数据时直接将其拉人黑名单。<br>概念二：AI监控；使用深度学习对用户数据信息进行建模，当发现某些玩家的数据分布和其他玩家的数据分配产生较大不同时，再来逐帧分析其运行<br>概念三：沙盒渲染；在计算机当中创建一片无法被读取的沙盒，将部分关键的运算放入沙盒当中进行计算，只有在计算结束之后才会返回数据；“计算不再信任操作系统”</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 13：系统调用与Shell</title>
    <url>/2023/08/3dbfbd52ee49.html</url>
    <content><![CDATA[<h2 id="我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell-前言：作为操作系统的用户，“我们”到底是怎么使用操作系统的？"><a href="#我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell-前言：作为操作系统的用户，“我们”到底是怎么使用操作系统的？" class="headerlink" title="我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell&gt; 前言：作为操作系统的用户，“我们”到底是怎么使用操作系统的？"></a>我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。<br>在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell<br><span id="more"></span><br>&gt; 前言：作为操作系统的用户，“我们”到底是怎么使用操作系统的？</h2><h2 id="13-1-Shell简介"><a href="#13-1-Shell简介" class="headerlink" title="13.1 Shell简介"></a>13.1 Shell简介</h2><h3 id="13-1-1-用户角度的Shell"><a href="#13-1-1-用户角度的Shell" class="headerlink" title="13.1.1 用户角度的Shell"></a>13.1.1 用户角度的Shell</h3><p>我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。<br>在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell</p>
<h3 id="13-1-2-早期的Shell"><a href="#13-1-2-早期的Shell" class="headerlink" title="13.1.2 早期的Shell"></a>13.1.2 早期的Shell</h3><p><strong>概念：</strong><br>早期的OS没有复杂结构，系统调用就像是库函数，那个时代的Shell就是命令行终端机。<br>核心：<strong>Shell就是一门把用户指令翻译为系统调用的编程语言</strong></p>
<p>手册：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man sh</span><br></pre></td></tr></table></figure>
<p>这是一个非常简单的手册，包含很多shell的内容，建立对UNIX Shell的基础认识。</p>
<h2 id="13-2-复刻简易UNIX"><a href="#13-2-复刻简易UNIX" class="headerlink" title="13.2 复刻简易UNIX"></a>13.2 复刻简易UNIX</h2><h3 id="13-2-1-简易UNIX代码初设置"><a href="#13-2-1-简易UNIX代码初设置" class="headerlink" title="13.2.1 简易UNIX代码初设置"></a>13.2.1 简易UNIX代码初设置</h3><p>早期的计算机设计由于性能低下，设计不能太消耗性能以及复杂<br>代码：<a href="http://jyywiki.cn/pages/OS/2022/demos/sh-xv6.c">http://jyywiki.cn/pages/OS/2022/demos/sh-xv6.c</a><br>零库函数依赖、可以作为最小可用的Linux的init程序<br>由于其链接任何库函数，因此可以ffreestanding</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -ffreestanding sh-xv6.c -g -O2</span><br><span class="line">ld sh-xv6.o -o sh</span><br></pre></td></tr></table></figure>
<p>第一行是将其编译，然后第二行将其静态链接<br>当使用反汇编模式进行调试时，直接从_Start()，用C写的这个函数处开始执行。此程序可以直接以命令行的形式进行运行。<br>![[Pasted image 20230827140800.png]]</p>
<h3 id="12-2-2-第一步：读取命令"><a href="#12-2-2-第一步：读取命令" class="headerlink" title="12.2.2 第一步：读取命令"></a>12.2.2 第一步：读取命令</h3><p>代码：<br>解析：不停的getcmd()来获得用户的输入，这其中直接使用read的系统调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> nread = <span class="built_in">syscall</span>(SYS_read,<span class="number">0</span>,buf,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>一直读到换行符才停止：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(*(buf++)==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>将命令读取到buf缓冲区里</p>
<h3 id="12-2-3-第二步：可能性-解释执行命令"><a href="#12-2-3-第二步：可能性-解释执行命令" class="headerlink" title="12.2.3 第二步：可能性|解释执行命令"></a>12.2.3 第二步：可能性|解释执行命令</h3><p>代码：<br>![[Pasted image 20230301181806.png]]<br>解析：<br>首先判断是不是一条’cd’命令，并且其当中不能有空格<br>使用系统调用，读取buf+3之后的数据</p>
<h3 id="12-2-4-第二步：可能性-新进程创建"><a href="#12-2-4-第二步：可能性-新进程创建" class="headerlink" title="12.2.4 第二步：可能性|新进程创建"></a>12.2.4 第二步：可能性|新进程创建</h3><p>解析：可能性|如果不是cd命令，此时创建一个新的进程，在新的进程里面把进程解析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">syscall</span>(SYS_fork) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">runcmd</span>(<span class="built_in">parsecmd</span>(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-5-第三步：程序解释器"><a href="#12-2-5-第三步：程序解释器" class="headerlink" title="12.2.5 第三步：程序解释器"></a>12.2.5 第三步：程序解释器</h3><p>其行为就和表达式求值一模一样。<br>求值表达式：<br>eval评估根节点，然后递归的评估子节点，等到两边的值都返回之后得到最后的解。Shell的每一个语句都有其语义。<br>命令解释：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">( echo a ; echo b) | wc -l</span><br></pre></td></tr></table></figure>
<p>![[Pasted image 20230301183132.png]]<br>每执行一个命令，其实就是使用execve()创建一个新的进程，函数的参数就是传入的命令。首先递归的执行左边的部分，然后再递归的执行右边的部分。</p>
<ul>
<li>命令与管道<ul>
<li>管道和命令关系<ul>
<li>管道的左边和右边都可以任意复杂：   </li>
<li>可以是一个很长的式子：<code>(echo a;each b;echo c;echo d)|wc -l</code></li>
<li>把管道左边的输出作为右边的输入，这就是管道的形式语义。</li>
</ul>
</li>
<li>管道解析<ul>
<li>pipe()创建一个管道，管道返回两个描述符：</li>
<li>pipe[0]是读口，pipe[1]是写口</li>
<li>之后会使用fork创建两个新的进程，这两个新的进程完全复制的父进程的状态，因此此时这三个进程完全共享管道，并且共进共出。</li>
<li>之后将p[0]的文件描述符关闭，后背又将p[1]的文件描述符关掉</li>
<li>之后再进行Fork，子进程编号为1的进程指向管道的左边，Fork出来的子进程再进行上述出现的行为</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>管道行为图解：<br>![[Pasted image 20230303165535.png]]</p>
<h4 id="12-2-5-1-将strace中信息保存至文件"><a href="#12-2-5-1-将strace中信息保存至文件" class="headerlink" title="12.2.5.1 将strace中信息保存至文件"></a>12.2.5.1 将strace中信息保存至文件</h4><p>对sh进行使用，然后保存其strace获得的系统调用信息，将其保存至文件当中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace -f -o /tmp/strace.log ./sh</span><br></pre></td></tr></table></figure>
<p>打开strace.log文件之后，即可看到系统调用存储成文件后的内容：<br>首先读取指令，使用fork创建进程：<br>![[Pasted image 20230303170109.png]]<br>然后主进程打印内容，退出子进程：</p>
<h2 id="13-3-UNIX-Shell"><a href="#13-3-UNIX-Shell" class="headerlink" title="13.3 UNIX Shell"></a>13.3 UNIX Shell</h2><p>UNIX Shell就是编程语言，写命令行就是编程<br>常用指令：<br>![[Pasted image 20230303170448.png]]<br><strong>Shell与Job Control</strong><br>即使是1990年代的Shell，也可以实现现在的操作系统的Job控制功能，只不过是使用的命令行，而非图形化界面</p>
<h3 id="13-3-1-Shell作为OS封装的API"><a href="#13-3-1-Shell作为OS封装的API" class="headerlink" title="13.3.1 Shell作为OS封装的API"></a>13.3.1 Shell作为OS封装的API</h3><p>我们需要一个用户能够直接操作的程序，管理操作系统对象，Shell就是操作系统的外壳，帮助人类和OS进行交互</p>
<p><strong>1970年代的Shell</strong><br>1970年代的命令，在“自然语言”和“机器语言”以及计算机的算力之间达到平衡。<br>但其也有缺点，比如命令之间的优先级，以及不同的Shell对编程语言的解读是不一样的</p>
<p><strong>空格带来的麻烦</strong><br>文本数据当中，对于空格的不同理解以及行为导致的程序后果<br>PowerShell：使用对象流管道解决</p>
<h3 id="13-3-2-现代Shell展望"><a href="#13-3-2-现代Shell展望" class="headerlink" title="13.3.2 现代Shell展望"></a>13.3.2 现代Shell展望</h3><p>现代的Shell功能不变，都是人和机器之间的API，但是其形式可以发生变化</p>
<ul>
<li>界面自带StackOverflow？</li>
<li>结合神经网络？</li>
<li>智能补全？</li>
<li>POPL20</li>
</ul>
<h2 id="13-4-终端与任务控制"><a href="#13-4-终端与任务控制" class="headerlink" title="13.4 终端与任务控制"></a>13.4 终端与任务控制</h2><h3 id="13-4-1-终端机制"><a href="#13-4-1-终端机制" class="headerlink" title="13.4.1 终端机制"></a>13.4.1 终端机制</h3><p>问题：为什么有时候使用Ctrl + C可以退出程序，有时候不可以？为什么有些进程可以退出，当管道创建了很多个进程时，使用Ctrl + C 将退出哪个进程？如果时Fork了一个Shell，那使用Ctrl + C 是不是要退出Shell？tmux是怎么实现的？</p>
<p><strong>解决方案：终端</strong><br>Shell连接了人和程序，而人和机器之间交互的设备就是输入和输出设备，这个设备就是终端<br>终端是UNIX当中一类特别的设备，其也作为文件来存在，可以在文件系统中新建多个终端，同时以多个窗口来访问</p>
<p><strong>tmux原理</strong><br>可以使用strace来读取tmux的行为，将其信息保存在文件系统中；<br>不管当前是哪一个窗口，tmux都会把当前的输入捕捉下来，然后相应的将按键的信息转发给不同的终端</p>
<h3 id="13-4-2-信号机制"><a href="#13-4-2-信号机制" class="headerlink" title="13.4.2 信号机制"></a>13.4.2 信号机制</h3><p>信号是终端产生的（比如Ctrl + C是一个信号），给前台进程发一个信号，收到信号之后会有对于的信号处理程序</p>
<p><strong>信号处理程序：</strong><br>![[Pasted image 20230303173129.png]]<br>Ctrl + C 给所有的前台的进程发信号，UNIX世界当中，登陆了Shell当中会先打开Session，然后进入进程组，这些进程组可以放在前台或者后台。前台组无论什么进程，创建进程后都是前台复制过来的，属于前台进程。此时按下Ctrl + C就会对前台的所有进程发送信号</p>
<h4 id="13-4-2-1-Job-Control机制"><a href="#13-4-2-1-Job-Control机制" class="headerlink" title="13.4.2.1 Job Control机制"></a>13.4.2.1 Job Control机制</h4><p>手册：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man setpgid</span><br></pre></td></tr></table></figure>
<p>手册当中告诉，每个session就是一个单独的控制终端，在任何时候，只有一个进程组是前台的进程组，Ctrl + C会给前台的所有进程发送信号。如果有好几个进程组都是前台进程，则此时往前台发送数据可能会产生数据竞争。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 15：Fork的应用</title>
    <url>/2023/08/3d8a9bfbeeea.html</url>
    <content><![CDATA[<p>Fork：操作系统就是一个大的状态机，OS在一般的情况下，使用Syscall执行Fork时会复制一个新的状态。而此状态由于是对于原本被Fork对象的复制，因此会和原本状态完全一致，因此如果原线程上在本地打开了一个文件描述符，那新的线程也会打开它，即指向了同一个OS中的对象</p>
<span id="more"></span>
<blockquote>
<p>前言：从这节课开始，会逐渐进入到如何实现OS相关的内容，即往OS的内核来走</p>
</blockquote>
<h2 id="15-1-fork-行为的补充解释"><a href="#15-1-fork-行为的补充解释" class="headerlink" title="15.1 fork()行为的补充解释"></a>15.1 fork()行为的补充解释</h2><h3 id="15-1-1-操作系统的状态机"><a href="#15-1-1-操作系统的状态机" class="headerlink" title="15.1.1  操作系统的状态机"></a>15.1.1  操作系统的状态机</h3><p><strong>概念复习</strong><br>Fork：操作系统就是一个大的状态机，OS在一般的情况下，使用Syscall执行Fork时会复制一个新的状态。而此状态由于是对于原本被Fork对象的复制，因此会和原本状态完全一致，因此如果原线程上在本地打开了一个文件描述符，那新的线程也会打开它，即指向了同一个OS中的对象（行为类似于指针共享）<br>Execve：进程执行了Execve，状态机就会被重置，但是在重置之后，OS当中的对象还在，因此即使状态被重置，这个指向依然存在，比如其打开的文件描述符依然存在。</p>
<h3 id="15-1-2-文件描述符"><a href="#15-1-2-文件描述符" class="headerlink" title="15.1.2 文件描述符"></a>15.1.2 文件描述符</h3><p><strong>概念</strong><br><strong>文件描述符就是一个指向操作系统内对象的指针</strong>，只能通过OS运行的方式去访问这些对象。但是对于一个文本对象，write一个对象的时候，应该是具有一个文件内的偏移量，进而可以使得两个write写入的内容不是被覆盖，而是都可以被写入。</p>
<p>文件描述符可以通过Open来得到，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open(<span class="string">&quot;a.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>此时会获得一个文件描述符，并且指向这个 a.txt 对象<br>在使用Open打开文件描述符时，可以使用一个O_APPEND的方式写入。不管文件的数量多少，都会以file offset的方式在文件的末尾进行追加。</p>
<p><strong>文件描述符的复制</strong><br>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;a.txt&quot;</span>,O_WROLY | O_CREAT);<span class="comment">//用creat打开，如果不存在就被创造</span></span><br><span class="line">assert(fd &gt; <span class="number">0</span>);</span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line">assert(pid&gt;<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	write(fd,<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	write(fd,<span class="string">&quot;World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：<br>![[Pasted image 20230315124639.png]]</p>
<ul>
<li><p>问题一：文件偏移量的管理<br>以上代码的结果，是Hello被World覆盖掉，还是两者都被输出？即当两个相同状态的进程进行write时，其两者用于相同的文件描述符的前提下，两者是共享偏移量还是其他行为？ </p>
</li>
<li><p>问题二：dup复制文件描述符<br><strong>什么是dup</strong><br>假设原本存在一个fd为3的文件描述符，指向了OS中的一个对象。当使用了dup之后，此时会再出现一个文件描述符，其fd为4，同样也指向了此OS中的一个对象。<br>但是如果带有文件偏移量，那此时究竟应该是共享offset，还是独立offset？</p>
</li>
</ul>
<h2 id="15-2-fork的实现"><a href="#15-2-fork的实现" class="headerlink" title="15.2 fork的实现"></a>15.2 fork的实现</h2><h3 id="15-2-1-fork设计的问题"><a href="#15-2-1-fork设计的问题" class="headerlink" title="15.2.1 fork设计的问题"></a>15.2.1 fork设计的问题</h3><p>创建副本这件事情的代价很大，进程可能有很大的地址空间，如果此时对一个非常大的地址空间fork一份，并且在这之后立马就execve，此时就会产生十分大的性能浪费，此时OS会怎么应对这种状况？</p>
<p><strong>OS中的进程地址空间设计</strong><br>每一个进程会有一个地址空间，并且在地址空间当中会进行分页（MMU），而进程其本身拥有的只是一个映射表。映射表提供了相关的信息，表示不同的内容会映射到分页之后的哪个页面，所以概念上进程拥有这些页面，其实实际上依然是由OS控制着所有这些内容。</p>
<h3 id="15-2-2-共享只读设计"><a href="#15-2-2-共享只读设计" class="headerlink" title="15.2.2 共享只读设计"></a>15.2.2 共享只读设计</h3><p>当一个进程拥有两个页面时，内容如下：<br>![[Lecture 15：Fork的应用 2023-03-15 17.06.04.excalidraw]]<br>当指向了一个fork之后，其状态如下;<br>![[Lecture 15：Fork的应用 2023-03-15 17.07.24.excalidraw]]<br>此时这两个进程都同时指向了一个可写的页面，因此Old进程可以写，New进程也可以写。但是此时OS会偷偷的抹掉这个可写的权限，进而可能发生缺页中断（段错误）。但如果OS发现，这个缺页中断只是被偷偷抹掉的，此时OS会将此页引用计数减1，然后将其拷贝一份到另外的可写权限的空间，从而把读写的权限重新还给NEW进程。<br>![[Lecture 15：Fork的应用 2023-03-15 17.12.48.excalidraw]]<br><strong>优点：</strong><br>这种设计Copy on Write的设计，当遇到非常大的地址空间中需要映射的内容时，有时可以不需要为其创建新的内容，只有在使用时才产生这种Copy On Write。<br><strong>例子：libc</strong><br>整个OS里面，只有一份libc的副本，OS当中有很多的进程，此时这些不同的进程都是指向同一个libc。</p>
<p><strong>代码证明Copy On Write</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPROC 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MB 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE (MB * (1 &lt;&lt; 20))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xstr(s) str(s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> str(s) #s</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *data = <span class="built_in">malloc</span>(SIZE); <span class="comment">// 128MB shared memory</span></span><br><span class="line">  <span class="built_in">memset</span>(data, <span class="string">&#x27;_&#x27;</span>, SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NPROC - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// NPROC processes go here</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;.fill 1048576 * &quot;</span> xstr(MB) <span class="string">&quot;, 1, 0x90&quot;</span>)</span>; <span class="comment">// 128MB shared code</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, O_RDONLY); assert(fd &gt; <span class="number">0</span>);</span><br><span class="line">  read(fd, &amp;idx, <span class="keyword">sizeof</span>(idx));</span><br><span class="line">  close(fd);</span><br><span class="line">  idx %= <span class="number">1048576</span> * MB;</span><br><span class="line"></span><br><span class="line">  data[idx] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pid = %d, write data[%u]\n&quot;</span>, getpid(), idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// not terminate</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行了这个代码之后，在OS当中有1000个进程在进行，并且上述代码在SO中，每个都要求分配了128MB的内存。但是OS并没有Crash掉，实际只是用了1GB左右的内存。这就是Copy On Write的实现。</p>
<p><strong>关于进程内存占有量</strong><br>由此推导出一个结论：证明一个进程用的多少的内存就是一个伪命题。如果简单的将一个进程映射的内存之和相加作为其内存大小，mmap可以映射一大片的内存（比如20T内存），但是这些内存是按需使用的，其只是做了一个映射，然后使用时只会用多少分配多少，并且还有很多内存是共享的（Libc）。</p>
<h2 id="15-3-状态机的复制"><a href="#15-3-状态机的复制" class="headerlink" title="15.3 状态机的复制"></a>15.3 状态机的复制</h2><h3 id="15-3-1-状态机视角"><a href="#15-3-1-状态机视角" class="headerlink" title="15.3.1 状态机视角"></a>15.3.1 状态机视角</h3><p><strong>概念：平行宇宙与fork</strong><br>物理世界上不同的粒子状态，可以定义出不同时间下的状态。如果此时要进行时间穿越，此时行为就是将未来的部分状态带到过去，并且从此状态开始进行分叉，而这个分叉就是fork()。<br>OS运行开发者使用fork()实现平行宇宙。</p>
<h3 id="15-3-2-fork与并行化"><a href="#15-3-2-fork与并行化" class="headerlink" title="15.3.2 fork与并行化"></a>15.3.2 fork与并行化</h3><p><strong>例子1：码交换搜索问题</strong><br>和不同的部分进行交换，就会进入不同的状态。可以使用状态机的视角，将所有的状态进行探索。<br>![[Lecture 15：Fork的应用 2023-03-16 16.57.00.excalidraw]]</p>
<p><strong>例子2：基于fork的dfs</strong><br>原本的dfs会使用深度遍历进行探索，然后使用回溯法回到原本的状态，回溯的过程十分耗时。而如果基于fork，使用状态机的视角来进行迁移，则可以只会跳回到初始状态（通过使用exit()来实现）。<br>其启示是：可以使用fork实现dfs；使用fork来进入不同的状态，并且联合OS来帮助进行管理，此时进入新的状态后原本的平行宇宙也可以被消除掉，每探索完一个平行宇宙都将其删除掉。<br>并且，还可以创造多个平行宇宙，并行的得到所有状态，然后程序结束。</p>
<h3 id="15-3-3-fork与跳过初始化"><a href="#15-3-3-fork与跳过初始化" class="headerlink" title="15.3.3 fork与跳过初始化"></a>15.3.3 fork与跳过初始化</h3><p><strong>问题</strong><br>假设你的NEMU需要启动很多份elf头文件，而如果NEMU进行初始化要花很多的时间（比如花费大量时间来初始化一片128MB的内存），此时如果为每个elf来进行启动就会产生大量消耗，此时可以按照以下行为分析：<br>![[Lecture 15：Fork的应用 2023-03-16 17.29.53.excalidraw]]<br><strong>处理方法</strong><br>此时可以只执行一次nemu_init()的内容，之后只需要每进来一个需要启动的内容，就fork一份，然后找到没有处理的文件，将其进行处理，就可以完成操作。并且因为只进行一次init，因此可以加速程序执行第一个文件的速度。</p>
<p><strong>跳过初始化的实际应用</strong><br>应用：安卓应用的秒启动</p>
<ul>
<li>简介：每一个安卓的程序都会通过以上的跳过初始化的方式进行启动。</li>
<li>原理：安卓应用是一个Java程序，而Java是运行在JVM虚拟机上面，对于安卓而言是一个Android Runtime（自己实现的虚拟机）。而安卓和Java都会有一个十分大的标准库，如果每一个程序是采取冷启动，即从0开始执行整个Java程序，不可能几秒内完成加载，此时就是使用了跳过初始化的思想，所有的Java程序只进行初始化一次。</li>
<li>Zygote Process：会有一个所有Android程序的父进程，名称为Zygote Process。其会完成所有必要的安卓程序的必要的类的加载，此时如果开始了一个新的程序，只要在init之后的状态基础之上fork一份即可完成创建。</li>
<li>一次加载，全员使用<br>应用：Chrome浏览器</li>
<li>简介：Chrome可以成功的原因之一，就是其速度非常的快。</li>
<li>原理：Chrome当中，每一个网页就是一个进程，使用跳过初始化的思想来进行网页的快速加载</li>
</ul>
<p><strong>核心：只要是从一个状态出发，需要很多个副本的，都可以使用fork。</strong></p>
<h3 id="15-3-4-fork与备份"><a href="#15-3-4-fork与备份" class="headerlink" title="15.3.4 fork与备份"></a>15.3.4 fork与备份</h3><p><strong>简介：</strong><br>要是我们可以对有Bug的程序总是能在任何状态“试一试”，然后试错了还能回到过去，就好了。<br><strong>概念：</strong><br>当过去某个节点发生了一个Bug，我们能否回到过去，在产生一次这个Bug?特别是出现并发Bug，此类Bug或许十分难以重现，拥有此存档机制就可以去复现过去状态下的Bug。<br>![[Lecture 15：Fork的应用 2023-03-17 17.46.14.excalidraw]]<br>在任何状态下，可以使用fork()开启另一条平行宇宙，然后在此基础上进行存档。然后如果顺着正常的路径进行执行，但是之后在这主分支之上发生了Crash，此时就可以拿回之前的存档，从之前的存档开始。<br>![[Lecture 15：Fork的应用 2023-03-17 21.24.34.excalidraw]]<br>然后拿回了之前的存档后，从此存档开始执行，并且需要更改一些环境。很多Bug都是由于环境导致的（比如许多的并发Bug）。<br>![[Lecture 15：Fork的应用 2023-03-17 21.27.15.excalidraw]]<br>这就是可以进行容错的机制。如果有轻量级的快照，就可以使用平行宇宙来复查一些Bug。甚至如果是想要还原并发这种Bug，甚至不需要复杂的Fork的快照，只需要有一个Setjmp寄存器的快照。</p>
<h2 id="15-4-对于Fork的讨论"><a href="#15-4-对于Fork的讨论" class="headerlink" title="15.4 对于Fork的讨论"></a>15.4 对于Fork的讨论</h2><h3 id="15-4-1-A-Fork-in-the-road"><a href="#15-4-1-A-Fork-in-the-road" class="headerlink" title="15.4.1 A Fork() in the road"></a>15.4.1 A Fork() in the road</h3><p><strong>简介：</strong><br>对于Unix Fork的批评。<br><strong>概述：</strong><br>fork使用的最舒服的时候，就是在一个简单的管道模型当中。但是随着OS发展，进程不止是有地址空间和文件描述符，但是之后进程会有信号（fork之后，发信号是两个都发，还是只发一个？），线程，进程间通信对象，ptrace等等。<br>fork的开发者对于这些问题进行了修复，但是结果就是导致现在的fork十分的复杂。比如出现线程之后。</p>
<p><strong>这些都是由进程拥有了一些更加复杂的对象所引发出的问题。</strong></p>
<h3 id="15-4-2-线程对于Fork的影响"><a href="#15-4-2-线程对于Fork的影响" class="headerlink" title="15.4.2 线程对于Fork的影响"></a>15.4.2 线程对于Fork的影响</h3><p><strong>线程概述</strong><br>在一个进程当中，会有一片地址空间，两个不同的线程共享这些地址空间，所有的页面都是共享的（因为页面是由OS持有的）。<br>![[Lecture 15：Fork的应用 2023-03-17 21.43.41.excalidraw]]<br><strong>问题</strong><br>此时如果fork了一份这个进程，这当中的这些线程会怎么样？</p>
<p><strong>分析</strong><br>首先，肯定是进程当中的某一个线程执行了fork，在执行了fork之后，是对应进程复制，另一个进程消失，还是两者都被复制？<br>正确答案是 只复制执行了fork的进程。<br>![[Lecture 15：Fork的应用 2023-03-17 21.47.35.excalidraw]]</p>
<h3 id="15-4-3-更安全的创建一个进程"><a href="#15-4-3-更安全的创建一个进程" class="headerlink" title="15.4.3 更安全的创建一个进程"></a>15.4.3 更安全的创建一个进程</h3><p><strong>创建进程：POSIX Spawn</strong><br>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">posix_spawn</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">pid_t</span> *pid,</span></span><br><span class="line"><span class="params"><span class="type">char</span> *path,</span></span><br><span class="line"><span class="params"><span class="type">posix_spawnattr_t</span> *attrp,</span></span><br><span class="line"><span class="params"><span class="type">char</span>* argv[],</span></span><br><span class="line"><span class="params"><span class="type">char</span>* envp[]</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>其是一个在fork发明出来之后的API，比fork更加的简单。</p>
<p>Fork的七宗罪：<br>![[Pasted image 20230317215942.png]]</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Fork</tag>
      </tags>
  </entry>
  <entry>
    <title>【商业系列】商业计划书大纲与内容</title>
    <url>/2023/08/efa8d1f054ea.html</url>
    <content><![CDATA[<p><strong>商业计划书大纲</strong></p>
<ul>
<li>1、 团队简介</li>
<li>2、 项目内容</li>
<li>3、 团队组成</li>
<li>4、 市场规模与分析</li>
<li>5、 商业模式</li>
<li>6、 战略规划<span id="more"></span></li>
</ul>
<h1 id="1-内容大纲"><a href="#1-内容大纲" class="headerlink" title="1.内容大纲"></a>1.内容大纲</h1><ul>
<li>1、 团队简介</li>
<li>2、 项目内容<ul>
<li>1、项目介绍</li>
<li>2、核心优势</li>
</ul>
</li>
<li>3、 团队组成</li>
<li>4、 市场规模与分析<ul>
<li>1、 市场分析</li>
<li>2、 竞品分析</li>
</ul>
</li>
<li>5、 商业模式<ul>
<li>1、 商业模式介绍</li>
<li>2、 相关数据</li>
</ul>
</li>
<li>6、 战略规划<ul>
<li>1、 战略目标</li>
<li>2、 实现路径</li>
</ul>
</li>
</ul>
<h1 id="2-各部分编写思路"><a href="#2-各部分编写思路" class="headerlink" title="2.各部分编写思路"></a>2.各部分编写思路</h1><h2 id="2-1-团队简介"><a href="#2-1-团队简介" class="headerlink" title="2.1 团队简介"></a>2.1 团队简介</h2><p><strong>内容构成</strong>：一句话介绍 + 50~100字团队简介</p>
<p><strong>一句话介绍</strong><br>内容尽可能简短、清晰，直接了当的了解当前团队的：</p>
<ol>
<li>核心业务内容</li>
<li>核心优势</li>
</ol>
<p><strong>团队简介</strong><br>简要介绍团队业务以及数据规模等内容；</p>
<h2 id="2-2-项目内容"><a href="#2-2-项目内容" class="headerlink" title="2.2 项目内容"></a>2.2 项目内容</h2><h3 id="2-2-1-项目介绍"><a href="#2-2-1-项目介绍" class="headerlink" title="2.2.1 项目介绍"></a>2.2.1 项目介绍</h3><p><strong>编写内容核心</strong><br>把此业务最吸引人、最有发展潜力的部分展现出来；</p>
<ul>
<li>分析方法<ul>
<li>简介：先确定此项目属于哪一种类型，然后再根据此类型的核心点，编写文字内容</li>
<li><ol>
<li>增长型项目（还没开始或刚开始）</li>
</ol>
<ul>
<li>侧重增长，大量数据放在此项目板块的<strong>发展潜力以及我们的优势</strong>上面</li>
</ul>
</li>
<li><ol start="2">
<li>运营型项目（已经开始）</li>
</ol>
<ul>
<li>侧重盈利，大量文字放在介绍当前流量的<strong>转化率以及盈利能力</strong>上</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>图片展示</strong><br>技术型项目给出吸引人的文字图片内容，吸引浏览者观看；</p>
<h3 id="2-2-2-核心优势"><a href="#2-2-2-核心优势" class="headerlink" title="2.2.2 核心优势"></a>2.2.2 核心优势</h3><p><strong>分析方法</strong><br>分析目前团队的开发能力当中，和竞品相比最具有优势的部分；</p>
<ul>
<li>流量矩阵：<ul>
<li>自媒体流量（自带宣传流量）</li>
<li>开发团队（丰富开发经验）</li>
<li>项目案例（Unity3D）</li>
</ul>
</li>
</ul>
<h2 id="2-3-团队组成"><a href="#2-3-团队组成" class="headerlink" title="2.3 团队组成"></a>2.3 团队组成</h2><p><strong>分析方法</strong><br>根据核心优势部分分析的结果，部分的去过滤团队介绍部分所需要呈现的内容；<br>只呈现优势的一面，劣势或不加分的一面要慎重描写</p>
<h2 id="2-4-市场规模与分析"><a href="#2-4-市场规模与分析" class="headerlink" title="2.4 市场规模与分析"></a>2.4 市场规模与分析</h2><h3 id="2-4-1-市场分析"><a href="#2-4-1-市场分析" class="headerlink" title="2.4.1 市场分析"></a>2.4.1 市场分析</h3><p><strong>数据采集</strong><br>要有明确、清晰的数据来源<br>在此数据来源之上，筛选出对项目有利的信息</p>
<ul>
<li>真实的数据，但是是部分的真实</li>
</ul>
<h3 id="2-4-2-竞品分析"><a href="#2-4-2-竞品分析" class="headerlink" title="2.4.2 竞品分析"></a>2.4.2 竞品分析</h3><p><strong>竞品确定</strong><br>竞品不一定得是完全相同的行业，重点是商业的逻辑；<br>确定一个牛逼的竞品，即展示当前项目天花板很高，然后再分析当前项目所处市场以及再哪些地方超越了竞品。</p>
<h2 id="2-5-商业模式"><a href="#2-5-商业模式" class="headerlink" title="2.5 商业模式"></a>2.5 商业模式</h2><p><strong>什么是商业模式</strong></p>
<ol>
<li>项目如何盈利？</li>
<li>项目的流量模式？</li>
<li>获客转化的路径？</li>
<li>是否具有可持续性？</li>
<li>增长的空间以及可能？</li>
</ol>
<p><strong>内容编写</strong><br>基于业务本身的内容，对模式进行介绍；</p>
<h2 id="2-6-战略规划"><a href="#2-6-战略规划" class="headerlink" title="2.6 战略规划"></a>2.6 战略规划</h2><p><strong>内容</strong></p>
<ol>
<li>确定战略目标，展现当前项目的发展前景</li>
<li>确定项目发展的实现路径，并且确定不同情况下的风险预案</li>
</ol>
]]></content>
      <categories>
        <category>商业</category>
      </categories>
      <tags>
        <tag>商业</tag>
        <tag>创业</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 14：C标准库的实现</title>
    <url>/2023/08/68a724658d83.html</url>
    <content><![CDATA[<p>操作系统内核对外面提供的API就是Syscall，而当中和用户交互的就是Shell。而在Shell的外面，OS提供了一个框架性程序，帮助开发者实现应用程序（因为没有人愿意在没有库函数的情况下，直接使用汇编、系统调用来制作应用程序）</p>
<blockquote>
<p>· 在系统调用之上构建可以普遍使用的标准库：libc</p>
</blockquote>
<span id="more"></span>
<h2 id="14-1-系统调用的封装"><a href="#14-1-系统调用的封装" class="headerlink" title="14.1 系统调用的封装"></a>14.1 系统调用的封装</h2><h3 id="14-1-1-熟悉又陌生的libc"><a href="#14-1-1-熟悉又陌生的libc" class="headerlink" title="14.1.1 熟悉又陌生的libc"></a>14.1.1 熟悉又陌生的libc</h3><p><strong>为什么需要libc</strong><br>虽然不借助任何的库函数也可以写程序，但是在自己写的时候还是要进行封装（一些固定的功能）。<br>裸奔式的编程是不可行的，即使是实现最简单的程序也有很多可以重用的部分。</p>
<h3 id="14-1-2-libc提供的类型系统"><a href="#14-1-2-libc提供的类型系统" class="headerlink" title="14.1.2 libc提供的类型系统"></a>14.1.2 libc提供的类型系统</h3><p><strong>第一种：类型系统</strong><br>问题：size of int 是多少大小？C语言编译器可以将其实现为八字节，也可以是四字节<br>解释：这种不同字节大小的类型，在进行跨平台交叉编译时，其移植性具有很大的障碍，因为其在不同平台上大小可能不同。<br>方法：libc标准库专门提供对应的标准基本类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在使用的时候，直接使用标注上字节大小的int或bool:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> a;</span><br><span class="line">	<span class="type">uint64_t</span> x;</span><br><span class="line">	<span class="type">intptr_t</span> ptr;<span class="comment">//可以保证，把这个指针cast成一个int之后不会丢失任何的数据</span></span><br><span class="line">	<span class="comment">//intptr_t ptr = (intptr_t)main;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是使用int替代intptr_t时，可能会丢失信息。</p>
<p>常见、在freestanding下也可以使用的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stddef.h -&gt; <span class="type">size_t</span></span><br><span class="line">stdint.h -&gt; <span class="type">int32_t</span>,<span class="type">uint64_t</span></span><br><span class="line">stdbool.h -&gt; <span class="type">bool</span>,<span class="literal">true</span>,<span class="literal">false</span></span><br><span class="line"><span class="type">float</span>.h</span><br><span class="line">limits.h</span><br><span class="line">stdarg.h</span><br></pre></td></tr></table></figure>
<p>系统syscall使用到的stdarg.h；当系统调用的函数在传递参数时，其当中参数的设计：<br>![[Pasted image 20230307124449.png]]<br>仿照系统的函数写的代码：<br>![[Pasted image 20230307124836.png]]</p>
<p>另一个问题：long type<br>long type32位机上是四字节，在其他机器上可能是八字节；</p>
<h3 id="14-1-3-libc对系统调用的封装"><a href="#14-1-3-libc对系统调用的封装" class="headerlink" title="14.1.3 libc对系统调用的封装"></a>14.1.3 libc对系统调用的封装</h3><p><strong>对execve()系统调用的封装</strong><br>execve()并不好用，平时使用的时候使用麻烦。<br>比如execve()的第一个路径必须为是一个合法的路径，可以是相对路径，但必须是合法的路径：<code>../../../../../../.././bin/echo</code><br>execve如果不给合法的路径，其会直接拒绝用户，但用户想要实现的是找到path当中的echo，而不是找完全准确的那个path。<br>平时写代码可能会用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execlp(<span class="string">&quot;echo&quot;</span>,<span class="string">&quot;echo&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;OS course&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//打印结果：hello OS course</span></span><br></pre></td></tr></table></figure>
<p>用静态的方式编译，然后查看其系统调用：<br>![[Pasted image 20230307131337.png]]<br>execve会尝试每一个path当中的路径，然后直到成功找到那个程序，然后使用execve进程reset。这当中也介绍了更高情商的API：execlp<br><em>补充：在看手册的时候，手册当中经常会有很大的引用，比如在execve的手册当中，其当中可以看到SEE ALSO，顺着这些引用往下看就可以算是实现了一次文献调研</em><br>libc就是对在系统调用的基础上，面向人类易用性进行的封装。</p>
<h3 id="14-1-4-libc对string、数组的封装"><a href="#14-1-4-libc对string、数组的封装" class="headerlink" title="14.1.4 libc对string、数组的封装"></a>14.1.4 libc对string、数组的封装</h3><p><strong>main函数中的参数</strong><br>main函数会有三个参数。当中有一个数组：<code>char *argv[]*</code></p>
<p>memset实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span>* s <span class="type">int</span> c,<span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;n ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		((<span class="type">char</span>*)s)[i] = c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>memset对于数据竞争的态度：直接不管你，谁最后把数据写进去，内存单元就是哪个进程的，并且标准库只对“标准库内部数据”的线程安全性负责。<br>使用clang对其进行编译后的结果：</p>
<p><strong>补充：libc实现的复杂性</strong><br>对于libc的实现者而言，因为Libc会被很多人调用，因此其正确性必须得得到验证。并且作为Libc，其必须得跑得快，而且还得兼顾各种的机器，在不同机器上面跑的快不快……<br>在多个线程使用其时，会不会产生数据竞争，是不是还得考虑安全……新的机制来了，当前代码还得支持。</p>
<p><em>补：现在的C语言 &#x3D; 大号的汇编语言 + 大家还能接受的API的标准</em></p>
<h3 id="14-1-5-其他的例子"><a href="#14-1-5-其他的例子" class="headerlink" title="14.1.5 其他的例子"></a>14.1.5 其他的例子</h3><p>数学库的实现：过于复杂，比如浮点数的性质，比如在接近0的时候如何保证精度。而OS要对纯粹的计算进行封装。</p>
<hr>
<h2 id="14-2-文件描述符与进程封装"><a href="#14-2-文件描述符与进程封装" class="headerlink" title="14.2 文件描述符与进程封装"></a>14.2 文件描述符与进程封装</h2><p>操作系统中存在大量的对象，比如终端、对于Shell来说连接的终端。libc的职责之一，就是对于这些常见对象的封装</p>
<h3 id="14-2-1-什么是文件描述符"><a href="#14-2-1-什么是文件描述符" class="headerlink" title="14.2.1 什么是文件描述符"></a>14.2.1 什么是文件描述符</h3><p>文件描述符就是一个打开的文件，而Linux当中一切都是文件，因此可以使用文件描述符来打开一切对象。因此Libc必须要对文件描述符进行一定的封装。 </p>
<p>例：往文件系统里面写文件的一段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* fp = fopen(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;Hello,OS world\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>使用gcc编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -g a.c &amp;&amp; ./a.out</span><br></pre></td></tr></table></figure>
<p>其系统调用的过程：<br>![[Pasted image 20230307171635.png]]<br>这是OS视角下，当前程序的行为。但也可以从用户的视角来看一下，这个代码发生的行为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p *fp</span><br></pre></td></tr></table></figure>
<p>对文件描述符的指针解引用，得出的结果（部分）：<br>![[Pasted image 20230307171858.png]]<br>由此可以看到：FILE* 背后就是封装了一个文件描述符。同时一个FILE只能返回一个文件描述符，要么是读口要么是写口。<br>装填了值之后，fp解引用会变成这样：<br>![[Pasted image 20230307172411.png]]<br>可以清晰的看到libc为其设置的不同区域的大小以及对应的内容。</p>
<p>popen和pclose的设计具有缺陷（或者说相比于现代的语言，不易用）</p>
<h3 id="14-2-2-其他进程-操作系统功能"><a href="#14-2-2-其他进程-操作系统功能" class="headerlink" title="14.2.2 其他进程&#x2F;操作系统功能"></a>14.2.2 其他进程&#x2F;操作系统功能</h3><p><strong>错误信息处理</strong><br>所有的API都有可能失败，此时Shell可能会发出一个error message，比如“No Such file or directory”。并且不止是这一个错误发出了这个信息，还有很多的其他err message都是这个，是不是背后有一个共通的错误反应的内容？<br>因为这背后都使用了一样的libc当中的错误处理代码，一代一代的传承出来（除非有一个打破者，比如rust出现）</p>
<p><strong>环境变量</strong><br>可以自己实现env.c这样的命令，借助Linux提供的env.c机制，可以实现非常简单的env环境变量实现。<br>在C语言当中可以使用环境变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br></pre></td></tr></table></figure>
<p>而这些环境变量在执行之前就已经有值，这些值是谁设置的？如何查看这些内容？<br>可以使用gdb调试，从starti开始执行。<br>先编译一下env.c代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc env.c -g -static</span><br></pre></td></tr></table></figure>
<p>受用gdb使用时，最开始starti时没有值，再往下执行后，可以看到时__libc_start_main()给其赋值<br>gdb断点查看：<br>![[Pasted image 20230308165300.png]]</p>
<h2 id="14-3-地址空间的封装"><a href="#14-3-地址空间的封装" class="headerlink" title="14.3 地址空间的封装"></a>14.3 地址空间的封装</h2><h3 id="14-3-1-内存分配行为"><a href="#14-3-1-内存分配行为" class="headerlink" title="14.3.1 内存分配行为"></a>14.3.1 内存分配行为</h3><p><strong>简介</strong><br>libc的一个非常重要的功能之一就是内存管理，而这块主要就是malloc和free，任何的应用程序都需要大量的分配内存。</p>
<p><strong>行为分析</strong><br>在一个大区间中维护互不相交的区间的集合，大区间由mmap来实现，mmap基于当前进程的地址空间，从当中挖去一大块内存。<br>在一个左闭右开的区间，维护一个数据结构，这些被分配的内存互相不相交，在这片内存当中进行malloc和free，可以往一片空区分配内存，或者将已经分配的内存释放掉。因此malloc和free就是区间管理。</p>
<p><strong>内存分配的效率问题</strong><br>当想要在设计内存管理的时候，使用类似红黑树、B+树类似的算法思路想要去实现算法复杂度的log(n)时，就已经陷入误区。<br>在OS上，在多处理器的方案下，光是想要实现安全性就够困难了。</p>
<p><strong>任何脱离workflow的性能优化都是耍流氓</strong>，在考虑性能之前，需要先考虑需要什么样的性能。</p>
<h3 id="14-3-2-内存管理workflow分析"><a href="#14-3-2-内存管理workflow分析" class="headerlink" title="14.3.2 内存管理workflow分析"></a>14.3.2 内存管理workflow分析</h3><p><strong>指导思想</strong><br>内存被分配出来就是为了被使用的，O(n)大小的对象分配至少需要有相对应数量级的读写操作，不然就是性能Bug。<br>必须是在需要对应的对象，需要那么多的内存时才分配那部分内存。</p>
<p><strong>问题</strong></p>
<ul>
<li>越小的对象创建&#x2F;分配越频繁<ul>
<li>字符串、临时对象等</li>
<li>生存周期可长可短</li>
</ul>
</li>
<li>较为频繁的分配中等大小的对象<ul>
<li>较大的数组、复杂的对象</li>
<li>更长的生命周期</li>
</ul>
</li>
<li>低频率的大对象<ul>
<li>巨大的容器、分配器</li>
<li>很长的生存周期</li>
</ul>
</li>
<li>挑战：并行化的分配问题<ul>
<li>所有的分配都会在处理器上发生，而处理器是并发、相互高度用总线连接的</li>
</ul>
</li>
</ul>
<h3 id="14-3-3-内存问题的两种方案"><a href="#14-3-3-内存问题的两种方案" class="headerlink" title="14.3.3 内存问题的两种方案"></a>14.3.3 内存问题的两种方案</h3><p>设置两套系统：</p>
<ul>
<li>fast path<ul>
<li>性能好，并行度好，覆盖大部分情况</li>
<li>可以很快的解决问题，但是有小概率失败</li>
</ul>
</li>
<li>slow path<ul>
<li>性能没那么好，但是要求把事情做好</li>
</ul>
</li>
<li>人的fast系统和slow系统<ul>
<li>直觉式的反应系统和推力式的反应系统</li>
</ul>
</li>
</ul>
<p><strong>Malloc：Fast Path设计</strong><br>简介：使得所有的CPU都可以并行的申请内存<br>实现：想实现更快的分配，因此不能进行上锁，如果此时有两个线程，此时可以以page的方式，在page的基础上维护一个空闲链表，当一个page分配完了，再从全局的page当中分配一个page，往其上一把锁，然后把这个page返回给需要的地方。<br>当快速的在page上分配内存时是fast path，但是当内存不够，分配更多的page时，此时是slow path。通过这种设计实现slow path的访问变少，性能变好。<br>如果不想在page上使用链表维护时，还可以设置最小的分配单元位32b、64b、…4kb，此时有一个64kb的page，在此page上有个Header，除了这个Header之外，在这个Page上就是一堆16b的对象（或者其他格式），可以为每个分配的大小单独分配结构。</p>
<p><strong>小内存的分段设计</strong><br>基于一个个Segregation上进行分配，每个slab里面的对象大小都一致，每个线程都在本地拥有立即分配完成的权限。</p>
<p><strong>大内存的大锁设计</strong><br>需要分配大内存时，此时就是使用线段树，将一串区域切分成树，然后变成了一个算法问题。使用一把大锁保证其安全。</p>
<h2 id="14-4-总结"><a href="#14-4-总结" class="headerlink" title="14.4 总结"></a>14.4 总结</h2><h3 id="14-4-1-相关手册"><a href="#14-4-1-相关手册" class="headerlink" title="14.4.1 相关手册"></a>14.4.1 相关手册</h3><p><strong>Libc手册</strong><br>The GNU C Library</p>
<p>Libc的实现：Newlib</p>
<h3 id="14-4-2-从C走向世界"><a href="#14-4-2-从C走向世界" class="headerlink" title="14.4.2 从C走向世界"></a>14.4.2 从C走向世界</h3><p>基于C，可以实现C++的编译器<br>基于C++，可以实现C++标准库<br>基于C++，可以是西安OpenJDK<br>基于C++，可以实现JS，进而实现整个浏览器当中的世界</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Game Engine：引擎事件系统</title>
    <url>/2023/08/e672ea9950c8.html</url>
    <content><![CDATA[<p>引擎事件系统框架编写</p>
<span id="more"></span>

<h2 id="1-事件类型基础"><a href="#1-事件类型基础" class="headerlink" title="1.事件类型基础"></a>1.事件类型基础</h2><h3 id="1-1-事件类型枚举"><a href="#1-1-事件类型枚举" class="headerlink" title="1.1 事件类型枚举"></a>1.1 事件类型枚举</h3><p>描述事件系统的基础事件类型，用枚举表示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">EventType</span></span><br><span class="line">&#123;</span><br><span class="line">	None = <span class="number">0</span>,</span><br><span class="line">	WindowClose, WindowResize, WindowFocus, WindowLostFocus, WindowMoved,</span><br><span class="line">	AppTick, AppUpdate, AppRender,</span><br><span class="line">	KeyPressed, KeyReleased,</span><br><span class="line">	MouseButtonPressed, MouseButtonReleased, MouseMoved, MouseScrolled</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-事件分类"><a href="#1-2-事件分类" class="headerlink" title="1.2 事件分类"></a>1.2 事件分类</h3><p>定义了事件分类，并且可以向0进行过滤、偏移；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EventCategory</span></span><br><span class="line">&#123;</span><br><span class="line">	None = <span class="number">0</span>,</span><br><span class="line">	EventCategoryApplication = <span class="built_in">BIT</span>(<span class="number">0</span>),</span><br><span class="line">	EventCategoryInput = <span class="built_in">BIT</span>(<span class="number">1</span>),</span><br><span class="line">	EventCategoryKeyboard = <span class="built_in">BIT</span>(<span class="number">2</span>),</span><br><span class="line">	EventCategoryMouse = <span class="built_in">BIT</span>(<span class="number">3</span>),</span><br><span class="line">	EventCategoryMouseButton = <span class="built_in">BIT</span>(<span class="number">4</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BIT的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT(x) (1 &lt;&lt; x)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-Event基类设计"><a href="#2-Event基类设计" class="headerlink" title="2.Event基类设计"></a>2.Event基类设计</h2><ul>
<li>内容：<ul>
<li>m_Handled：用于表示此内容是否已经被处理过；</li>
<li>IsInCategory：现在处理的事件，是否是属于类型的部分；使用此方法快速的进行过滤； </li>
<li>GetName：仅用在Debug模式；</li>
<li>ToString：默认输出名字，也可以继承后修改以及扩展此行为；<ul>
<li>实现细节：stringstream的性能很差，但目前Debug模式可以先不考虑；</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> Event</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">EventDispatcher</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> EventType <span class="title">GetEventType</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetCategoryFlags</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetName</span>(); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsInCategory</span><span class="params">(EventCategory category)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GetCategoryFlags</span>() &amp; category;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">bool</span> m_Handled = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-抽象函数的实现宏"><a href="#2-1-抽象函数的实现宏" class="headerlink" title="2.1 抽象函数的实现宏"></a>2.1 抽象函数的实现宏</h3><p>因为在Event当中有抽象函数需要实现，每一个子类都需要手动进行实现的话会导致浪费。可以将其写成一个宏函数，在子类当中只需传入类型，既可以自动实现其子类的抽象函数的实现；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_CLASS_TYPE(type) static EventType GetStaticType() &#123; return EventType::##type; &#125;\</span></span><br><span class="line"><span class="meta">								virtual EventType GetEventType() const override &#123; return GetStaticType(); &#125;\</span></span><br><span class="line"><span class="meta">								virtual const char* GetName() const override &#123; return #type; &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-KeyEvent类设计"><a href="#3-KeyEvent类设计" class="headerlink" title="3.KeyEvent类设计"></a>3.KeyEvent类设计</h2><p><strong>KeyEvent概念</strong><br>需要处理案件的事件。并且按键的事件至少具有以下三种状态：</p>
<ol>
<li>第一次按下</li>
<li>按下中</li>
<li>第一次抬起<br>KeyEvent需要能够处理并表达这三种状态。</li>
</ol>
<p><strong>继承</strong><br>KeyEvent是其他更多按键事件的父类，是Event类的子类；</p>
<p><strong>KeyEvent代码</strong><br>此代码的内容类似于是抽象类，只是用于提供继承；不能实例化一个Key Event；</p>
<ul>
<li>内容：<ul>
<li>构造函数：构造函数被设置为protected，表示此类作用为提供继承；</li>
<li>Get Key Code：返回KeyCode数值；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> KeyEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetKeyCode</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_KeyCode; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryKeyboard | EventCategoryInput)</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">KeyEvent</span>(<span class="type">int</span> keycode)</span><br><span class="line">		: <span class="built_in">m_KeyCode</span>(keycode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_KeyCode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>EVENT_CLASS_CATEGORY内容</strong><br>因为KeyBoard键盘输入同时也是一般Input的一种，因此其进行分类时同属于这两种类型；</p>
<h3 id="3-1-KeyPressedEvent类设计"><a href="#3-1-KeyPressedEvent类设计" class="headerlink" title="3.1 KeyPressedEvent类设计"></a>3.1 KeyPressedEvent类设计</h3><p>此类是一个可以被实际实例化的类；</p>
<p><strong>构造函数</strong><br>此类的构造函数传入repeatCount，表示此按键的重复次数。当此数值不为0时，此内容表示当前Event在被重复按下；</p>
<p><strong>ToString重写</strong><br>输出”KeyPressedEvent: “ 加上 KeyCode 的数值；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> KeyPressedEvent : <span class="keyword">public</span> KeyEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">KeyPressedEvent</span>(<span class="type">int</span> keycode, <span class="type">int</span> repeatCount)</span><br><span class="line">		: <span class="built_in">KeyEvent</span>(keycode), <span class="built_in">m_RepeatCount</span>(repeatCount) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetRepeatCount</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_RepeatCount; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;KeyPressedEvent: &quot;</span> &lt;&lt; m_KeyCode &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; m_RepeatCount &lt;&lt; <span class="string">&quot; repeats)&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(KeyPressed)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_RepeatCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-KeyReleasedEvent类设计"><a href="#3-2-KeyReleasedEvent类设计" class="headerlink" title="3.2 KeyReleasedEvent类设计"></a>3.2 KeyReleasedEvent类设计</h3><p>和Pressed类基本一致，只不过没有repeatCount的计数内容；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> KeyReleasedEvent : <span class="keyword">public</span> KeyEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">KeyReleasedEvent</span>(<span class="type">int</span> keycode)</span><br><span class="line">		: <span class="built_in">KeyEvent</span>(keycode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;KeyReleasedEvent: &quot;</span> &lt;&lt; m_KeyCode;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(KeyReleased)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-EventDispatcher"><a href="#4-EventDispatcher" class="headerlink" title="4.EventDispatcher"></a>4.EventDispatcher</h2><p><strong>作用</strong><br>让我们可以实际的去发布一个事件，基于需要发布事件的类型；<br>创建一个Dispatcher的实例，并且拥有一个Event的引用。在这个Dispatcher中拥有一个Dispatch()方法，可以接受一个EventFn函数。然后如果类型一致，可以实际的在Dispatch中运行这个EventFn的函数。</p>
<p><strong>构造函数</strong><br>Event基类作为参数，接受各种事件类型，赋值在私有的Event变量上；</p>
<p><strong>Dispatch()方法</strong><br>在此方法内需要使用上Event，进行判断泛型传入的类型T的事件类型，和当前Dispatch中存储的Event的类型是否一致（通过GetEventType()方法，调用GetStaticType()方法）；<br>一致时，会调用EventFn中存储的函数，并返回bool；</p>
<p><strong>EventFn函数</strong><br>使用std的function，并且返回bool类型，接受T&amp;引用（可以为任何类型的Event）作为参数；</p>
<ul>
<li>补充：<strong>std::function()</strong><ul>
<li>可以把std::function看做一个函数对象，用于表示并存储函数这个抽象概念。</li>
<li>std::function的实例可以存储、复制和调用任何可调用对象（函数指针，类成员函数指针，bind表达式等等），存储的可调用对象称为std::function的目标，若std::function不含目标，则称它为空</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventDispatcher</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">using</span> EventFn = std::function&lt;<span class="built_in">bool</span>(T&amp;)&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">EventDispatcher</span>(Event&amp; event)</span><br><span class="line">		: <span class="built_in">m_Event</span>(event)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="type">bool</span> <span class="title">Dispatch</span><span class="params">(EventFn&lt;T&gt; func)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Event.<span class="built_in">GetEventType</span>() == T::<span class="built_in">GetStaticType</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			m_Event.m_Handled = <span class="built_in">func</span>(*(T*)&amp;m_Event);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Event&amp; m_Event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="5-MouseEvent设计"><a href="#5-MouseEvent设计" class="headerlink" title="5.MouseEvent设计"></a>5.MouseEvent设计</h2><p><strong>MouseMovedEvent</strong><br>传入x、y表示两个坐标位置，用于存储鼠标移动事件所需要的信息；<br>同理MouseScrolledEvent。<br>下面内容基本类似，主要关注构造函数中传入的参数的差别，代表了此种类型事件所实际需要使用到的数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseMovedEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MouseMovedEvent</span>(<span class="type">float</span> x, <span class="type">float</span> y)</span><br><span class="line">		: <span class="built_in">m_MouseX</span>(x), <span class="built_in">m_MouseY</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_MouseX; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetY</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_MouseY; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;MouseMovedEvent: &quot;</span> &lt;&lt; m_MouseX &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; m_MouseY;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(MouseMoved)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryMouse | EventCategoryInput)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> m_MouseX, m_MouseY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseScrolledEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MouseScrolledEvent</span>(<span class="type">float</span> xOffset, <span class="type">float</span> yOffset)</span><br><span class="line">		: <span class="built_in">m_XOffset</span>(xOffset), <span class="built_in">m_YOffset</span>(yOffset) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetXOffset</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_XOffset; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetYOffset</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_YOffset; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;MouseScrolledEvent: &quot;</span> &lt;&lt; <span class="built_in">GetXOffset</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="built_in">GetYOffset</span>();</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(MouseScrolled)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryMouse | EventCategoryInput)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> m_XOffset, m_YOffset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseButtonEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetMouseButton</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Button; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryMouse | EventCategoryInput)</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">MouseButtonEvent</span>(<span class="type">int</span> button)</span><br><span class="line">		: <span class="built_in">m_Button</span>(button) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Button;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseButtonPressedEvent : <span class="keyword">public</span> MouseButtonEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MouseButtonPressedEvent</span>(<span class="type">int</span> button)</span><br><span class="line">		: <span class="built_in">MouseButtonEvent</span>(button) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;MouseButtonPressedEvent: &quot;</span> &lt;&lt; m_Button;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(MouseButtonPressed)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseButtonReleasedEvent : <span class="keyword">public</span> MouseButtonEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MouseButtonReleasedEvent</span>(<span class="type">int</span> button)</span><br><span class="line">		: <span class="built_in">MouseButtonEvent</span>(button) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;MouseButtonReleasedEvent: &quot;</span> &lt;&lt; m_Button;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(MouseButtonReleased)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-ApplicationEvent设计"><a href="#6-ApplicationEvent设计" class="headerlink" title="6.ApplicationEvent设计"></a>6.ApplicationEvent设计</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> WindowResizeEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">WindowResizeEvent</span>(<span class="type">unsigned</span> <span class="type">int</span> width, <span class="type">unsigned</span> <span class="type">int</span> height)</span><br><span class="line">		: <span class="built_in">m_Width</span>(width), <span class="built_in">m_Height</span>(height) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Width; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Height; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;WindowResizeEvent: &quot;</span> &lt;&lt; m_Width &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; m_Height;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(WindowResize)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_Width, m_Height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> WindowCloseEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">WindowCloseEvent</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(WindowClose)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> AppTickEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AppTickEvent</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(AppTick)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> AppUpdateEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AppUpdateEvent</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(AppUpdate)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> AppRenderEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AppRenderEvent</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(AppRender)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>游戏引擎</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
        <tag>事件</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏引擎原理】P1：GPU驱动的几何管线</title>
    <url>/2023/08/fd049e549b6a.html</url>
    <content><![CDATA[<p>传统渲染问题：<br>在CPU端发出一个Draw Call，在此过程中GPU可能会一直在等待Draw Call，因此浪费大量性能；<br>在GPU中设置好数据，还要在CPU中处理各种计算，而且GPU要花费大量的时间在等待CPU的时间中，因为就算是计算一个非常简单的index，也需要把整个Render跑一遍。</p>
<span id="more"></span>
<h2 id="1-传统渲染管线"><a href="#1-传统渲染管线" class="headerlink" title="1 传统渲染管线"></a>1 传统渲染管线</h2><h3 id="1-1-传统渲染问题"><a href="#1-1-传统渲染问题" class="headerlink" title="1.1 传统渲染问题"></a>1.1 传统渲染问题</h3><p><strong>核心：所有的需求是在CPU那端发起</strong><br>在CPU端发出一个Draw Call，在此过程中GPU可能会一直在等待Draw Call，因此浪费大量性能；<br>在GPU中设置好数据，还要在CPU中处理各种计算，而且GPU要花费大量的时间在等待CPU的时间中，因为就算是计算一个非常简单的index，也需要把整个Render跑一遍。<br><strong>Draw Graphics API</strong><br>传统渲染管线跑现代游戏无法满足，现代CPU得先把数据准备好，然后再把数据给到GPU；</p>
<h3 id="1-2-Compute-Shader与GPU驱动管线"><a href="#1-2-Compute-Shader与GPU驱动管线" class="headerlink" title="1.2 Compute Shader与GPU驱动管线"></a>1.2 Compute Shader与GPU驱动管线</h3><p><strong>Compute Shader核心概念</strong><br>计算机不需要再CPU和GPU中来回导数据，所有的计算都在GPU的内部；<br>方法：</p>
<ol>
<li>在GPU中内置一些计算模块，很多计算直接在GPU中完成；把很多只有在CPU中才可以做的通用计算放到GPU上面；</li>
<li>单个Draw Call可以绘制多个Mesh；</li>
</ol>
<p><strong>更加进阶的状态：GPU驱动Render管线</strong><br>GPU控制什么对象该被实际的渲染，包括Lod Selection，Visibility Culling On GPU<br>CPU不触碰GPU的数据，尽量让CPU不那么忙；</p>
<p><strong>GPU驱动Render管线在材质中应用</strong><br>在《刺客信条大革命》中大场景的渲染，大场景当中有大量不可见的物体以及材质；</p>
<ul>
<li>解决方法<ul>
<li>对每个游戏世界中的物体，按照其Mesh把其分成无数个小的Clusters，计算这个小Clusters是否被遮挡</li>
<li>因为这种小粒度的Cluster在GPU中可以被批量处理，因此实际上性能更高，对于三角形有尽可能高的利用率；</li>
</ul>
</li>
</ul>
<p><strong>GPU驱动Pipeline概述</strong><br>流程图：<br><img src="/../../image/Pasted%20image%2020230827161631.png"></p>
<p>CPU阶段进行粗略的Culling，在GPU阶段进行更加精细的Culling，每一个物体被分成不同的Cluster，然后打包进一个非常大的Index Buffer当中。最后一个Draw Call一次性完成计算。<br>核心：通过前面GPU一大堆的计算，一次性将不可见的几何完成绘制；</p>
<p><strong>Work in CPU Side</strong><br>在CPU端只需要</p>
<h2 id="2-Occlusion-Culling与相机以及阴影"><a href="#2-Occlusion-Culling与相机以及阴影" class="headerlink" title="2 Occlusion Culling与相机以及阴影"></a>2 Occlusion Culling与相机以及阴影</h2><p>如何将观测或者光照不到的地方的渲染变得尽可能廉价；</p>
<p><strong>核心概念</strong><br>对于所有基于Cluster渲染的管线而言，Occlusion的计算都是十分关键的部分；<br>而Occlusion的基本思想，就是尽可能快速且低成本的基于当前相机的位置构建index buffer，类似于形成了一层幕布；当想渲染任何一个物体的时候，使用cluster渲染时使用这个index buffer在GPU中快速进行测试，快速将不需要渲染的部分剔除掉；</p>
<h3 id="2-1-Occlusion-Depth-Generation"><a href="#2-1-Occlusion-Depth-Generation" class="headerlink" title="2.1 Occlusion Depth Generation"></a>2.1 Occlusion Depth Generation</h3><p>遮挡深度生成：这个根据场景生成的Depth Buffer可以被重用；</p>
<p><strong>深度Pre-Pass与最好的Occluders在完整的像素当中</strong></p>
<ol>
<li>选择最好的occluders通过艺术资源或者heuristic</li>
<li>重新计算occluder</li>
<li>合并以及重投影与十六分之一的像素版本；</li>
<li>生成Z-Buffer用于GPU Culling计算；</li>
</ol>
<p><strong>两个阶段的Occlusion Culling</strong><br>第一阶段：把上一帧里面的所有物体，依据Z buffer数据测试一遍，对所有通过上一帧Z-Buffer的物体先绘制一遍；把可能可见的物体先跑一遍得出画面；<br>问题：此时得出的z很有可能是错误的，此时应该把所有认为可能不可见的物体也测试一遍Z-Buffer<br>第二阶段：在第一阶段过滤完之后，重新再测试一遍被忽略掉的物体，从而减少大量的渲染量，准确并且高效完成；<br><img src="/../../image/Pasted%20image%2020230827161702.png"></p>
<h3 id="2-2-可视化内容处理渲染管线"><a href="#2-2-可视化内容处理渲染管线" class="headerlink" title="2.2 可视化内容处理渲染管线"></a>2.2 可视化内容处理渲染管线</h3><p><strong>Visiblity Buffer</strong><br>Visiblity Buffer是一种新的越来越瘦关注的Buffer；<br>如果使用传统的Shading，每一次渲染都需要全部进行处理，处理的数据量非常大，因此可以把这些Texture可以全部打包放到一个Shading当中</p>
<p><strong>Deferred Shading 与 G-Buffer 存在的意义与问题</strong><br>Deffered Shading：在Deferred Shader中处理很多三角形的场景时，其不会保证优先绘制靠近相机的物体，因此对于同一个像素可能会渲染十几次，因为在这个像素上可能会有多个物体在其射线上；<br>大量的对G-Buffer的读写会产生大量的性能浪费；</p>
<p><strong>Visiblity Buffer</strong><br>解决方法：在第一帧渲染的时候，就只把几何数据渲染进去，而不是把Texture等其他数据全部在第一帧弄进去；在获得了这些几何体的位置信息后，再将其手动的把每个顶点该有的信息输入进去；<br>Shading阶段时，把几何体的每个像素位置拿到，反算出来其像素点应该有的反射率等信息，接下来对其进行Shading；<br>其非常适合在场景当中有大量的小物体，而且这些物体经常会被其他物体遮挡住；</p>
<p><strong>Visiblity Buffer与Deferred Shading结合</strong><br>将Visiblity和G-Buffer结合，G-Buffer的数据可以来自于传统渲染管线，也可以来自于Visiblity Buffer渲染管线；</p>
<h2 id="3-Nanite"><a href="#3-Nanite" class="headerlink" title="3 Nanite"></a>3 Nanite</h2><h3 id="3-1-前言"><a href="#3-1-前言" class="headerlink" title="3.1 前言"></a>3.1 前言</h3><p><strong>要解决的问题</strong><br>每个做Render的目标：在虚拟世界中还原现实世界，但现实世界中具有无限的几何细节。实时渲染的人希望在游戏当中实现无限的几何细节；</p>
<p><strong>Nanite基本的源头：Virtual Texture</strong><br>在真实的游戏场景当中拥有大量的texture，在游戏引擎中提出Virtual Texture的思想，即在游戏当中、离Camera的Texture精度高，离Camera远的Texture精度低；即先形成一大张的Virtual Texture；</p>
<p><strong>进一步推到：把几何Geometry也变成Virtual Map</strong><br>需要有一个方法把几何也变成Virtual Map；但这个过程十分困难，因为几何信息的处理比Texture困难很多；</p>
<ul>
<li>Voxels方法？<ul>
<li>难以表达高精度内容</li>
<li>数据量惊人</li>
<li>而且目前主流的艺术资产都不是基于Voxel表达的</li>
</ul>
</li>
<li>Subdivision Surfaces？<ul>
<li>增加几何的精细度</li>
<li>在实时给几何体细分表面</li>
</ul>
</li>
<li>Map-Based Method?<ul>
<li>难以表达表面特性</li>
<li>基于硬件的加密几何</li>
</ul>
</li>
</ul>
<p><strong>最后结果：基于三角形的几何构建</strong></p>
<h3 id="3-2-Virtual-Geometry"><a href="#3-2-Virtual-Geometry" class="headerlink" title="3.2 Virtual Geometry"></a>3.2 Virtual Geometry</h3><p><strong>Nanite中的几何表达</strong><br>无论增加多少的几何复杂度，屏幕上能够展示的几何数量终归是有限的，有像素上有一个或两个三角形就够了；<br>可以通过屏幕像素的精度来决定几何物体的精度；</p>
<ul>
<li>基于Cluster的几何表达<ul>
<li>将几何体分成不同的Cluster</li>
<li>让其根据View来决定Cluster的精度，不同的LOD在Cluster中具有不同的精度</li>
<li>对于屏幕空间最大化的利用<br><img src="/../../image/Pasted%20image%2020230827161729.png"></li>
</ul>
</li>
</ul>
<p><strong>Nanite的Cluster细分方法</strong><br>根据View的距离情况，根据LOD进行Cluster的简化，将其合成一份Cluster；<br>因此可以在游戏进行时，可以根据View距离加载不同的LOD；<br><strong>Cluster合并的问题</strong><br>不同LOD等级的物体之间衔接的时候会有问题，即本来是根据同一LOD构建出的几何体现在有部分表面其Cluster变成其他LOD是，分界处衔接有问题；<br>解决方法：把边给锁住；在边缘一直锁着LOD0的边；但是锁边的时候这些边的三角形数量也很高；并且因为人眼对于高频的信号感受力很强，因此对于这种边缘处突然出现的高频信号会有反应；</p>
<p><strong>对Cluster合并问题的解决：Cluster Group</strong><br>只缩Cluster Group的边，里面的Cluster再随意的去简化；<br>保证了在LOD切换的时候，不会在衔接处明显变化；<br>其希望被锁住的LOD的边在切换的时候不会注意到被缩边的Cluster Group;<br>如图是Cluster Group在不同LOD时变化：<br>乱中有序：底层的Cluster上层可能有多个，并且不会和上层的所有Cluster都产生关系；<br><img src="/../../image/Pasted%20image%2020230827161745.png"></p>
<h3 id="3-3-QEM"><a href="#3-3-QEM" class="headerlink" title="3.3 QEM"></a>3.3 QEM</h3><p>形成Cluster Group的流水线；<br><strong>LOD Selection For Cluster Group In Paralllel</strong><br>能不能让LOD的Selection可不可以被并行化，从左到右或者从右到左的遍历都有可能是不稳定的；<br>把Cluster节点组成的树状的LOD，变成数组的线性的LOD（通过把Cluster其对应父节点的信息存储进来）</p>
<ul>
<li>希望是独立的决策</li>
</ul>
]]></content>
      <categories>
        <category>游戏引擎</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
        <tag>技术美术</tag>
      </tags>
  </entry>
</search>
