<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【CSharp系列】CLR寄宿与AppDomain（1）-- 基本概念</title>
    <url>/2023/09/a5b39cbba297.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h1 id="1-CLR寄宿与AppDomain介绍"><a href="#1-CLR寄宿与AppDomain介绍" class="headerlink" title="1.CLR寄宿与AppDomain介绍"></a>1.CLR寄宿与AppDomain介绍</h1><p><strong>寄宿（hosting）基本概念</strong><br>CLR寄宿（Common Language Runtime Hosting）是指将托管代码与CLR（Common Language Runtime）进行交互的过程。 在C#中，CLR作为执行环境负责加载、执行和管理托管代码。 CLR寄宿则允许在托管环境之外，通过与CLR通信来扩展和控制CLR的行为。</p>
<ul>
<li>寄宿使得任何应用程序都可以使用CLR的功能，并且它使得现有的应用程序能部分使用托管代码编写；</li>
<li>寄宿为应用程序提供了编程的接口，来进一步的自定义以及扩展；<ul>
<li>可扩展性意味着第三方代码可以在进程中进行；</li>
<li>即可以使用DLL来扩展；但DLL中的代码容易破坏应用程序的状态（数据结构与代码），并可能利用应用程序本身的上下文来窃取无法访问的资源；</li>
</ul>
</li>
</ul>
<p><strong>CLR寄宿的使用场景</strong><br>在C#中，CLR寄宿的使用场景主要包括以下几个方面：</p>
<ol>
<li>自定义宿主环境：通过CLR寄宿，可以创建自定义的托管代码宿主环境，以满足特定的需求。 这样的需求可能包括自定义的安全性机制、资源管理、日志记录等。  </li>
<li>扩展CLR行为：通过CLR寄宿，可以扩展CLR的行为。 例如，可以在托管代码执行前进行一些预处理或后处理操作，或者向CLR注入自定义的监听器或拦截器。</li>
<li>与非托管代码的交互：CLR寄宿还提供了一种机制，使托管代码能够与非托管代码进行交互。 这样，可以在C#中调用C或C++编写的原生库，并利用其功能或性能优势。</li>
</ol>
<p><strong>AppDomain基本概念</strong><br>AppDomain是CLR中的一个隔离容器，用于在一个进程内运行多个托管代码的环境。 每个AppDomain都有自己的虚拟内存空间和加载上下文，可以加载和卸载托管程序集，并提供一定程度的隔离性和安全性。</p>
<ul>
<li>AppDomain 允许第三方的、不受信任的代码在现有的进程中运行，而CLR保证数据结构、代码和安全上下文不被滥用或破坏；</li>
</ul>
<p><strong>AppDomain使用场景</strong><br>在C#中，AppDomain的使用场景主要包括以下几个方面：</p>
<ol>
<li>插件化架构：通过使用AppDomain，可以实现插件化架构，将不同功能的托管代码加载到独立的AppDomain中。 这样可以有效隔离插件之间的冲突，提高应用程序的可靠性和扩展性。</li>
<li>动态加载和卸载程序集：AppDomain允许在运行时动态加载和卸载程序集，从而实现动态扩展应用程序的功能。 这对于需要灵活加载和卸载托管代码的场景非常有用。</li>
<li>安全隔离：每个AppDomain都有自己的安全策略和权限设置，可以提供一定程度的安全隔离。 这对于需要运行不可信代码或实现多级安全权限管理的应用程序非常重要。</li>
</ol>
<h1 id="2-CLR寄宿基础"><a href="#2-CLR寄宿基础" class="headerlink" title="2.CLR寄宿基础"></a>2.CLR寄宿基础</h1><p><strong>CLR寄宿运行环境</strong><br>因为NETFramework在Windows平台的顶部运行，所以.NET Framework必须用Windows能理解的技术来构建，即所有托管模块和程序集文件都必须使用 Windows PE文件格式，而且要么是Windows EXE文件，要么是DLL文件；</p>
<ul>
<li>对CLR开发<ul>
<li><ol>
<li>Microsoft实际是把它实现成包含在一个DLL中的COM服务器；</li>
</ol>
</li>
<li><ol start="2">
<li>Microsoft为CLR定义了一个标准的COM接口，安装.NET框架的时候代表CLR的COM服务器在微软的Windows注册表中登记；</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>创建CLR COM服务器实例</strong><br>创建实例：对于非托管宿主，应该使用MetaHost.h中的CLRCreateInstance来创建其实例；</p>
<ul>
<li>CLRCreateInstance函数与MSCorEE.dll<ul>
<li>此函数在 MSCorEE.dll 文件（垫片）中实现； </li>
<li>CLRCreateInstance 函数可返回一个 ICLRMetaHost 接口。宿主应用程序可调用这个接口的 GetRuntime 函数，指定宿主要创建的CLR的版本；</li>
<li>垫片将所需版本的CLR加载到宿主的进程中；</li>
</ul>
</li>
</ul>
<p><strong>MSCorEE.dll</strong><br>此文件在 C:\Windows\System32 目录下，MSCorEE.dll可决定创建什么版本的CLR；</p>
<ul>
<li>一个机器可以有多个版本的CLR，但只能有一个MSCorEE.dll；</li>
</ul>
<p><strong>GetRuntime函数</strong><br>此函数可以返回指向ICLRRuntimeInfo接口的指针；此指针可以利用GetInterface方法获得ICLRRuntimeHost接口；</p>
<ul>
<li>宿主应用程序可调用接口定义的方法做以下事情：<ul>
<li>设置宿主管理器：告诉 CLR 宿主想参与涉及以下操作的决策：内存分配、线程调度&#x2F;同步以及程序集加载等；</li>
<li>获取CLR管理器：告诉CLR阻止使用某些类&#x2F;成员。另外，宿主能分辨哪些代码可以调试，哪些不可以；</li>
<li>初始化并启动CLR；</li>
<li>加载程序集并执行其中的代码；</li>
<li>停止CLR；</li>
</ul>
</li>
</ul>
<h1 id="3-AppDomain基础"><a href="#3-AppDomain基础" class="headerlink" title="3.AppDomain基础"></a>3.AppDomain基础</h1><p><strong>AppDomain基础概念介绍</strong><br>AppDomain 是为了提供隔离而设计的。</p>
<ul>
<li>CLR COM 服务器初始时会创建一个AppDomain；</li>
<li>AppDomain 是一组程序集的逻辑容器，CLR初始化时创建的第一个AppDomain称为“默认AppDomain”，这个默认的AppDomain只有在Windows进程终止时才会被销毁；</li>
<li>除了默认 AppDomain，正在使用非托管COM接口方法或托管类型方法的宿主还可要求CLR创建额外的 AppDomain；</li>
</ul>
<h2 id="3-1-AppDomain具体功能"><a href="#3-1-AppDomain具体功能" class="headerlink" title="3.1 AppDomain具体功能"></a>3.1 AppDomain具体功能</h2><p><strong>功能1：一个AppDomain的代码不能直接访问另一个AppDomain代码创建的对象</strong></p>
<ol>
<li>AppDomain中的代码创建了一个对象后，该对象便被该AppDomain拥有；</li>
<li>换言之：它的生存期不能超过创建它的代码所在的AppDomain；</li>
<li>一个AppDomain中的代码要访问另一个AppDomain 中的对象，只能使用“按引用封送”(marshal-by-reference)或者“按值封送”(marshal-by-value)的语义。这就强制建立了清晰的分隔和边界，因为一个AppDomain中的代码不能直接引用另一个AppDomain中的代码创建的对象。</li>
<li>隔离的机制使 AppDomain 能很容易地从进程中卸载，不会影响其他 AppDomain 正在运行的代码；</li>
</ol>
<p><strong>功能2：AppDomain可以卸载</strong><br>CLR不支持从AppDomain中卸载特定的程序集，但可以告诉CLR卸载一个AppDomain，从而卸载该AppDomain当前包含的所有程序集；</p>
<p><strong>功能3：AppDomain可以单独保护</strong><br>AppDomain 创建后会应用一个权限集，它决定了向这个 AppDomain 中运行的程序集授予的最大权限；<br>由于存在这些权限，所以当宿主加载一些代码后，可以保证这些代码不会破坏宿主本身使用的一些重要数据结构；</p>
<p><strong>功能4：AppDomain可以单独配置</strong><br>AppDomain 创建后会关联一组配置设置，这些设置主要影响CLR在AppDomain中加载程序集的方式；<br>涉及搜索路径、版本绑定重定向、卷影复制以及加载器优化；</p>
<h2 id="3-2-AppDomain与Windows进程"><a href="#3-2-AppDomain与Windows进程" class="headerlink" title="3.2 AppDomain与Windows进程"></a>3.2 AppDomain与Windows进程</h2><p><strong>Windows上的进程</strong><br>一个Windows进程由若干AppDomain和执行引擎构成；其中运行着一个CLR COM服务器，该CLR当前管着两个AppDomain；</p>
<ul>
<li>Loader堆<ul>
<li>运行的AppDomain数量没有硬性制，每个AppDomain都有自己的 Loader 堆，每个 Loader 堆都记录了自 AppDomain 创以来已访问过哪些类型；</li>
<li>Loader 堆中的每个类型对象者有一个方法表，方法表中的每个记录项都指向JIT编译的本机代码（前提此方法得至少执行过一次）</li>
</ul>
</li>
<li>程序集<ul>
<li>每个AppDomain都加载了一些程序集，包括MyApp.exe、TypeLib.dll等；</li>
<li>两个AppDomain都加载了System.dll程序集，但类型对象的内存不会被两个AppDomain共享；</li>
<li>并且，AppDomain中的代码调用一个类型定义的方法时，方法的IL代码将进行JIT编译，生成的本机代码和每个单独的AppMain关联，而不和所有的AppDomain共享；</li>
</ul>
</li>
<li>MSCorLib.dd与程序集共享<ul>
<li>该程序集包含了System.Object、System.Int32以及其他所有与 .NET Framework 密不可分的类型；</li>
<li>CLR初始化时，该程序集会自动加载，而且所有AppDomain都共享该程序集中的类型；</li>
<li>为了减少资源消耗，MSCorLib.dll程序集以一种<strong>AppDomain中立</strong>的方式加载；</li>
<li>针对以 AppDomain 中立的方式加载的程序集，CLR会为它们维护一个特殊的 Loader 堆，该Loader 堆中的所有类型对象以及为这些类型定义的方法JIT编译生成的所有本机代码，都会由进程中的所有AppDomain共享；<br><img src="/../../image/Pasted%20image%2020230904120337.png"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>CLR</tag>
        <tag>AppDomain</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】CLR寄宿与AppDomain（2）-- 跨越AppDomain边界访问对象</title>
    <url>/2023/09/a1092601f220.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h1 id="1-跨AppDomain基本概念"><a href="#1-跨AppDomain基本概念" class="headerlink" title="1.跨AppDomain基本概念"></a>1.跨AppDomain基本概念</h1><p>一个 AppDomain 中的代码可以和另一个 AppDomain 中的类型和对象通信，但只能通过良好定义的机制进行。<br>以下代码演示了以下三种类型在构造时的不同行为：</p>
<ol>
<li>“按引用封送”(Marshal-by-Reference)类型；</li>
<li>“按值封送”(Marshalby-Value)类型；</li>
<li>完全不能封送的类型；<br>代码还演示了创建它们的 AppDomain 卸载时这些对象的不同行为。</li>
</ol>
<h2 id="1-1-AppDomain基本属性"><a href="#1-1-AppDomain基本属性" class="headerlink" title="1.1 AppDomain基本属性"></a>1.1 AppDomain基本属性</h2><p>Marshalling方法首先获得一个 AppDomain 对象引用，当前调用线程正在该 AppDomain 中执行；</p>
<p><strong>线程与AppDomain关系</strong></p>
<ul>
<li>在Windows中，线程总是在一个进程的上下文中创建，而且线程的整个生存期都在该进程的生存期内；</li>
<li><strong>线程和AppDomain没有一对一关系</strong>；<ul>
<li>AppDomain 是一项CLR的功能，Windows对AppDomain一无所知；</li>
<li>由于一个Windows进程可包含多个AppDomain，所以线程能执行一个AppDomain中的代码，再执行另一个AppDomain中的代码；</li>
<li>从CLR的角度看，线程一次只能执行一个 AppDomain 中的代码；</li>
</ul>
</li>
<li>线程可调用 System.Threading.Thread 的静态方法GetDomain，来向CLR询问它正在哪个AppDomain中执行；</li>
</ul>
<p><strong>友好名称</strong><br>AppDomain创建后可被赋予一个友好名称；</p>
<ul>
<li>它是用于标识AppDomain的一个String；</li>
<li>友好名称主要是为了方便调试，由于CLR要在我们的任何代码执行前创建默认 AppDomain，所以使用可执行文件的文件名作为默认的 AppDomain 友好名称；</li>
<li>Marshalling 方法使用System.AppDomain的只读FriendlyName属性来查询默认AppDomain的友好名称。</li>
</ul>
<h1 id="2-按引用传递进行跨AppDomain通信"><a href="#2-按引用传递进行跨AppDomain通信" class="headerlink" title="2.按引用传递进行跨AppDomain通信"></a>2.按引用传递进行跨AppDomain通信</h1><p><strong>创建新AppDomain</strong><br>通过调用<code>System.AppDomain</code>的静态方法<code>CreateDomain()</code>来指示同一个Window进程中，创建一个AppDomain；</p>
<p><strong>CreateDomain方法</strong><br>CreateDomain 方法内部会在进程中新建一个AppDomain，该AppDomain将被赋予指定的友好名称、安全性和配置设置；<br>新 AppDomain 有自己的 Loader 堆，这个堆目前是空的，因为还没有程序集加载到新AppDomain中；<br>创建AppDomain时，CLR不在这个AppDomain中创建任何线程。AppDomain中也不会运行代码，除非显式地让一个线程调用AppDomain中的代码。</p>
<ul>
<li>参数一<ul>
<li>代表新的AppDomain的友好名称的String；</li>
</ul>
</li>
<li>参数二<ul>
<li>用于设置新的AppDomain的权限集合；</li>
<li><code>System.Security.Policy.Evidence</code>用于计算权限集，传递null时表示继承自创建它的AppDomain；</li>
<li>构建权限集：<code>System.Security.PermissionSet</code>；</li>
</ul>
</li>
<li>参数三<ul>
<li>用于设置新的AppDomain的属性配置；</li>
<li>可以使用<code>AppDomainSetup</code>来进行特殊配置；</li>
</ul>
</li>
</ul>
<p><strong>在新AppDomain中创建类型实例</strong><br>在新AppDomain中创建类型实例主要分为两个步骤：</p>
<ol>
<li>将程序集加载到新的AppDomain中；</li>
<li>构造程序集中定义类型的实例（由CreateInstanceAndUnwrap方法实现）；</li>
</ol>
<ul>
<li>CreateInstanceAndUnwrap 方法<ul>
<li>参数一：标识了想在新AppDomain中加载的程序集；</li>
<li>参数二：标识了想构建其实例的那个类型的名称；</li>
<li>内部实现：<ul>
<li><ol>
<li>CreateInstanceAndUnwrap 方法导致调用线程从当前 AppDomain 切换新的 AppDomain，线程将指定的程序集加载到新的AppDomain当中</li>
</ol>
</li>
<li><ol start="2">
<li>扫描程序集的类型定义元数据表，查找参数二中传入的指定的类型；</li>
</ol>
</li>
<li><ol start="3">
<li>调用将找到的类型的无参构造函数；</li>
</ol>
</li>
<li><ol start="4">
<li>返回默认 AppDomain ，使用返回的对象引用；</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="完整代码附录"><a href="#完整代码附录" class="headerlink" title="完整代码附录"></a>完整代码附录</h1><p><img src="/../../image/Pasted%20image%2020230905114123.png"><br><img src="/../../image/Pasted%20image%2020230905114139.png"><br><img src="/../../image/Pasted%20image%2020230905114150.png"><br><img src="/../../image/Pasted%20image%2020230905114204.png"><br><img src="/../../image/Pasted%20image%2020230905114214.png"></p>
<p>你好 winsadwanidw 你的，windows, C#</p>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>CLR</tag>
        <tag>AppDomain</tag>
        <tag>进程</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】1. CLR执行模型</title>
    <url>/2023/08/5aed3da140f6.html</url>
    <content><![CDATA[<p>将源代码编译成托管模块<br><strong>定义：公共语言运行时（Common Language Runtime，CLR）</strong><br>描绘：是一个可以由多种编程语言使用的”运行时”，其核心功能包括：</p>
<ol>
<li>内存管理</li>
<li>程序集加载</li>
<li>安全性</li>
<li>异常处理</li>
<li>线程同步<span id="more"></span></li>
</ol>
<h2 id="1-1-将源代码编译成托管模块"><a href="#1-1-将源代码编译成托管模块" class="headerlink" title="1.1 将源代码编译成托管模块"></a>1.1 将源代码编译成托管模块</h2><p><strong>定义：公共语言运行时（Common Language Runtime，CLR）</strong><br>描绘：是一个可以由多种编程语言使用的”运行时”，其核心功能包括：</p>
<ol>
<li>内存管理</li>
<li>程序集加载</li>
<li>安全性</li>
<li>异常处理</li>
<li>线程同步<br>这些功能可以由所有面向CLR的语言使用。基于CLR的托管语言和非托管C++语言，在系统层面后者可以进行更低级别的控制，可以完全按照自己的想法管理内存。而CLR不管开发者使用哪一种编程语言写源代码，只要其是面向CLR的。因此，CLR提供了其他技术所无法媲美的集成度，使得混合语言编程成为了开发者可以考虑的一个选项。<br>为了执行包含托管代码以及托管数据的模块，用户必须在自己的计算机上安装好CLR（目前作为.NET Framework的一部分被提供）</li>
</ol>
<p>补充：可将编译器是为语法检查其和“正确代码分析器”。</p>
<p><strong>定义：托管模块（managed module）</strong><br>描述：托管模块是标准的32位（PE32）或者64位（PE32+）的Microsoft Windows可移植体文件，基于CLR来运行。<br>托管模块四大部分：</p>
<ol>
<li>PE32 或 PE32+头：如果是依赖于本机CPU的代码，此项会包含和本机CPU相关的信息。</li>
<li>CLR头：包含使这个模块成为托管模块的信息，比如CLR版本，Main方法位置，MethodDef数据，模块元数据等</li>
<li>元数据：源代码的定义数据，源代码的引用数据</li>
<li>IL代码：编译器编译源代码时生成的代码，运行时CLR将IL编译成编辑CPU代码</li>
<li></li>
</ol>
<p><strong>定义：托管代码（managed code）</strong><br>描述：每个面向CLR的编译器生成的代码，都是IL代码（中间代码），IL代码又被称作托管代码。<br>IL代码比大部分CPU机器语言都更加高级，其可以访问和操作对象的类型，并且提供了指令来创建和初始化对象那个、调用对象上的虚方法以及直接操作数组元素。在此意义上，可以将IL理解成是一种<strong>面向对象的机器语言</strong>。<br>补充：使用高级语言只能使用CLR全部功能当中的一个子集，但IL汇编语言运行开发人员访问CLR全部功能。<br>逻辑关系：<br>![[Chapter 1：CLR执行模型 2023-03-07 19.16.22.excalidraw]]</p>
<h2 id="1-2-将托管模块合并成程序集"><a href="#1-2-将托管模块合并成程序集" class="headerlink" title="1.2 将托管模块合并成程序集"></a>1.2 将托管模块合并成程序集</h2><p><strong>定义：程序集（assembly）</strong><br>描述：CLR实际上并不和托管模块工作，而是和程序集工作。生成的程序集既可以时可执行文件，也可以是DLL，最终由CLR管理这些程序集中的代码的执行。<br>内容：</p>
<ol>
<li>程序集是一个或者多个模块&#x2F;资源文件的逻辑性分组；</li>
<li>程序集是重用、安全性以及版本控制的最小单元；</li>
<li>利用程序集，可以将一组文件作为一个单独的实体来对待；<br>优势：程序集把文件的逻辑表示和物理表示区分开，利用程序集可以在不同的地方部署文件，在使用到其时再进行下载，不使用其时可以无需下载，但是在对待程序集时确依然将其视为一个整体</li>
</ol>
<p>逻辑关系：<br>![[Chapter 1：CLR执行模型 2023-03-07 19.30.58.excalidraw]]</p>
<h2 id="1-3-加载公共语言运行时"><a href="#1-3-加载公共语言运行时" class="headerlink" title="1.3 加载公共语言运行时"></a>1.3 加载公共语言运行时</h2><p><strong>简介</strong><br>在CLR运行之前，需要设置其平台选项指定最后生成的程序集能够在指定的平台上运行。</p>
<p><strong>CLR运行前设置：设置不同CPU版本</strong><br>在CLR加载之前，C#编译器提供了一个&#x2F;platform的命令行选项，允许指定最后生成的程序集能够在指定的平台上运行。<br>取决于&#x2F;platform开关选项，C#编译器生成的程序集要么包含PE32，要么是PE32+，在可执行文件运行前，Windows会检查文件头，判断需要的是32位还是64位的地址空间。<br>之后，Windows检查EXE文件头，决定创建32位或者64位进程，并在进程地址空间加载MSCorEE.dll的x86、x64或者ARM版本。</p>
<p><strong>MSCorEE.dll</strong><br>进程在Windows当中检查文件头后，需要决定创建32位或者64位进程，之后会在进程的地址空间内加载MSCorEE.dll的对应CPU版本，其不同版本都在<code>%SystemRoot%\System32</code>或者<code>%SystemRoot%\SysWow64</code>目录中。之后进程的主线程调用MSCorEE当中的定义的一个方法，此方法初始化CLR，并加载EXE程序集，调用入口方法Main。</p>
<p><strong>加载CLR</strong></p>
<ol>
<li>可执行文件运行前，Windows会检查文件头，判断需要的是32位还是64位的地址空间。</li>
<li>Windows检查EXE文件头，决定创建32位或者64位进程，并在进程地址空间加载MSCorEE.dll的x86、x64或者ARM版本。</li>
<li>进程的主线程调用MSCorEE.dll中定义的一个方法，此方法初始化CLR，加载EXE程序集，调用其入口方法Main，然后托管应用程序启动并运行。</li>
</ol>
<p>![[Chapter 1：CLR执行模型 2023-03-07 20.10.16.excalidraw]]</p>
<h2 id="1-4-执行程序集的代码"><a href="#1-4-执行程序集的代码" class="headerlink" title="1.4 执行程序集的代码"></a>1.4 执行程序集的代码</h2><p>定义：即时编译器（Just in time，JIT）<br>描述：在执行程序集中IL代码的方法后，需要将IL代码转换成本机（native）指令，此时就由CLR当中的JIT编译器来实现。JIT编译器动态的将本机CPU代码存储到动态内存中，因此一旦应用程序停止，编译好的代码也会被丢弃，之后再次启动或者存在两个实例时需要在此编译。</p>
<p>定义：记录项<br>描述：CLR会分配一个内部的数据结构来管理对引用类型的访问。CLR将引用的类型当中的每个方法都设置一个记录项，这个记录项都含有一个地址，此地址指向该方法的具体实现。当JIT访问记录项，想编译对应函数时，即可顺着此记录项找到对应IL代码。</p>
<p><strong>执行过程</strong><br>在Main方法执行之前，CLR检测出Main代码引用的所有类型，导致CLR分配一个内部的数据结构来管理对引用类型的访问。CLR将引用的类型当中的每个方法都设置一个记录项， CLR将每个记录项设置为包含在CLR内部的一个未编档函数，此函数为JITCompiler。在调用对应方法时，JITCompiler被调用，查询元数据找到IL代码，并且将此IL代码编译成本机CPU指令。<br>本机CPU代码动态分配到内存块当中，然后JITCompiler回到CLR为类型创建的内部数据结构，找到被调用方法对应的那条记录，将其修改（原本为对JITCompiler的引用）为指向CPU代码的内存块。第二次验证时，会跳过JITCompiler函数，直接执行内存块当中的代码。因为第二次调用不需要编译，因此只有在首次调用时有一些性能损失。</p>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>CLR</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】托管堆与垃圾回收（1）-- 托管堆</title>
    <url>/2023/08/4b26dd1d757b.html</url>
    <content><![CDATA[<ul>
<li><ol>
<li>为什么要有托管堆</li>
</ol>
</li>
<li><ol start="2">
<li>什么是托管堆</li>
</ol>
</li>
<li><ol start="3">
<li>垃圾回收算法</li>
</ol>
<ul>
<li><ol>
<li>引用计数算法</li>
</ol>
</li>
<li><ol start="2">
<li>引用跟踪算法<span id="more"></span></li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="1-为什么要有托管堆"><a href="#1-为什么要有托管堆" class="headerlink" title="1.为什么要有托管堆"></a>1.为什么要有托管堆</h1><h2 id="1-1-面向对象与资源分配"><a href="#1-1-面向对象与资源分配" class="headerlink" title="1.1 面向对象与资源分配"></a>1.1 面向对象与资源分配</h2><p><strong>面向对象中的资源</strong><br>概念：在面向对象的环境中，任何一种类型都代表了计算机中可供程序使用的一种资源。如果要使用这种资源，就需要为这种资源分配一定的内存；</p>
<p><strong>资源分配步骤</strong></p>
<ul>
<li>第一步<ul>
<li>调用IL代码<code>newobj</code>，为代表资源的类型分配内存；</li>
<li>此步骤通常由new操作符来触发并完成；</li>
</ul>
</li>
<li>第二步<ul>
<li>根据类型的状态设置，初始化内存，设置资源的初始状态并使得此资源可用；</li>
<li>由类型的实例构造函数来设置初始状态；</li>
</ul>
</li>
<li>第三步<ul>
<li>访问类型的成员来使用此资源</li>
</ul>
</li>
<li>第四步<ul>
<li>摧毁资源的状态，以进行垃圾的清理</li>
</ul>
</li>
<li>第五步<ul>
<li>由GC回收期释放内存</li>
</ul>
</li>
</ul>
<h2 id="1-2-为什么需要托管堆来进行垃圾回收"><a href="#1-2-为什么需要托管堆来进行垃圾回收" class="headerlink" title="1.2 为什么需要托管堆来进行垃圾回收"></a>1.2 为什么需要托管堆来进行垃圾回收</h2><p><strong>C++中的例子</strong><br>在需要程序员手动管理内存的语言中（比如当C++不使用shareptr或其他基于对象的指针时），程序员经常会产生两种错误：</p>
<ol>
<li>忘记释放不再需要的内存，进而造成内存泄漏；</li>
<li>尝试使用已经释放的内存，造成安全漏洞；<br>由于这两种错误经常是在程序运行时才能发现，因此程序发生异常时调试困难。</li>
</ol>
<p><strong>解决方法：可验证的、类型安全的代码</strong><br>在资源分配阶段中的【第四步】，此步骤若不是由程序员来完成，而是交给程序的托管堆和垃圾回收器来自动进行时，此时程序就能进一步的保证安全；</p>
<ul>
<li>托管堆会自动完成垃圾的回收，并且当需要手动进行回收时，托管堆还提供了一个简化的模型；</li>
</ul>
<p><strong>补充：需要特殊清理的类型</strong><br>部分包装了本机资源的类型，比如对文件、Socket、数据库连接资源的类型，可能无法使用自动进行的垃圾回收，而是需要程序员使用GC的手动触发；</p>
<h1 id="2-什么是托管堆"><a href="#2-什么是托管堆" class="headerlink" title="2.什么是托管堆"></a>2.什么是托管堆</h1><h2 id="2-1-托管堆基本概念"><a href="#2-1-托管堆基本概念" class="headerlink" title="2.1 托管堆基本概念"></a>2.1 托管堆基本概念</h2><p><strong>托管堆</strong><br>在C#中，托管堆是一种用于存储和管理托管对象（即运行在CLR中的对象）的内存区域。它是CLR的一部分，为托管对象提供动态内存分配和释放的功能。托管堆是一种自动化内存管理机制，它通过垃圾回收器自动回收不再使用的对象，从而释放内存并确保内存的正确使用。</p>
<p><strong>NextObjPtr</strong><br>CLR会在程序的托管堆中管理一个指针NextObjPtr，此指针会一直指向下一个对象在队中分配的位置。在最开始时，此指针指向地址空间的基地址；</p>
<p><strong>内存自动扩张</strong><br>在一个区域的内存备非垃圾对象填满之后，CLR会自动分配更多的区域。此过程会一直进行，直到进程的地址空间被填满；</p>
<h2 id="2-2-CLR中的new行为"><a href="#2-2-CLR中的new行为" class="headerlink" title="2.2 CLR中的new行为"></a>2.2 CLR中的new行为</h2><p><strong>执行行为</strong><br>C#的new操作符将导致CLR执行以下步骤：</p>
<ul>
<li>第一步<ul>
<li>计算类型的字段(包括从基类型继承的字段)所需的字节数。</li>
</ul>
</li>
<li>第二步<ul>
<li>加上对象额外所需的两部分开销所需的字节数；</li>
<li>每个对象都有两个开销字段：<ul>
<li>类型对象指针</li>
<li>同步块索引</li>
</ul>
</li>
<li>对于32位应用程序，这两个字段各自需要 32位，所以每个对象要增加8字节。对于64位应用程序，这两个字段各自需要64位，所以每个对象要增加16字节；</li>
</ul>
</li>
<li>第三步<ul>
<li>检查阶段：<ul>
<li>CLR检查区域中是否有分配对象所需的字节数。如果托管堆有足够的可用空间，就在NextObiPtr 指针指向的地址处放入对象，为对象分配的字节会被清零；</li>
</ul>
</li>
<li>调用阶段<ul>
<li>调用类型的构造器，为类型构造器中的this参数传递当前NextObiPtr指向的对象，new操作符返回对象引用；</li>
<li>在返回这个引用之前，NextObjiPtr指针的值会加上对象占用的字节数来得到一个新值，即下个对象放入托管堆时的地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>分配之后的内存，在空间中形式如下简图：<br><img src="/../../image/Pasted%20image%2020230828103459.png" alt="新初始化的托管堆，其中构造了3个对象"></p>
<h2 id="2-3-托管堆与空间局部化"><a href="#2-3-托管堆与空间局部化" class="headerlink" title="2.3 托管堆与空间局部化"></a>2.3 托管堆与空间局部化</h2><p><strong>空间局部化</strong><br>由于托管堆的分配是在指针之上加一个值，因此其分配的速度非常的快；差不多同时分配的对象彼此间有较强的联系，而且经常差不多在同一时间访问；</p>
<ul>
<li><strong>由于托管堆在内存中连续分配这些对象，所以会因为引用的“局部化”(locality)而获得性能上的提升</strong></li>
</ul>
<p><strong>具体的优点</strong></p>
<ul>
<li>优点一<ul>
<li>进程的工作集会非常小，应用程序只需使用很少的内存，从而提高了速度；</li>
</ul>
</li>
<li>优点二<ul>
<li>代码使用的对象可以全部驻留在 CPU 的缓存中。应用程序能以非常快的速度访问这些对象，因为CPU在执行大多数操作不会因Cache Miss而被迫访问较慢的 RAM；</li>
</ul>
</li>
</ul>
<h1 id="3-垃圾回收算法"><a href="#3-垃圾回收算法" class="headerlink" title="3.垃圾回收算法"></a>3.垃圾回收算法</h1><p>在应用程序调用new操作符创建对象时，可能会没有足够地址空间来分配该对象，此时CLR就需要执行垃圾回收。</p>
<h2 id="3-1-引用计数算法"><a href="#3-1-引用计数算法" class="headerlink" title="3.1 引用计数算法"></a>3.1 引用计数算法</h2><p><strong>什么是引用计数算法</strong><br>对于对象生存期的管理，有些系统使用的是引用计数算法；<em>比如微软的COM</em></p>
<p><strong>算法内容</strong><br>堆上的每个对象都维护着一个内存字段，用于统计程序中多少部分正在使用对象。随着每一部分到达代码中某个不再需要对象的地方，就递减对象的计数字段。当计数字段变成0，对象就可以从内存中删除；</p>
<p><strong>算法问题：循环引用</strong><br>在一些GUI应用程序中，窗口对象将容纳对子UI对象的引用，而子UI对象将容纳对父窗口对象的引用；<br>这种引用会阻止两个对象的计数器达到 0，所以两个对象永远不会删除，即使应用程序本身不再需要窗口。</p>
<ul>
<li>CLR不使用引用计数算法，而是使用<strong>引用跟踪算法</strong>；</li>
</ul>
<h2 id="3-2-引用跟踪算法"><a href="#3-2-引用跟踪算法" class="headerlink" title="3.2 引用跟踪算法"></a>3.2 引用跟踪算法</h2><p><strong>算法特点</strong><br>引用跟踪算法只关心引用类型的变量，不关心值类型变量。因为只有引用类型的变量才能引用堆上的对象，而值类型变量直接包含值类型实例本身。</p>
<p><strong>基础概念：根</strong><br>在CLR中，将所有引用类型的变量称为<strong>根</strong>；<br>引用类型变量可以在许多场合使用：</p>
<ul>
<li>类的静态字段</li>
<li>类的实例字段</li>
<li>方法参数</li>
<li>局部变量<br>这些内容都可以成为根。</li>
</ul>
<h3 id="3-2-1-算法实现"><a href="#3-2-1-算法实现" class="headerlink" title="3.2.1 算法实现"></a>3.2.1 算法实现</h3><p><strong>第一阶段：暂停阶段</strong><br>暂停进程中的所有线程。这防止线程在CLR检查期间访问对象并更改其状态；</p>
<p><strong>第二阶段：标记阶段</strong></p>
<ul>
<li>CLR 遍历堆中的所有对象，将同步块索引字段中的一位设为 0；<em>当此位设为 0 时，表示此对象应该被删除；为 1 时表示不用删除；</em></li>
<li>设置为 0 之后，表明所有对象都应删除。然后，CLR 检查所有活动根，查看它们引用了哪些对象。如果一个根包含null，CLR忽略这个根并继续检查下个根；</li>
<li>任何根如果引用了堆上的对象，CLR 都会标记那个对象，也就是将该对象的同步块索引中的位设为 1。一个对象被标记后，CLR 会检查那个对象中的根，标记它们引用的对象。如果发现对象已经标记，就不重新检查对象的字段。这就避免了因为循环引用而产生死循环。</li>
<li>全部检查完毕后，堆中的对象要么已标记，要么未标记。<ul>
<li>已标记的对象不能被垃圾回收，因为至少有一个根在引用它。这种对象是<strong>可达reachable</strong>的对象。因为应用程序代码可通过仍在引用它的变量抵达它；</li>
<li>未标记的对象是<strong>不可达unreachable</strong>的，因为应用程序中不存在使对象能被再次访问的根；</li>
</ul>
</li>
</ul>
<p>图示为回收之前的托管堆：<br><img src="/../../image/Pasted%20image%2020230828105510.png" alt="回收之前的托管堆"></p>
<p><strong>第三阶段：压缩阶段</strong><br>CLR对堆中已标记的对象进行“内存位置的转移，压缩所有幸存下来的对象，使它们占用连续的内存空间，如图所示：<br><img src="/../../image/Pasted%20image%2020230828105609.png" alt="垃圾回收之后的托管堆"></p>
<ul>
<li>压缩的好处：<ul>
<li>所有幸存对象在内存中紧挨在一起，恢复了引用的“局部化”，减小了应用程序的工作集，从而提升了将来访问这些对象时的性能；</li>
<li>解决了原生堆的空间碎片化问题；</li>
</ul>
</li>
<li>内存偏移<ul>
<li>在内存中移动了对象之后有一个问题待解决：引用幸存对象的根现在引用的还是对象最初在内存中的位置，而非移动之后的位置；</li>
<li>CLR要从每个根减去所引用的对象在内存中偏移的字节数，保证每个根还是引用和之前一样的对象–只是对象在内存中变换了位置；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>垃圾回收</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】托管堆与垃圾回收（3）-- 特殊资源对象</title>
    <url>/2023/08/5f4541f148f0.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<ul>
<li><ol>
<li>特殊资源对象</li>
</ol>
</li>
<li><ol start="2">
<li>Finalize特点</li>
</ol>
</li>
<li><ol start="3">
<li>SafeHandle类</li>
</ol>
<ul>
<li>3.1 SafeHandle类基本概念</li>
<li>3.2 SafeHandle特点<span id="more"></span></li>
</ul>
</li>
</ul>
<h1 id="1-特殊资源对象"><a href="#1-特殊资源对象" class="headerlink" title="1.特殊资源对象"></a>1.特殊资源对象</h1><p><strong>什么是特殊资源对象</strong><br>对于C#中的大部分对象而言，只要有内存的分配既可以正常工作。但是还有一部分对象其使用了其他特殊的资源，比如IO设备、线程、锁、Socket等等。<br><em>例如，System.IO.FileStream类型需要打开一个文件(本机资源)并保存文件的指针。然后类型的Read和Write方法用此指针操作文件。类似地，System.Threading.Mutex类型要打开一个Windows互斥体内核对象(本机资源)并保存其对象的指针，并在调用Mutex的方法时使用该对象。</em></p>
<p><strong>如何处理特殊资源对象：Finalize终结</strong><br>对于这些特殊资源对象，不可以直接对象内存进行回收，而是应该在回收之前先对其进行一些处理，保证其在回收之前执行一些代码。</p>
<ul>
<li>Finalize终结机制：<ul>
<li>CLR提供了称为终结的机制，允许对象在被判定为垃圾之后，但在对象内存被回收之前执行一些代码。</li>
<li>任何包装了本机资源(文件、网络连接、套接字、互斥体)的类型都支持终结。CLR 判定一个对象不可达时，对象将终结它自己，释放它包装的本机资源。</li>
</ul>
</li>
</ul>
<p><strong>Finalize方法</strong><br>在System.Object中定义了受保护的虚方法：Finalize<br>垃圾回收器判定对象是垃圾后，会调用对象的Finalize方法。C#要求在类名前面加上“～”符号来定义Finalize方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SomeType</span></span><br><span class="line">&#123;</span><br><span class="line">	~SomeType()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//这里的代码会进入Finalize方法	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-Finalize特点"><a href="#2-Finalize特点" class="headerlink" title="2.Finalize特点"></a>2.Finalize特点</h1><p><strong>特点一：执行终结导致对象存活变长</strong></p>
<ul>
<li>被视为垃圾的对象在垃圾回收完毕之后才会调用 Finalize 方法，所以这些对象的内存不是马上被回收的；</li>
<li>可终结对象在回收时必须存活，造成它会提升一代，使对象活得比正常时间长，增大了内存耗用；更糟的是，可终结对象被提升时，其字段引用的所有对象也会被提升，因为它们也必须继续存活。</li>
<li>建议<ul>
<li>要尽量避免为引用类型的字段定义可终结对象；</li>
<li>尽量不要直接使用 Finalize 方法；</li>
</ul>
</li>
</ul>
<p><strong>特点二：无法控制Finalize执行的时间</strong></p>
<ul>
<li>CLR不保证多个Finalize方法的调用顺序。所以在Finalize方法中，<strong>不要访问定义了Finalize方法的其他类型的对象</strong>：那些对象可能已经终结了；</li>
<li>但可以安全地访问值类型的实例，或者访问没有定义 Finalize 方法的引用类型的对象；</li>
</ul>
<p><strong>特点三：CLR使用一个特殊、高优先级的线程调用Finalize方法</strong></p>
<ul>
<li>为了避免死锁，CLR使用专用线程来负责此方法的执行；</li>
<li>但也同时，如果一个Finalize方法阻塞，该线程也就无法再调用任何更多的Finalize方法；</li>
</ul>
<p><strong>结论：Finalize只是用于释放本机资源而设计的</strong></p>
<ul>
<li>建议：不要重写Obiect的Finalize方法；</li>
<li>正确做法是：使用Microsoft在FCL中提供的辅助类；<ul>
<li>这些辅助类重写了Finalize方法；</li>
<li>添加了一些特殊的CLR代码，可以从这些辅助类派生出自己的类；</li>
</ul>
</li>
</ul>
<h1 id="3-SafeHandle类"><a href="#3-SafeHandle类" class="headerlink" title="3.SafeHandle类"></a>3.SafeHandle类</h1><h2 id="3-1-SafeHandle类基本概念"><a href="#3-1-SafeHandle类基本概念" class="headerlink" title="3.1 SafeHandle类基本概念"></a>3.1 SafeHandle类基本概念</h2><p><strong>SafeHandle类的定义</strong><br>SafeHandle类是一个抽象基类，位于System.Runtime.InteropServices命名空间中；<br>它用于提供一个安全的封装器，用于管理本机资源的句柄（例如文件句柄、内核对象句柄等）；<br>SafeHandle类通过派生具体的子类，提供了一种可靠的方式来管理和释放这些句柄。</p>
<p><strong>SafeHandle类解决的问题</strong><br>SafeHandle类解决了在C#中使用本机资源句柄时的一些常见问题，例如：</p>
<ul>
<li>1.内存泄漏：在编写使用本机资源的代码时，如果不正确地释放句柄，可能会导致内存泄漏；</li>
<li>2.不确定的错误：使用不正确的句柄或重复释放句柄可能会导致不确定的行为和错误；</li>
<li>3.线程安全：在多线程环境下，对句柄的访问必须进行适当的同步，以确保不会导致竞态条件或其他线程相关的问题；<br>SafeHandle类通过提供一个可继承的模板，规范了如何正确使用和自动释放本机资源句柄，从而解决了上述问题。</li>
</ul>
<p><strong>SafeHandle和Finalize方法的关系</strong></p>
<ul>
<li>核心：SafeHandle类通过覆盖Finalize方法来增强对句柄的管理和释放；</li>
<li>内容：<ul>
<li>Finalize方法是C#中的垃圾回收器提供的一个特殊方法，用于在对象被垃圾回收之前执行清理操作。</li>
<li>SafeHandle类中的子类通常会重写Dispose方法和Finalize方法。Dispose方法用于显式地释放句柄和其他资源，而Finalize方法则是在垃圾回收器执行回收操作之前被自动调用。</li>
</ul>
</li>
</ul>
<h2 id="3-2-SafeHandle特点"><a href="#3-2-SafeHandle特点" class="headerlink" title="3.2 SafeHandle特点"></a>3.2 SafeHandle特点</h2><h3 id="3-2-1-派生自CriticalFinalizerObject类"><a href="#3-2-1-派生自CriticalFinalizerObject类" class="headerlink" title="3.2.1 派生自CriticalFinalizerObject类"></a>3.2.1 派生自CriticalFinalizerObject类</h3><p><strong>核心概念：SafeHandle继承自CriticalFinalizerObject类</strong></p>
<p><strong>功能一：首次构造时执行JIT编译</strong></p>
<ul>
<li>内容<ul>
<li>首次构造任何CriticalFinalizerObject的派生类型对象时，CLR立即对<strong>继承层次结构中的所有 Finalize 方法进行JIT编译</strong>；</li>
</ul>
</li>
<li>目的<ul>
<li>构造对象时就编译这些方法，可确保当对象被确定为垃圾之后，本机资源肯定会得以释放；</li>
<li>不对 Finalize 方法进行提前编译，那么也许能分配并使用本机资源，但无法保证释放；</li>
<li>因为<strong>内存紧张时，CLR可能找不到足够的内存来编译Finalize方法</strong>，这会阻止Finalize方法的执行，造成本机资源泄漏；</li>
<li>因为提前进行JIT编译，可以解决这个问题；</li>
</ul>
</li>
</ul>
<p><strong>功能二：</strong></p>
<ul>
<li>调用Finalize顺序<ul>
<li>CLR是在调用了非 CriticalFinalizerObject 派生类型的 Finalize 方法之后，才调用CriticalFinalizerObject派生类型的Finalize方法；</li>
<li>托管资源类因此可以在它们的Finalize方法中成功地访问CriticalFinalizerObject派生类型的对象；</li>
<li><em>例如FileStream类的Finalize方法可以放心地将数据从内存缓冲区 fush到磁盘，它知道此时磁盘文件还没有关闭；</em></li>
</ul>
</li>
</ul>
<h3 id="3-2-2-SafeHandle是抽象类"><a href="#3-2-2-SafeHandle是抽象类" class="headerlink" title="3.2.2 SafeHandle是抽象类"></a>3.2.2 SafeHandle是抽象类</h3><p>为了能够使用此类，必须有另一个类从该类派生，并重写以下内容：</p>
<ol>
<li>受保护的构造函数</li>
<li>抽象方法ReleaseHandle</li>
<li>抽象属性IsInvalid的get访问器</li>
</ol>
<p><strong>辅助类：SafeHandleZero0rMinusOnelsInvalid类</strong><br>此类继承自SafeHandle，也是一个抽象类，用于辅助进行类的派生；</p>
<ul>
<li>抽象类：<ul>
<li>必须有另一个类从该类派生，并重写它的受保护构造器和抽象方法ReleaseHandle；</li>
<li>NETFramework 提供了几个从SafeHandleZero0rMinusOneIsInvalid 派生的公共类，包括：<ul>
<li>SafeFileHandle</li>
<li>SafeRegistryHandle</li>
<li>SafeWaitHandle</li>
<li>SafeMemoryMappedViewHandle</li>
</ul>
</li>
</ul>
</li>
<li>其他继承自SafeHandleZero0rMinusOnelsInvalid的类<ul>
<li>SafeProcessHandle</li>
<li>SafeThreadHandle</li>
<li>SafeTokenHandleSafeLibraryHandle</li>
<li>SafeLocalAllocHandle</li>
</ul>
</li>
</ul>
<h3 id="3-2-3-SafeHandle作用"><a href="#3-2-3-SafeHandle作用" class="headerlink" title="3.2.3 SafeHandle作用"></a>3.2.3 SafeHandle作用</h3><ol>
<li>修正了潜在的资源泄露问题：SafeHandle收到CLR的特殊对待；</li>
<li>防止有人利用潜在的安全漏洞</li>
</ol>
<h2 id="3-3-SafeHandle使用"><a href="#3-3-SafeHandle使用" class="headerlink" title="3.3 SafeHandle使用"></a>3.3 SafeHandle使用</h2><p><strong>如何使用包装了本机资源的类型：以FileStream类为例</strong></p>
<ul>
<li>FileStream介绍<ul>
<li>System.Io.FileStream 可用于打开一个文件，从文件中读取字节，向文件写入字节，然后关闭文件；</li>
<li>FileStream类还提供子几个额外的属性：Length、Position、CanRead和方法Read、Write、Flush；</li>
</ul>
</li>
<li>问题<ul>
<li><img src="/../../image/Pasted%20image%2020230901152011.png"></li>
<li>问题描述：<ul>
<li>File的静态 Delete 方法可能会要求 Windows 删除一个仍然打开的文件，此时 Delete 方法会抛出System.IO.IOException 的异常；</li>
</ul>
</li>
<li>文件可能“误打误撞”地被删除<ul>
<li>如果另一线程不知怎么造成了一次垃圾回收，而且这次垃圾回收刚好在调用 Write 之后、调用Delete之前发生，那么FileStream的SafeFileHandle字段的 Finalize 方法就会被调用，这会关闭文件，随后 Delete操作也就可以正常运行；</li>
</ul>
</li>
</ul>
</li>
<li>解决方法<ul>
<li>可以使用Dispose方法来完成资源显示的释放；</li>
<li>在File.Delete()之前，先调用<code>fs.Dispose()</code>方法；</li>
</ul>
</li>
</ul>
<h3 id="3-3-1-Dispose方法与对象生存期控制"><a href="#3-3-1-Dispose方法与对象生存期控制" class="headerlink" title="3.3.1 Dispose方法与对象生存期控制"></a>3.3.1 Dispose方法与对象生存期控制</h3><p>当想要控制类所包裹的本机资源的生存期时，就必须实现IDispose接口：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Dispose</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>什么是Dispose方法</strong></p>
<ul>
<li>Dispose方法描述<ul>
<li>在C#编程语言和CLR（公共语言运行时）中，Dispose方法是一种用于释放资源的标准机制。它主要用于管理和释放那些需要手动处理的非托管资源，例如文件、数据库连接、网络连接和操作系统句柄等。Dispose方法允许在使用完资源后立即释放它们，以避免资源的长时间占用和浪费。</li>
</ul>
</li>
<li>Dispose方法的作用<ul>
<li>Dispose方法的主要作用是在使用完资源后进行释放和清理。它可以用来执行以下任务：</li>
<li><ol>
<li>关闭文件、释放文件句柄，并确保文件被正确关闭。</li>
</ol>
</li>
<li><ol start="2">
<li>断开数据库连接，释放数据库资源，并确保连接被关闭。</li>
</ol>
</li>
<li><ol start="3">
<li>关闭网络连接，释放网络资源，并确保连接被断开。</li>
</ol>
</li>
<li><ol start="4">
<li>释放其他非托管资源，如图形设备接口（GDI）对象、操作系统句柄等。</li>
</ol>
</li>
<li>通过实现Dispose方法，我们可以明确地告知程序何时应该释放资源，而不仅仅依赖于垃圾回收机制。</li>
</ul>
</li>
</ul>
<p><strong>Dispose方法和SafeHandle的关系</strong><br>Dispose方法通常与SafeHandle类一起使用，以确保资源的正确释放；</p>
<ul>
<li>SafeHandle类为Dispose方法提供了一个机制：使得在对象的生命周期结束时，自动调用Dispose方法，即使存在异常或错误也能正确处理资源的释放。</li>
<li>通过结合使用Dispose方法和SafeHandle类，我们可以更可靠和安全地管理非托管资源，提高代码的健壮性和可维护性。</li>
</ul>
<p><strong>什么时候使用Dispose</strong><br>需要注意的是：并不是一定要调用Dispose才能保证本机资源得到清理。本机资源的清理最终总会发生，<strong>调用Dispose只是控制这个发生的时机</strong>；</p>
<ul>
<li>调用Dispose不会将托管对象从托管堆删除。只有在垃圾回收之后，托管堆中的内存才会得以回收；</li>
<li>这意味着：即使 Dispose 了托管对象过去用过的任何本机资源，也能在托管对象上调用方法；<ul>
<li><img src="/../../image/Pasted%20image%2020230901153633.png"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>垃圾回收</tag>
        <tag>线程</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】托管堆与垃圾回收（2）-- 基于代的垃圾回收算法</title>
    <url>/2023/08/2d466e9f916b.html</url>
    <content><![CDATA[<ul>
<li><ol>
<li>垃圾回收的基本假设</li>
</ol>
</li>
<li><ol start="2">
<li>垃圾回收算法</li>
</ol>
<ul>
<li>2.1 初始化堆与第0代对象</li>
<li>2.2 从第0代对象到第1代对象</li>
<li>2.3 从第1代对象到第2代对象</li>
</ul>
</li>
<li><ol start="3">
<li>垃圾回收触发条件</li>
</ol>
<ul>
<li>3.1 监视垃圾回收内存使用</li>
</ul>
</li>
<li><ol start="4">
<li>大对象</li>
</ol>
</li>
<li><ol start="5">
<li>垃圾回收模式</li>
</ol>
</li>
</ul>
<span id="more"></span>
<h1 id="1-垃圾回收的基本假设"><a href="#1-垃圾回收的基本假设" class="headerlink" title="1.垃圾回收的基本假设"></a>1.垃圾回收的基本假设</h1><p>由于CLR的GC是基于代的垃圾回收器算法，因此其对代码做出了以下几点假设：</p>
<ul>
<li><ol>
<li>对象越新，生存期越短；</li>
</ol>
</li>
<li><ol start="2">
<li>对象越老，生存期越长；</li>
</ol>
</li>
<li><ol start="3">
<li>回收堆的一部分，速度快于回收整个堆；<br>以上假设对于大部分的现代应用程序都成立，其影响了下面GC算法的实现。</li>
</ol>
</li>
</ul>
<h1 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h1><h2 id="2-1-初始化堆与第0代对象"><a href="#2-1-初始化堆与第0代对象" class="headerlink" title="2.1 初始化堆与第0代对象"></a>2.1 初始化堆与第0代对象</h2><p><strong>实现过程</strong></p>
<ul>
<li>预算容量<ul>
<li>CLR初始化时，为第0代对象选择一个预算容量。</li>
</ul>
</li>
<li>启动垃圾回收<ul>
<li>如果分配一个新对象造成第0代超过预算，就必须立马就启动一次垃圾回收。</li>
<li>假设此时初始化时分配的对象刚好用完第0代的空间，那么分配下一个对象就必须启动垃圾回收。</li>
</ul>
</li>
<li>压缩对象<ul>
<li>垃圾回收器判断对象C和E是垃圾，所以会压缩对象D，使之与对象B相邻。</li>
</ul>
</li>
<li>进入第1代<ul>
<li>在垃圾回收中存活的对象A，B和D现在成为第1代对象。第1代对象已经经历了垃圾回收器的一次检查；</li>
<li>此时第0代不包含任何对象，当下一次再分配内存时，新对象会被继续分配到第0代之中；</li>
</ul>
</li>
</ul>
<p><strong>图片展示</strong><br>初始化堆：<br><img src="/../../image/Pasted%20image%2020230829101037.png"></p>
<p>启动垃圾回收+压缩对象+进入第1代：<br><img src="/../../image/Pasted%20image%2020230829101102.png"></p>
<h2 id="2-2-从第0代对象到第1代对象"><a href="#2-2-从第0代对象到第1代对象" class="headerlink" title="2.2 从第0代对象到第1代对象"></a>2.2 从第0代对象到第1代对象</h2><p><strong>实现过程</strong></p>
<ul>
<li>继续分配<ul>
<li>新分配的对象继续进入第0代；</li>
<li>部分对象（包含第1代与第0代）在程序运行时，逐渐变得不可达；</li>
</ul>
</li>
<li>启动垃圾回收<ul>
<li>新对象造成第0代超出预算；</li>
</ul>
</li>
<li>决定GC检查代<ul>
<li>垃圾回收器必须决定检查哪些代。开始一次垃圾回收时，垃圾回收器除了检查第0代时，还会检查第1代占用了多少内存。</li>
<li>在下图中，由于第1代占用的内存远少于预算，所以垃圾回收器只检查第0代中的对象；</li>
</ul>
</li>
</ul>
<p><strong>基本假设与基于代的GC</strong></p>
<ul>
<li>假设一：对象越新，生存期越短<ul>
<li>因为新的对象在第0代中，并且第0代包含更多垃圾的可能性很大，在GC时能回收更多的内存；</li>
<li>即<strong>对象越新，生存期越短</strong></li>
<li>并且由于忽略了第1代中的对象，所以加快了垃圾回收速度</li>
</ul>
</li>
<li>假设三：回收堆的一部分，速度快于回收整个堆<ul>
<li>忽略第1代中的对象能提升垃圾回收器的性能。对性能有更大提振作用的是：现在不必遍历托管堆中的每个对象；</li>
<li>如果根或对象引用了老一代的某个对象，垃圾回收器就可以忽略老对象内部的所有引用，能在更短的时间内构造好可达对象图；</li>
</ul>
</li>
</ul>
<p><strong>图片展示</strong><br>产生新对象，垃圾产生：<br><img src="/../../image/Pasted%20image%2020230829101709.png"></p>
<p>垃圾回收，对象压缩：<br><img src="/../../image/Pasted%20image%2020230829101728.png"></p>
<h2 id="2-3-从第1代对象到第2代对象"><a href="#2-3-从第1代对象到第2代对象" class="headerlink" title="2.3 从第1代对象到第2代对象"></a>2.3 从第1代对象到第2代对象</h2><p><strong>实现过程</strong></p>
<ul>
<li>全部预算已满<ul>
<li>假定第1代的增长导致它的所有对象占用了全部预算。此时应用程序继续运行并分配对象，使第0代对象达到它的预算容量；</li>
<li>此时由于第0代已满，必须进行垃圾回收；</li>
<li>此次垃圾回收时发现第1代占用太多空间，导致全部预算用完（并且第1代当中已经有很多对象变得不可达）；</li>
<li>此次垃圾回收需要堆第0代以及第1代对象进行回收；</li>
</ul>
</li>
<li>产生第2代<ul>
<li>经过垃圾回收，产生第2代对象；第0代继续空余出来；</li>
<li><strong>只有在第1代超出预算时才会检查第1代中的对象</strong></li>
</ul>
</li>
</ul>
<p><strong>托管堆与代</strong></p>
<ul>
<li>3代托管堆<ul>
<li>托管堆只支持三代：第0代、第1代和第2代，没有第3代。</li>
</ul>
</li>
<li>代与预算<ul>
<li>CLR初始化时，会为每一代选择预算；</li>
</ul>
</li>
<li>CLR 的垃圾回收器是自调节的<ul>
<li>垃圾回收器会在执行垃圾回收的过程中了解应用程序的行为；<ul>
<li>假定应用程序构造了许多对象，但每个对象用的时间都很短。在这种情况下，对第0代的垃圾回收会回收大量内存；</li>
<li>事实上，第0代的所有对象都可能被回收；</li>
</ul>
</li>
<li><strong>当GC发现回收0代后存活下来的对象很少，就可能减少第0代的预算，反之增加预算</strong>。这种启发式的算法对第1代以及第2代通用适用；</li>
<li>每当垃圾回收进行后，会检查存活下来的对象多少，进而增大或减小这些代的预算；</li>
</ul>
</li>
</ul>
<h1 id="3-垃圾回收触发条件"><a href="#3-垃圾回收触发条件" class="headerlink" title="3.垃圾回收触发条件"></a>3.垃圾回收触发条件</h1><p><strong>垃圾回收可以有以下几种触发条件</strong></p>
<ol>
<li>CLR检测垃圾回收超出代的预算；</li>
<li>代码显示调用System.GC的静态方法Collect；</li>
<li>Windows报告低内存情况；</li>
<li>CLR卸载AppDomain；</li>
<li>CLR关闭；</li>
</ol>
<p><strong>强制垃圾回收</strong><br>System.GC类型允许应用程序对垃圾回收器进行一些直接控制。可以用Collect进行强制垃圾回收，但大部分情况下不推荐。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Collect</span>(<span class="params">Int32 generation,GCCollectionMode mode,Boolean blocking</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>generation<ul>
<li>表示回收第几代的垃圾</li>
</ul>
</li>
<li>GCCollectionMode<ul>
<li>Default：不传递任何符号名称；</li>
<li>Forced：强制回收指定的代(以及低于它的所有代)；</li>
<li>Optimized：只有在能释放大量内存或者能减少碎片化的前提下，才执行回收（强制执行Collect时，尽可能使用这种模式）；</li>
</ul>
</li>
</ul>
<h2 id="3-1-监视垃圾回收内存使用"><a href="#3-1-监视垃圾回收内存使用" class="headerlink" title="3.1 监视垃圾回收内存使用"></a>3.1 监视垃圾回收内存使用</h2><p><strong>监视用方法</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">Int32 <span class="title">CollectionCount</span>(<span class="params">Int32 generation</span>)</span>;</span><br><span class="line"><span class="function">Int64 <span class="title">GetTotalMemory</span>(<span class="params">Boolean forceFullCollection</span>)</span>;</span><br></pre></td></tr></table></figure>
<h1 id="4-大对象"><a href="#4-大对象" class="headerlink" title="4.大对象"></a>4.大对象</h1><p><strong>什么是大对象</strong><br>在CLR当中，将对象分为大对象和小对象，大于85000字节的对象是大对象；</p>
<p><strong>大对象特点</strong></p>
<ul>
<li>大对象在进程地址空间其他地方分配；</li>
<li>目前的GC不压缩大对象；</li>
<li>大对象总是第2代的，不可能为第0、1代；</li>
</ul>
<h1 id="5-垃圾回收模式"><a href="#5-垃圾回收模式" class="headerlink" title="5.垃圾回收模式"></a>5.垃圾回收模式</h1><p><strong>两种基本的GC模式</strong></p>
<ul>
<li>工作站模式<ul>
<li>该模式针对客户端应用程序优化GC；</li>
<li><strong>CLR默认以工作站模式运行</strong></li>
<li>GC造成的延时很低，应用程序的线程挂起时间短，并且GC假定机器上运行的其他应用程序都不会消耗太多的CPU资源；</li>
</ul>
</li>
<li>服务器模式<ul>
<li>该模式针对服务器端应用程序优化GC；</li>
<li>被优化的主要是吞吐量和资源利用。GC假定机器上没有运行其他应用程序，并假定机器的所有CPU都可用来辅助完成GC；</li>
<li>该模式造成托管堆被拆分成几个区域，每个CPU一个；</li>
<li>开始垃圾回收时，垃圾回收器在每个CPU上都运行一个特殊线程，每个线程都和其他线程并发回收它自己的区域；</li>
<li>这个功能要求应用程序在多CPU计算机上运行使线程能真正地同时工作，从而获得性能的提升。</li>
</ul>
</li>
</ul>
<p><strong>切换工作模式</strong><br>GCLatencyMode定义四种模式：</p>
<ol>
<li>Batch：服务器GC模式的默认值，关闭并发GC；</li>
<li>Interactive：工作站GC模式的默认值，打开并发GC；</li>
<li>LowLatency：此模式时，GC将全力避免第2代垃圾的回收。更容易抛出内存溢出异常；</li>
<li>SustainedLowLatency；</li>
</ol>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>垃圾回收</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Prompt编写指南</title>
    <url>/2023/08/081ae7892f5f.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<ul>
<li><ol>
<li>基础知识</li>
</ol>
<ul>
<li>1.1 两种LLM</li>
<li>1.2 提问原则</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h1><h2 id="1-1-两种LLM"><a href="#1-1-两种LLM" class="headerlink" title="1.1 两种LLM"></a>1.1 两种LLM</h2><p><strong>Base LLM</strong><br>基于文字数据进行文字的接龙，基于互联网的数据进行文本内容的猜测。</p>
<p><strong>Instruction Tuned LLM</strong><br>这种模型训练的方法：先训练出来Base LLM，然后再在Base LLM的基础之上，在大量的IO指令基础上进行微调，再通过RLHF技术进行进一步的优化。使得系统能够更好的接受输入以及输出。<br>对于大部分情况下，都为使用ITLLM进行学习以及开发。</p>
<ul>
<li>因为ITLLM是基于指令（关键词）进行的矫正、输出，因此当结果不合适时，应对重写选择合适的指令；</li>
</ul>
<h2 id="1-2-提问原则"><a href="#1-2-提问原则" class="headerlink" title="1.2 提问原则"></a>1.2 提问原则</h2><h3 id="1-2-1-原则一：编写明确、具体的指令"><a href="#1-2-1-原则一：编写明确、具体的指令" class="headerlink" title="1.2.1 原则一：编写明确、具体的指令"></a>1.2.1 原则一：编写明确、具体的指令</h3><p>明确 不等于 简短，为了明确的指令，可以提供更多的描述，来保证上下文信息的重组；</p>
<p><strong>具体方法1：使用分隔符清楚的指示输入的不同部分</strong></p>
<ul>
<li>分隔符可以是任何清晰的符号：引号、分割号、三引号、XML标记等</li>
<li>让模型知道：这是一个单独的部分</li>
</ul>
<p><strong>具体方法2：要求结构化的输出</strong><br>可以要求HTML、JSON、XML、MD等具体格式的输出；</p>
<p><strong>具体方法3：要求模型检查条件是否被满足</strong><br>当问题是基于某些假设时，可以先让模型检查这些假设；如果不满足条件，则指示停止尝试完全完成这些任务。</p>
<p><strong>具体方法4：少量训练提示</strong><br>在前面有成功回答的问题时，可以要求模型，它的任务是以一致的风格回答问题；</p>
<h3 id="1-2-2-原则二：给模型时间去思考"><a href="#1-2-2-原则二：给模型时间去思考" class="headerlink" title="1.2.2 原则二：给模型时间去思考"></a>1.2.2 原则二：给模型时间去思考</h3><p>模型无法处理过于复杂的问题。因此需要给模型“时间”去思考；</p>
<p><strong>具体方法1：指定完成任务所需的步骤</strong><br>具体指明回答时的步骤，比如：<br><em>第一步：总结要点<br>第二步：将要点翻译成英文<br>第三步：列出每一个要点的名称以及总结<br>第四步：输出JSON格式的内容</em></p>
<p><strong>具体方法2：指示模型在做出结论之前，先思考解决方案</strong><br>在模型给出具体的答案之前，先给时间去进行问题的实际思考；<br>比如让模型先用自己的计算方法进行计算，然后再和给出的答案进行比较；<br><em>1、先给出你自己的解决方案</em><br><em>2、再该处你自己的解决方案之前，不要决定解决方案是否正确</em></p>
<p><strong>具体方法3：面对幻觉时，要求模型先给出引用，再基于引用给出答案</strong><br>由于模型并不知道自己知识的边界，因此可能会编造出看起来十分正确的回答；<br>为了解决这种问题，可以要求：</p>
<ol>
<li>模型先给出针对问题的答案的引用；</li>
<li>要求模型基于这些引用，回答相关问题；</li>
</ol>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>ChatGPT</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>AI时代个人生存指南</title>
    <url>/2023/08/62011fb26306.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<ul>
<li><ol>
<li>ChatGPT使用基础</li>
</ol>
<ul>
<li>1.1 ChatGPT的使用之道</li>
<li>1.2 ChatGPT的使用之术</li>
</ul>
</li>
<li><ol start="2">
<li>Midjourney使用基础</li>
</ol>
<ul>
<li>2.1 Midjourney的使用之道</li>
<li>2.2 Midjourney的使用之术<span id="more"></span></li>
</ul>
</li>
</ul>
<h1 id="1-Chat-GPT使用基础"><a href="#1-Chat-GPT使用基础" class="headerlink" title="1.Chat GPT使用基础"></a>1.Chat GPT使用基础</h1><p><strong>核心思想：拥抱AI，理解AI，成为AI</strong></p>
<ul>
<li>拥抱AI<ul>
<li>率先掌握AI技能，掌握竞争优势；</li>
</ul>
</li>
<li>理解AI<ul>
<li>知道AI的能力，知道AI能做什么；</li>
<li>同时反推自己的发展方向：AI不能做什么，就是人未来能做的事情；</li>
</ul>
</li>
<li>成为AI<ul>
<li>率先向AI学习，让自己的思维和AI同步；</li>
<li>谁和AI最像，谁就获得了第一批AI带来的绝对优势；</li>
</ul>
</li>
</ul>
<h2 id="1-1-ChatGPT的使用之道"><a href="#1-1-ChatGPT的使用之道" class="headerlink" title="1.1 ChatGPT的使用之道"></a>1.1 ChatGPT的使用之道</h2><p><strong>前言：关于prompt</strong><br>虽然目前依然需要使用prompt来辅助AI，但未来的AI发展是其越来越理解人类想要什么，而不需要使用prompt来提示；</p>
<blockquote>
<p><em>prompt教程推荐：吴恩达的prompt视频（适合程序员）：<br><a href="https://www.bilibili.com/video/BV1Z14y1Z7LJ/?spm_id_from=333.337.search-card.all.click&vd_source=3f70c2a1700b0323e22826080d18a119">https://www.bilibili.com/video/BV1Z14y1Z7LJ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3f70c2a1700b0323e22826080d18a119</a></em></p>
</blockquote>
<p><strong>概念：ChatGPT能做什么</strong><br>首先思考AI能做什么，在了解AI能做的事情的情况下，再思考应该让它如何做这件事情；<br>AI的画像：<strong>一个学习过网上所有知识，保守而道德的名校大学生。理性思考5秒钟，回答10句话。</strong></p>
<ul>
<li>知识：只存留在2021年；</li>
<li>保守：没有独特思想；</li>
<li>道德：有人类设定的道德包袱；</li>
<li>名校本科生水平：不接受过于复杂的问题，可以回答大部分知识问题；</li>
<li>理性思考5秒钟：不能接受过度复杂问题；</li>
</ul>
<p><strong>道一：Chat GPT的道德</strong><br>AI的回答是很道德的回答。当和价值立场或者观点相关的问题时，只会给出不同的立场，而不表达观点；</p>
<ul>
<li>甚至会出现<strong>道德在事实之上</strong>；</li>
<li>为了保证道德的限制，甚至让道德在事实之上；<br><em>或许道德极大的限制了LLM的能力。</em></li>
</ul>
<p><strong>道二：Chat GPT的知识</strong><br>一般本科大学生的知识它都会；并且理解能力强。</p>
<p><strong>道三：Chat GPT的提问</strong><br>对于提问，遵循两个原则：<strong>拆分、直接</strong>；</p>
<ul>
<li>直接：<ul>
<li>提问不能太复杂，但是可以很困难；</li>
</ul>
</li>
<li>拆分：<ul>
<li>回答内容不能太长，所以一开始就设计多个问题，对各个部分拆分提问；</li>
<li>对很长内容的提问：先提问大纲内容，再对每个大纲的细分内容进行提问；</li>
</ul>
</li>
</ul>
<p><strong>道四：面对AI的幻觉</strong><br>AI是语言生成模型，即按照上一句话生成下一句话；</p>
<ul>
<li>AI会出现强行回答，AI自己也无法分辨真假；</li>
<li>如何面对AI回答的幻觉：<ul>
<li>逻辑推演；</li>
<li>拥有常识；</li>
<li>自行验证；</li>
</ul>
</li>
</ul>
<p><strong>道五：把寻找和使用AI工具，纳入接受新工作的思考流程</strong><br>在接受一份新工作的时候，首先就可以想一想：当中有哪些工作是AI可以做的；并且把它纳入到生成流程当中。</p>
<p><strong>补充：AI大模型的数据截止到2021年</strong><br>在2021年之前的数据，在LLM当中都有；但2021年之后的数据，AI自己也需要去查（通过OpenAI的服务器去访问这些网站）；</p>
<p><strong>应用场合</strong></p>
<ul>
<li>文字工作<ul>
<li>套路文章创作，润色，翻译，取标题，举例子</li>
</ul>
</li>
<li>生活助手<ul>
<li>普通问题咨询</li>
</ul>
</li>
</ul>
<h2 id="1-2-ChatGPT的使用之术"><a href="#1-2-ChatGPT的使用之术" class="headerlink" title="1.2 ChatGPT的使用之术"></a>1.2 ChatGPT的使用之术</h2><p><strong>术一：描述好背景信息</strong><br>在向AI咨询一个问题前，一定要先描述好问题的背景信息；<br>如果不清楚描述什么背景，可以<strong>向AI提问，这个问题需要了解什么背景信息</strong>；</p>
<p><strong>术二：提问计算方法，再得到结果</strong><br>如果直接问AI一个问题的答案，AI可能难以回答。但是如果提问AI一个问题的计算方法，AI的回答正确率更高；</p>
<ul>
<li>AI知道计算的方法，但不擅长计算</li>
<li>对AI进行复杂计算的提问：可以<strong>先问过程，再顺着过程问答案</strong>；</li>
</ul>
<p><strong>术三：让他扮演一个角色</strong><br>让他扮演一个角色，作为一个角色来回答你的问题；<br><em>你现是一个作家、你现在是一个软件公司的文案总监、你现在是一个法律顾问</em></p>
<h1 id="2-Midjourney使用基础"><a href="#2-Midjourney使用基础" class="headerlink" title="2.Midjourney使用基础"></a>2.Midjourney使用基础</h1><h2 id="2-1-Midjourney使用之道"><a href="#2-1-Midjourney使用之道" class="headerlink" title="2.1 Midjourney使用之道"></a>2.1 Midjourney使用之道</h2><p><strong>道一：创作具有艺术感的图像</strong><br>AI绘画可以模仿多种艺术风格，创造性的运用绘画技巧，并进行独特的构图和色彩搭配；</p>
<p><strong>道二：难以处理复杂边缘、空间关系的物体</strong><br>这与扩散模型的原理有关。现阶段，扩散模型可学习的样本图片的清晰度普遍较低，导致模型在处理某些细节时需要进行“猜测”。因此，我们常常发现AI绘制的手指存在错误，其他具有复杂边缘的物体也存在同样的问题。另外，扩散模型并非从空间角度理解图像，因此在处理物体间复杂的空间关系时，AI可能会遇到困难</p>
<p><strong>道三：难以同时绘制多个对象，并且每个对象有不同的属性</strong><br>AI可能无法准确理解多个对象和这些对象之间的属性关系，或者可能会忽略掉一些关键属性。 </p>
<h2 id="2-2-Midjourney使用之术"><a href="#2-2-Midjourney使用之术" class="headerlink" title="2.2 Midjourney使用之术"></a>2.2 Midjourney使用之术</h2><p><strong>术一：Prompt能力</strong><br>使用明确且具体的语言，来描述任务；</p>
<p><strong>术二：用尽可能清晰的语言</strong><br>Midjourney的语言文字理解能力不如Chat GPT；</p>
<p><strong>术三：工具本身的熟练程度</strong></p>
<ul>
<li>设置宽高比；</li>
<li>混乱程度；</li>
<li>使用种子；</li>
</ul>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>【商业系列】商业计划书大纲与内容</title>
    <url>/2023/08/efa8d1f054ea.html</url>
    <content><![CDATA[<p><strong>商业计划书大纲</strong></p>
<ul>
<li>1、 团队简介</li>
<li>2、 项目内容</li>
<li>3、 团队组成</li>
<li>4、 市场规模与分析</li>
<li>5、 商业模式</li>
<li>6、 战略规划<span id="more"></span></li>
</ul>
<h1 id="1-内容大纲"><a href="#1-内容大纲" class="headerlink" title="1.内容大纲"></a>1.内容大纲</h1><ul>
<li>1、 团队简介</li>
<li>2、 项目内容<ul>
<li>1、项目介绍</li>
<li>2、核心优势</li>
</ul>
</li>
<li>3、 团队组成</li>
<li>4、 市场规模与分析<ul>
<li>1、 市场分析</li>
<li>2、 竞品分析</li>
</ul>
</li>
<li>5、 商业模式<ul>
<li>1、 商业模式介绍</li>
<li>2、 相关数据</li>
</ul>
</li>
<li>6、 战略规划<ul>
<li>1、 战略目标</li>
<li>2、 实现路径</li>
</ul>
</li>
</ul>
<h1 id="2-各部分编写思路"><a href="#2-各部分编写思路" class="headerlink" title="2.各部分编写思路"></a>2.各部分编写思路</h1><h2 id="2-1-团队简介"><a href="#2-1-团队简介" class="headerlink" title="2.1 团队简介"></a>2.1 团队简介</h2><p><strong>内容构成</strong>：一句话介绍 + 50~100字团队简介</p>
<p><strong>一句话介绍</strong><br>内容尽可能简短、清晰，直接了当的了解当前团队的：</p>
<ol>
<li>核心业务内容</li>
<li>核心优势</li>
</ol>
<p><strong>团队简介</strong><br>简要介绍团队业务以及数据规模等内容；</p>
<h2 id="2-2-项目内容"><a href="#2-2-项目内容" class="headerlink" title="2.2 项目内容"></a>2.2 项目内容</h2><h3 id="2-2-1-项目介绍"><a href="#2-2-1-项目介绍" class="headerlink" title="2.2.1 项目介绍"></a>2.2.1 项目介绍</h3><p><strong>编写内容核心</strong><br>把此业务最吸引人、最有发展潜力的部分展现出来；</p>
<ul>
<li>分析方法<ul>
<li>简介：先确定此项目属于哪一种类型，然后再根据此类型的核心点，编写文字内容</li>
<li><ol>
<li>增长型项目（还没开始或刚开始）</li>
</ol>
<ul>
<li>侧重增长，大量数据放在此项目板块的<strong>发展潜力以及我们的优势</strong>上面</li>
</ul>
</li>
<li><ol start="2">
<li>运营型项目（已经开始）</li>
</ol>
<ul>
<li>侧重盈利，大量文字放在介绍当前流量的<strong>转化率以及盈利能力</strong>上</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>图片展示</strong><br>技术型项目给出吸引人的文字图片内容，吸引浏览者观看；</p>
<h3 id="2-2-2-核心优势"><a href="#2-2-2-核心优势" class="headerlink" title="2.2.2 核心优势"></a>2.2.2 核心优势</h3><p><strong>分析方法</strong><br>分析目前团队的开发能力当中，和竞品相比最具有优势的部分；</p>
<ul>
<li>流量矩阵：<ul>
<li>自媒体流量（自带宣传流量）</li>
<li>开发团队（丰富开发经验）</li>
<li>项目案例（Unity3D）</li>
</ul>
</li>
</ul>
<h2 id="2-3-团队组成"><a href="#2-3-团队组成" class="headerlink" title="2.3 团队组成"></a>2.3 团队组成</h2><p><strong>分析方法</strong><br>根据核心优势部分分析的结果，部分的去过滤团队介绍部分所需要呈现的内容；<br>只呈现优势的一面，劣势或不加分的一面要慎重描写</p>
<h2 id="2-4-市场规模与分析"><a href="#2-4-市场规模与分析" class="headerlink" title="2.4 市场规模与分析"></a>2.4 市场规模与分析</h2><h3 id="2-4-1-市场分析"><a href="#2-4-1-市场分析" class="headerlink" title="2.4.1 市场分析"></a>2.4.1 市场分析</h3><p><strong>数据采集</strong><br>要有明确、清晰的数据来源<br>在此数据来源之上，筛选出对项目有利的信息</p>
<ul>
<li>真实的数据，但是是部分的真实</li>
</ul>
<h3 id="2-4-2-竞品分析"><a href="#2-4-2-竞品分析" class="headerlink" title="2.4.2 竞品分析"></a>2.4.2 竞品分析</h3><p><strong>竞品确定</strong><br>竞品不一定得是完全相同的行业，重点是商业的逻辑；<br>确定一个牛逼的竞品，即展示当前项目天花板很高，然后再分析当前项目所处市场以及再哪些地方超越了竞品。</p>
<h2 id="2-5-商业模式"><a href="#2-5-商业模式" class="headerlink" title="2.5 商业模式"></a>2.5 商业模式</h2><p><strong>什么是商业模式</strong></p>
<ol>
<li>项目如何盈利？</li>
<li>项目的流量模式？</li>
<li>获客转化的路径？</li>
<li>是否具有可持续性？</li>
<li>增长的空间以及可能？</li>
</ol>
<p><strong>内容编写</strong><br>基于业务本身的内容，对模式进行介绍；</p>
<h2 id="2-6-战略规划"><a href="#2-6-战略规划" class="headerlink" title="2.6 战略规划"></a>2.6 战略规划</h2><p><strong>内容</strong></p>
<ol>
<li>确定战略目标，展现当前项目的发展前景</li>
<li>确定项目发展的实现路径，并且确定不同情况下的风险预案</li>
</ol>
]]></content>
      <categories>
        <category>商业</category>
      </categories>
      <tags>
        <tag>商业</tag>
        <tag>创业</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 10：状态机模型的应用</title>
    <url>/2023/08/f8b821c31d0a.html</url>
    <content><![CDATA[<ul>
<li>状态机的确定性<ul>
<li>概念<ul>
<li>每一个状态都有一个确定的下一个状态</li>
<li>不确定的状态机，状态之后会有不同的分支状态</li>
</ul>
</li>
<li>宏观物理世界<ul>
<li>近似于决定性的状态机，状态之间用于牛顿机械式的逻辑关系</li>
<li>例子：Game Of Life</li>
</ul>
</li>
<li>微观物理世界<span id="more"></span></li>
</ul>
</li>
</ul>
<h2 id="10-1-状态机模型的物理世界应用"><a href="#10-1-状态机模型的物理世界应用" class="headerlink" title="10.1 状态机模型的物理世界应用"></a>10.1 状态机模型的物理世界应用</h2><h3 id="10-1-1-世界状态的确定性分析"><a href="#10-1-1-世界状态的确定性分析" class="headerlink" title="10.1.1 世界状态的确定性分析"></a>10.1.1 世界状态的确定性分析</h3><ul>
<li>状态机的确定性<ul>
<li>概念<ul>
<li>每一个状态都有一个确定的下一个状态</li>
<li>不确定的状态机，状态之后会有不同的分支状态</li>
</ul>
</li>
<li>宏观物理世界<ul>
<li>近似于决定性的状态机，状态之间用于牛顿机械式的逻辑关系</li>
<li>例子：Game Of Life</li>
</ul>
</li>
<li>微观物理世界</li>
</ul>
</li>
</ul>
<h3 id="10-1-2-状态机模型的应用"><a href="#10-1-2-状态机模型的应用" class="headerlink" title="10.1.2 状态机模型的应用"></a>10.1.2 状态机模型的应用</h3><p>这里不知道为什么会出现问题。。。</p>
<h2 id="在决定性的数学公理体系下，状态机模型的使用1-数学严谨的体系下，解释平行宇宙2-细胞的状态分析与还原"><a href="#在决定性的数学公理体系下，状态机模型的使用1-数学严谨的体系下，解释平行宇宙2-细胞的状态分析与还原" class="headerlink" title="在决定性的数学公理体系下，状态机模型的使用1. 数学严谨的体系下，解释平行宇宙2. 细胞的状态分析与还原"></a>在决定性的数学公理体系下，状态机模型的使用<br>1. 数学严谨的体系下，解释平行宇宙<br>2. 细胞的状态分析与还原</h2><h2 id="10-2-状态机模型下的编译器和现代CPU"><a href="#10-2-状态机模型下的编译器和现代CPU" class="headerlink" title="10.2 状态机模型下的编译器和现代CPU"></a>10.2 状态机模型下的编译器和现代CPU</h2><h3 id="10-2-1-编译器模型"><a href="#10-2-1-编译器模型" class="headerlink" title="10.2.1 编译器模型"></a>10.2.1 编译器模型</h3><h2 id="编译器：从源代码S（状态机）-二进制代码C（状态机）在不同的SystemCall之中，保证语义一致性（保证结果的最终一致）-10-2-2-编译器优化的正确性核心：源代码状态机和二进制状态机的可观测行为的一致性例子：现代的CPU在一个时钟周期当中可以执行两条指令甚至更多-10-2-3-查看状态机执行程序执行-状态机执行例子：通过strace观测系统调用的行为以及所花费的时间。-查看所有的状态机行为-方法：使用GDB进行调试-单步调试-反汇编调试-通过调试器展示的状态的一部分-寄存器-内存-变量状态机视角下，Debug可进行的行为：1-复制当前状态机的状态2-回溯状态机的上一个状态3-进入状态机的下一个状态4-记录一个状态机的完整执行-状态机的状态回溯-概念：-虽然当前程序的状态机的状态可能十分复杂，但是在不同指令之间进行执行时，如果只是将指令的行为记录下来，即可回走-每次状态切换时更改的内容有效-例子：-在一个用于随机情况的方法条件下，可以通过gcc的record将状态记录下来-，当想要还原这个随机性的Bug时只需要恢复当时的状态即可实现-记录状态机的完整执行-决定性程序：-如果程序是完全决定性的，只要程序的初始状态知道，之后的状态都可以据此由此复现出来-拥有系统调用、Random的程序：-待记录内容：-1-指令数-2-结果-3-n份以上内容-可使用此功能-指令：-rr-record-想记录下函数的全部行为：-需要知道从上一条指令到下一条指令有多少决定性的指-令-程序的io-程序的中断-程序可以完整的记录程序的执行-例子：老游戏的replay"><a href="#编译器：从源代码S（状态机）-二进制代码C（状态机）在不同的SystemCall之中，保证语义一致性（保证结果的最终一致）-10-2-2-编译器优化的正确性核心：源代码状态机和二进制状态机的可观测行为的一致性例子：现代的CPU在一个时钟周期当中可以执行两条指令甚至更多-10-2-3-查看状态机执行程序执行-状态机执行例子：通过strace观测系统调用的行为以及所花费的时间。-查看所有的状态机行为-方法：使用GDB进行调试-单步调试-反汇编调试-通过调试器展示的状态的一部分-寄存器-内存-变量状态机视角下，Debug可进行的行为：1-复制当前状态机的状态2-回溯状态机的上一个状态3-进入状态机的下一个状态4-记录一个状态机的完整执行-状态机的状态回溯-概念：-虽然当前程序的状态机的状态可能十分复杂，但是在不同指令之间进行执行时，如果只是将指令的行为记录下来，即可回走-每次状态切换时更改的内容有效-例子：-在一个用于随机情况的方法条件下，可以通过gcc的record将状态记录下来-，当想要还原这个随机性的Bug时只需要恢复当时的状态即可实现-记录状态机的完整执行-决定性程序：-如果程序是完全决定性的，只要程序的初始状态知道，之后的状态都可以据此由此复现出来-拥有系统调用、Random的程序：-待记录内容：-1-指令数-2-结果-3-n份以上内容-可使用此功能-指令：-rr-record-想记录下函数的全部行为：-需要知道从上一条指令到下一条指令有多少决定性的指-令-程序的io-程序的中断-程序可以完整的记录程序的执行-例子：老游戏的replay" class="headerlink" title="编译器：从源代码S（状态机）-&gt; 二进制代码C（状态机）在不同的SystemCall之中，保证语义一致性（保证结果的最终一致）### 10.2.2 编译器优化的正确性核心：源代码状态机和二进制状态机的可观测行为的一致性例子：现代的CPU在一个时钟周期当中可以执行两条指令甚至更多### 10.2.3 查看状态机执行程序执行 &#x3D; 状态机执行例子：通过strace观测系统调用的行为以及所花费的时间。+ 查看所有的状态机行为    + 方法：使用GDB进行调试        + 单步调试        + 反汇编调试    + 通过调试器展示的状态的一部分        + 寄存器        + 内存        + 变量状态机视角下，Debug可进行的行为：1. 复制当前状态机的状态2. 回溯状态机的上一个状态3. 进入状态机的下一个状态4. 记录一个状态机的完整执行+ 状态机的状态回溯    + 概念：        + 虽然当前程序的状态机的状态可能十分复杂，但是在不同指令之间进行执行时，如果只是将指令的行为记录下来，即可回走        + 每次状态切换时更改的内容有效    + 例子：        + 在一个用于随机情况的方法条件下，可以通过gcc的record将状态记录下来 ，当想要还原这个随机性的Bug时只需要恢复当时的状态即可实现+ 记录状态机的完整执行    + 决定性程序：        + 如果程序是完全决定性的，只要程序的初始状态知道，之后的状态都可以据此由此复现出来    + 拥有系统调用、Random的程序：        + 待记录内容：        + 1. 指令数        + 2. 结果        + 3. n份以上内容    + 可使用此功能        + 指令：            + rr record        + 想记录下函数的全部行为：            + 需要知道从上一条指令到下一条指令有多少决定性的指 令            + 程序的io            + 程序的中断        + 程序可以完整的记录程序的执行            + 例子：老游戏的replay"></a>编译器：从源代码S（状态机）-&gt; 二进制代码C（状态机）<br>在不同的SystemCall之中，保证语义一致性（保证结果的最终一致）<br>### 10.2.2 编译器优化的正确性<br><strong>核心：源代码状态机和二进制状态机的可观测行为的一致性</strong><br>例子：现代的CPU在一个时钟周期当中可以执行两条指令甚至更多<br>### 10.2.3 查看状态机执行<br>程序执行 &#x3D; 状态机执行<br>例子：通过strace观测系统调用的行为以及所花费的时间。<br>+ 查看所有的状态机行为<br>    + 方法：使用GDB进行调试<br>        + 单步调试<br>        + 反汇编调试<br>    + 通过调试器展示的状态的一部分<br>        + 寄存器<br>        + 内存<br>        + 变量<br>状态机视角下，Debug可进行的行为：<br>1. 复制当前状态机的状态<br>2. 回溯状态机的上一个状态<br>3. 进入状态机的下一个状态<br>4. 记录一个状态机的完整执行<br>+ 状态机的状态回溯<br>    + 概念：<br>        + 虽然当前程序的状态机的状态可能十分复杂，但是在不同指令之间进行执行时，如果只是将指令的行为记录下来，即可回走<br>        + 每次状态切换时更改的内容有效<br>    + 例子：<br>        + 在一个用于随机情况的方法条件下，可以通过gcc的record将状态记录下来 ，当想要还原这个随机性的Bug时只需要恢复当时的状态即可实现<br>+ 记录状态机的完整执行<br>    + 决定性程序：<br>        + 如果程序是完全决定性的，只要程序的初始状态知道，之后的状态都可以据此由此复现出来<br>    + 拥有系统调用、Random的程序：<br>        + 待记录内容：<br>        + 1. 指令数<br>        + 2. 结果<br>        + 3. n份以上内容<br>    + 可使用此功能<br>        + 指令：<br>            + rr record<br>        + 想记录下函数的全部行为：<br>            + 需要知道从上一条指令到下一条指令有多少决定性的指 令<br>            + 程序的io<br>            + 程序的中断<br>        + 程序可以完整的记录程序的执行<br>            + 例子：老游戏的replay</h2><h2 id="10-3-状态机与性能分析"><a href="#10-3-状态机与性能分析" class="headerlink" title="10.3 状态机与性能分析"></a>10.3 状态机与性能分析</h2><h3 id="10-3-1-采样状态机的执行"><a href="#10-3-1-采样状态机的执行" class="headerlink" title="10.3.1 采样状态机的执行"></a>10.3.1 采样状态机的执行</h3><h2 id="每当想进行性能优化的时候，总是要停下来想想，当下是否适合作性能优化。性能分析的核心原则：Premature-optimization-is-the-root-of-all-exil-问题：如何在代价很低的方法下，获得程序的summary（）？即获得性能摘要-性能优化的时机-分析程序在时间和空间上的调用-时间-空间-10-3-2-Profiler和性能摘要单点调试的问题：当使用gdb单点调试时，程序需要在每个指令下停止下来，无法测算每个指令执行的速度。此时只需要关注状态机的整体行为，观察程序在某一段时间中的关键信息（CPU、GPU、内存）数据。实现此步骤的方法是：中断-中断-概念：基于中断的机制，程序此时会进入到OS的代码。此时OS的代码可以访问到程序中断前的状态，并将此状态进行采样与输出-10-3-2-1-基于gcc进行性能摘要输出当前程序性能摘要：结果：将整个程序的Profiler记录，并打开报告：获得的每一条指令的时间：-10-3-3-实际中的性能优化百分之八十的时间都消耗在了百分之二十的代码上-工业界面到的性能优化-实际情况：木桶效应-每个部分都已经优化到了局部最优解"><a href="#每当想进行性能优化的时候，总是要停下来想想，当下是否适合作性能优化。性能分析的核心原则：Premature-optimization-is-the-root-of-all-exil-问题：如何在代价很低的方法下，获得程序的summary（）？即获得性能摘要-性能优化的时机-分析程序在时间和空间上的调用-时间-空间-10-3-2-Profiler和性能摘要单点调试的问题：当使用gdb单点调试时，程序需要在每个指令下停止下来，无法测算每个指令执行的速度。此时只需要关注状态机的整体行为，观察程序在某一段时间中的关键信息（CPU、GPU、内存）数据。实现此步骤的方法是：中断-中断-概念：基于中断的机制，程序此时会进入到OS的代码。此时OS的代码可以访问到程序中断前的状态，并将此状态进行采样与输出-10-3-2-1-基于gcc进行性能摘要输出当前程序性能摘要：结果：将整个程序的Profiler记录，并打开报告：获得的每一条指令的时间：-10-3-3-实际中的性能优化百分之八十的时间都消耗在了百分之二十的代码上-工业界面到的性能优化-实际情况：木桶效应-每个部分都已经优化到了局部最优解" class="headerlink" title="每当想进行性能优化的时候，总是要停下来想想，当下是否适合作性能优化。性能分析的核心原则：Premature optimization is the root of all exil.问题：如何在代价很低的方法下，获得程序的summary（）？即获得性能摘要+ 性能优化的时机    + 分析程序在时间和空间上的调用    + 时间    + 空间### 10.3.2 Profiler和性能摘要单点调试的问题：当使用gdb单点调试时，程序需要在每个指令下停止下来，无法测算每个指令执行的速度。此时只需要关注状态机的整体行为，观察程序在某一段时间中的关键信息（CPU、GPU、内存）数据。实现此步骤的方法是：中断+ 中断    + 概念：基于中断的机制，程序此时会进入到OS的代码。此时OS的代码可以访问到程序中断前的状态，并将此状态进行采样与输出#### 10.3.2.1 基于gcc进行性能摘要输出当前程序性能摘要：结果：将整个程序的Profiler记录，并打开报告：获得的每一条指令的时间：### 10.3.3 实际中的性能优化百分之八十的时间都消耗在了百分之二十的代码上+ 工业界面到的性能优化    + 实际情况：木桶效应    + 每个部分都已经优化到了局部最优解"></a>每当想进行性能优化的时候，总是要停下来想想，当下是否适合作性能优化。<br><em>性能分析的核心原则：Premature optimization is the root of all exil.</em><br>问题：如何在代价很低的方法下，获得程序的summary（）？即获得性能摘要<br>+ 性能优化的时机<br>    + 分析程序在时间和空间上的调用<br>    + 时间<br>    + 空间<br>### 10.3.2 Profiler和性能摘要<br><strong>单点调试的问题：</strong><br>当使用gdb单点调试时，程序需要在每个指令下停止下来，无法测算每个指令执行的速度。此时只需要关注状态机的整体行为，观察程序在某一段时间中的关键信息（CPU、GPU、内存）数据。<br>实现此步骤的方法是：中断<br>+ 中断<br>    + 概念：基于中断的机制，程序此时会进入到OS的代码。此时OS的代码可以访问到程序中断前的状态，并将此状态进行采样与输出<br>#### 10.3.2.1 基于gcc进行性能摘要<br>输出当前程序性能摘要：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">perf stat ./a.out </span><br></pre></td></tr></table></figure><br>结果：<br><img src="/../../image/Pasted%20image%2020230829191438.png"><br>将整个程序的Profiler记录，并打开报告：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">perf record ./a.out</span><br><span class="line">perf report</span><br></pre></td></tr></table></figure><br>获得的每一条指令的时间：<br><img src="/../../image/Pasted%20image%2020230829191456.png"><br>### 10.3.3 实际中的性能优化<br>百分之八十的时间都消耗在了百分之二十的代码上<br>+ 工业界面到的性能优化<br>    + 实际情况：木桶效应<br>    + 每个部分都已经优化到了局部最优解</h2><h2 id="10-4-状态机与程序验证"><a href="#10-4-状态机与程序验证" class="headerlink" title="10.4 状态机与程序验证"></a>10.4 状态机与程序验证</h2><h3 id="10-4-1-现在的Model-Check工具"><a href="#10-4-1-现在的Model-Check工具" class="headerlink" title="10.4.1 现在的Model Check工具"></a>10.4.1 现在的Model Check工具</h3><p>概念：状态机模型可以用于证明程序的正确性。使用bfs便利所有的状态，再使用execute给定一个并发程序的调度。<br>例子：for程序的并发Bug<br>**学术界的Model Check工具</p>
<ol>
<li>NASA的Java PathFinder：把Model Check扩充到了所有的Java代码</li>
<li>Spin：只可以使用其自己定义的语言</li>
<li>TLA Plus：用于亚马逊的并发式程序的正确性验证</li>
</ol>
<ul>
<li>现在的Model Check在分布式系统上的应用<ul>
<li>并发系统：<ul>
<li>分布式系统也是一种并发系统，但是其问题更大</li>
<li>并发系统假设其所有的节点都能够正常工作</li>
</ul>
</li>
<li>分布式系统<ul>
<li>在分布式系统中，必须假设所有的节点都可能出错（丢失）</li>
<li>在节点丢失的情况下还能进行tutorial</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="10-4-2-Model-Check可以做什么"><a href="#10-4-2-Model-Check可以做什么" class="headerlink" title="10.4.2 Model Check可以做什么"></a>10.4.2 Model Check可以做什么</h3><p>当探索不确定性程序的执行时，Model Check可以检查任何程序的执行；<br>Model Check可以检测当前不确定程序的任何一种可能性，并检查出Bug。</p>
<ul>
<li>不确定<ul>
<li>输入不确定</li>
<li>随机函数不确定<br>面对不确定性程序，可以检测程序的所有可能性空间<br><strong>问题：程序的状态空间太大</strong></li>
</ul>
</li>
</ul>
<ol>
<li>如何将这个状态的可能性减少？</li>
<li>如何将状态合并？</li>
<li>如何将状态往后延迟？</li>
</ol>
<ul>
<li>状态坍缩<ul>
<li>将大量可能性的状态转换为分支，延迟状态的展开，将状态合并，直到发现Bug再将其反向展开</li>
<li>分支成立：<ul>
<li>再检测有没有分支<ul>
<li>分支成立：<ul>
<li>在检测有没有分支：<ul>
<li>分支成立：<ul>
<li>当前红色的状态是否可达？</li>
<li>用约束求解器来计算</li>
<li>计算出当前程序的状态，此状态为Bug</li>
</ul>
</li>
<li>分支不成立：</li>
</ul>
</li>
</ul>
</li>
<li>分支不成立：</li>
</ul>
</li>
</ul>
</li>
<li>分支不成立：</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 12：进程的地址空间</title>
    <url>/2023/08/d03400aa93d7.html</url>
    <content><![CDATA[<p>程序就是状态机，C语言的状态机被转换成汇编语言的状态机，在汇编语言的状态机当中直接看到内存地址空间。</p>
<span id="more"></span>
<h2 id="12-1-动-静态链接程序地址空间"><a href="#12-1-动-静态链接程序地址空间" class="headerlink" title="12.1 动&#x2F;静态链接程序地址空间"></a>12.1 动&#x2F;静态链接程序地址空间</h2><p>当指针指向一个不合法的位置时会直接得到一个错误，如果往一个合法的地址无权限的写入，也会获得一个访问错误。但就指针本身而言，其可以指向任何地方。如果想要真正知道哪些地方是可读的，即当前程序的地址空间，如何实现?</p>
<h3 id="12-1-1-最小C程序的地址空间"><a href="#12-1-1-最小C程序的地址空间" class="headerlink" title="12.1.1 最小C程序的地址空间"></a>12.1.1 最小C程序的地址空间</h3><p>在gdb下获得进程的进程号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info inferiors</span><br></pre></td></tr></table></figure>

<p>查看某一个进程地址空间代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pmap 37491</span><br></pre></td></tr></table></figure>
<p>当中的37491为进程的id。</p>
<p><strong>查看结果：</strong><br><img src="/../../image/Pasted%20image%2020230829191538.png"></p>
<p><strong>可以使用strace指令来获取pmap指令的系统调用：</strong></p>
<ul>
<li>除了可以用pmap之外，还可以直接在文件系统的proc中查看进程内存映射的关键信息。</li>
<li>proc当中有进程的编号，命令行从属的父子关系，还有当前进程内存映射的关键信息</li>
</ul>
<p>**相关手册：<code>mam 5 proc</code></p>
<h4 id="12-1-1-1-将strace信息以Vim打开"><a href="#12-1-1-1-将strace信息以Vim打开" class="headerlink" title="12.1.1.1 将strace信息以Vim打开"></a>12.1.1.1 将strace信息以Vim打开</h4><p>代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace ./a.out &amp;| vim -A</span><br></pre></td></tr></table></figure>

<h3 id="12-1-2-静态链接程序的地址空间"><a href="#12-1-2-静态链接程序的地址空间" class="headerlink" title="12.1.2 静态链接程序的地址空间"></a>12.1.2 静态链接程序的地址空间</h3><p>以下是在proc当中读取的地址空间信息：<br><img src="/../../image/Pasted%20image%2020230829191738.png"><br>信息相比于前面最小的C程序要更多；<br>第一行：ELF文件头<br>第二行：因为有x表示可执行，所以为可执行代码<br>第三行：因为为只可读的数据，所以应该为字符串常量<br>第五行：可读可写，堆区</p>
<h3 id="12-1-3-动态链接程序的地址空间"><a href="#12-1-3-动态链接程序的地址空间" class="headerlink" title="12.1.3 动态链接程序的地址空间"></a>12.1.3 动态链接程序的地址空间</h3><p><strong>变化：</strong><br>相比于静态链接，动态链接程序的地址空间明显变得更复杂。并且其进程空间开始的地址相比于之前发生了较大的变化，因为OS进程地址随机化的机制，每一次动态链接程序的执行，其首地址空间位置都可能发生变化。<br>除此之外，还多了更多的映射区域。<br>以及一些没有文件的（但是可读可写）内存？是不是未初始化数据？如果在C程序当中分配一大段数组内存，此段空间将会承载此内容。<br><strong>通过改变程序的行为，观察程序的地址空间并且验证自己的假设。</strong></p>
<hr>
<h2 id="12-2-进程的地址空间管理"><a href="#12-2-进程的地址空间管理" class="headerlink" title="12.2 进程的地址空间管理"></a>12.2 进程的地址空间管理</h2><h3 id="12-2-1-VDSO、系统调用与非陷入式调用"><a href="#12-2-1-VDSO、系统调用与非陷入式调用" class="headerlink" title="12.2.1 VDSO、系统调用与非陷入式调用"></a>12.2.1 VDSO、系统调用与非陷入式调用</h3><p>操作系统上的程序是状态机，在程序当中有一类特殊的程序为SYSCALL系统调用，此指令会进入到操作系统内核执行，此时SYSCALL会因为转台的切换，带来更大的开销。<br>如何实现不进入OS内核的系统调用？</p>
<p>进程与时钟：<br>OS当中的进程是不知道时钟的，时钟本身是由OS维护的，这个时间原则上只有OS知道</p>
<p>程序中的time函数：<br>time函数没有进入libc，而是停在了vdso，把当前的地址相减寻址，得到一个不可访问的其他进程的地址。在执行了time函数之后，获得了一个极大的数值。<br>time函数可以在不进入操作系统内核的前提下，完成一个系统调用。因为在一片地址空间中，OS单独设置一块vvar，使得不进入OS的系统调用可以实现。因为这部分已经由OS提供了。</p>
<h3 id="12-2-2-系统调用的实现"><a href="#12-2-2-系统调用的实现" class="headerlink" title="12.2.2 系统调用的实现"></a>12.2.2 系统调用的实现</h3><p>一般教科书任何，需要通过中断来实现系统调用。但SYSCALL不需要int指令，就可以实现地址调用，甚至有更多</p>
<h3 id="12-2-3-mmap"><a href="#12-2-3-mmap" class="headerlink" title="12.2.3 mmap()"></a>12.2.3 mmap()</h3><p>操作系统需要提供一个机制来帮助我们管理地址空间;<br>OS需要提供相关指令，使得在程序执行的时候，在当前OS当中已有的内存当中找到一片新的内存，为其改变程序的地址空间，分配一片新的空间;<br>这个指令就是mmap；</p>
<p><strong>概念：</strong><br>mmap可以帮助程序在其状态当中，映射新的地址空间或者把已有的地址空间分配出去。在一个地址（addr）上面，映射一片长度为length的空间，向其传递访问的权限（prot），地址映射的方式（flags）。</p>
<p><strong>定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="type">int</span> fd,<span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>mmap与程序加载器</strong><br>由于在Linux的设计哲学当中，一切都是文件，因此mmap当中有一个fd，有一个offset，就可以直接把一个非常大的文件直接映射到地址空间当中，然后再后背访问多少再进行加载多少。</p>
<h3 id="12-2-4-程序基于mmap的加载行为"><a href="#12-2-4-程序基于mmap的加载行为" class="headerlink" title="12.2.4 程序基于mmap的加载行为"></a>12.2.4 程序基于mmap的加载行为</h3><p>当程序想要加载某些文件，比如libc库时，此时只需要读取程序的ELF头文件（当中包含了这些文件的地址，要加载到什么位置），得到需要映射的文件信息，然后使用mmap将这些信息映射到当前程序的地址空间，即可完成加载。</p>
<h3 id="12-2-5-应用：使用mmap申请大内存"><a href="#12-2-5-应用：使用mmap申请大内存" class="headerlink" title="12.2.5 应用：使用mmap申请大内存"></a>12.2.5 应用：使用mmap申请大内存</h3><p>在申请太多内存的时候，OS会直接拒绝此行为。<br>代码：<br><img src="/../../image/Pasted%20image%2020230829191917.png"></p>
<p><strong>代码解析：</strong><br>申请了3GB大小的内存，fd描述为1，读写它，一瞬间就完成。<br>使用strace观察行为可以知道，其只是使用mmap标记上了这段内存，在实际使用到的时候再进行加载。</p>
<h2 id="12-3-地址空间的隔离"><a href="#12-3-地址空间的隔离" class="headerlink" title="12.3 地址空间的隔离"></a>12.3 地址空间的隔离</h2><p>每一个指针只能访问当前进程的地址空间，mmap就是在当前程序的地址空间扩充一块，即mmap帮助了地址空间隔离的机制。</p>
<h3 id="12-3-1-老游戏修改器实现"><a href="#12-3-1-老游戏修改器实现" class="headerlink" title="12.3.1 老游戏修改器实现"></a>12.3.1 老游戏修改器实现</h3><p>命令与政府修改器实现的大致逻辑：</p>
<ul>
<li>第一步：获得游戏进程的PID（进程号）</li>
<li>第二步：由于Linux下的proc机制，其将程序的整个地址空间作为文件全部暴露出来了。可以将其作为文件使用<code>popen()</code>打开再扫过每一段内存。</li>
<li>第三步：使用解析代码<code>fscanf()</code>，找到每一段可读的内存</li>
<li>第四步：遍历此段内存，找到关键词数据</li>
<li>第五步：修改被关键字标记的内存</li>
</ul>
<h3 id="12-3-2-按键精灵-变速齿轮"><a href="#12-3-2-按键精灵-变速齿轮" class="headerlink" title="12.3.2 按键精灵&amp;变速齿轮"></a>12.3.2 按键精灵&amp;变速齿轮</h3><p>制作假的驱动，利用操作系统API模拟按下。<br>把游戏放在虚拟机上执行，可以任意调整时钟周期。</p>
<h3 id="12-3-3-代码注入"><a href="#12-3-3-代码注入" class="headerlink" title="12.3.3 代码注入"></a>12.3.3 代码注入</h3><p>在OS下，既可以改内存，也可以改代码。</p>
<h4 id="12-3-3-1-代码热更新原理"><a href="#12-3-3-1-代码热更新原理" class="headerlink" title="12.3.3.1 代码热更新原理"></a>12.3.3.1 代码热更新原理</h4><p>当程序当中有以下代码的时候，两次函数会输出一样的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is old function&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo_new</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is new function&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	foo();</span><br><span class="line">	foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果代码执行热更新后，可以在运行时动态更改当前函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DSU</span><span class="params">(<span class="type">void</span>* old , <span class="type">void</span>* new)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ROUNDDOWN(ptr) ((void*)(((uintptr_t)ptr) &amp;~0xfff))</span></span><br><span class="line">	<span class="type">size_t</span> pg_size = ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>![[Pasted image 20230227204316.png]]<br>在原本的代码区中，将部分需要更新的代码更改为其他代码。<br>获得原本的代码地址，使用mprotect()函数将这片地址只读属性改成读写属性，然后再把新的地址（新函数的地址）给填写进去。</p>
<h4 id="12-3-3-2-基于人工智能的游戏外挂"><a href="#12-3-3-2-基于人工智能的游戏外挂" class="headerlink" title="12.3.3.2 基于人工智能的游戏外挂"></a>12.3.3.2 基于人工智能的游戏外挂</h4><p>使用深度学习算法，分析画面当中出现的特征画面，然后再抓取游戏引擎向底层OpenGL发出的渲染指令，分析其指令和画面的特征关系，从而抓取到其对应的代码，然后对其进行代码注入。</p>
<h3 id="12-3-4-地址空间Hack的攻与防"><a href="#12-3-4-地址空间Hack的攻与防" class="headerlink" title="12.3.4 地址空间Hack的攻与防"></a>12.3.4 地址空间Hack的攻与防</h3><p>概念一：保证控制&#x2F;数据 流的完整性；对独立的进程以及驱动进行完整性检验，保证部分区域的数据无法被读取，当用户尝试读取这部分数据时直接将其拉人黑名单。<br>概念二：AI监控；使用深度学习对用户数据信息进行建模，当发现某些玩家的数据分布和其他玩家的数据分配产生较大不同时，再来逐帧分析其运行<br>概念三：沙盒渲染；在计算机当中创建一片无法被读取的沙盒，将部分关键的运算放入沙盒当中进行计算，只有在计算结束之后才会返回数据；“计算不再信任操作系统”</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>操作系统</tag>
        <tag>Fork</tag>
        <tag>Mmap</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 11：操作系统上的进程</title>
    <url>/2023/08/5b1cbd3ab6e9.html</url>
    <content><![CDATA[<blockquote>
<pre><code>1. 操作系统启动后做了什么？
2. 操作系统如何管理进程？
</code></pre>
</blockquote>
<span id="more"></span>
<h2 id="11-1-进程与Linux"><a href="#11-1-进程与Linux" class="headerlink" title="11.1 进程与Linux"></a>11.1 进程与Linux</h2><h3 id="11-1-1-操作系统的第一个进程"><a href="#11-1-1-操作系统的第一个进程" class="headerlink" title="11.1.1 操作系统的第一个进程"></a>11.1.1 操作系统的第一个进程</h3><p>操作系统的第一条程序执行之后，接下来的行为就是创建其他的程序，然后就把操作系统的全部控制权交给程序，即操作系统树根上的程序。<br>操作系统只是创建第一个树根进程，然后其他进程由此树根进程创建。</p>
<p><strong>Linux进入之后加载第一个程序的代码：</strong><br><img src="/../../image/Pasted%20image%2020230829191238.png"></p>
<h4 id="11-1-1-1-gcc观看进程结构"><a href="#11-1-1-1-gcc观看进程结构" class="headerlink" title="11.1.1.1 gcc观看进程结构"></a>11.1.1.1 gcc观看进程结构</h4><p>以下shell指令执行后，将会输出当前OS的所有进程，而这些所有进程都是由根进程所创建：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pstree</span><br><span class="line">systemd ---..其他进程</span><br></pre></td></tr></table></figure>
<p><img src="/../../image/Pasted%20image%2020230829191308.png"></p>
<h3 id="11-1-2-最小Linux实现Linux-运行："><a href="#11-1-2-最小Linux实现Linux-运行：" class="headerlink" title="11.1.2 最小Linux实现Linux 运行："></a>11.1.2 最小Linux实现Linux 运行：</h3><ol>
<li>无图形界面</li>
<li>128m内存</li>
<li>linux内核</li>
<li>将initramfs<br>使用<code>make run</code>启动程序后，当前OS内核当中只有一个init在执行，此进程不可返回，不然OS就会发生Crash</li>
</ol>
<h4 id="11-1-2-1-OS内核链接至BusyBox"><a href="#11-1-2-1-OS内核链接至BusyBox" class="headerlink" title="11.1.2.1 OS内核链接至BusyBox"></a>11.1.2.1 OS内核链接至BusyBox</h4><p>将busybox链接至OS的<code>/bin/</code>目录下，生成的链接文件的名称为ps、arch、pst等这些Linux常见命令的名称，此时在OS中就可以直接使用这些程序。<br>只要当前程序是静态链接的，就可以被链接到OS当中</p>
<h3 id="11-1-3-略复杂一些的OS实现"><a href="#11-1-3-略复杂一些的OS实现" class="headerlink" title="11.1.3 略复杂一些的OS实现"></a>11.1.3 略复杂一些的OS实现</h3><p>内容：</p>
<ol>
<li>当中有更多挂载的磁盘</li>
<li>执行switch root系统调用，将initramfs销毁<br>把初始的文件系统销毁，然后创建一个新的文件系统</li>
</ol>
<p><strong>系统调用的三大类型</strong></p>
<ol>
<li>进程管理</li>
<li>文件管理</li>
<li>内存管理<br>有这三类系统调用，就可以实现整个OS世界</li>
</ol>
<hr>
<h2 id="11-2-进程与fork"><a href="#11-2-进程与fork" class="headerlink" title="11.2 进程与fork()"></a>11.2 进程与fork()</h2><p>OS必须要有一个创建进程的API，在Init加载了第一个进程后，使用fork()创建其他的进程</p>
<h3 id="11-2-1-什么是fork"><a href="#11-2-1-什么是fork" class="headerlink" title="11.2.1 什么是fork()"></a>11.2.1 什么是fork()</h3><p>当前进程有一个执行流，当执行到了fork()之后当前程序的执行流变成两条，完成分叉<br><strong>如何理解？</strong><br>操作系统在加载之后就创建了init这个状态机。当init执行了fork()后，执行流就会陷入到内核当中执行OS代码，fork会把当前进程状态机的状态完整复制一份，然后创建一个新的执行流</p>
<ul>
<li>完全一致的进程<ul>
<li>两个进程在内存上一模一样，寄存器一样</li>
<li>只有返回的值不一样：<ul>
<li>每一个进程都有一个唯一的编号</li>
<li>除了编号之外一切相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>当操作系统新创建了进程之后，就变成了一个并发程序。OS每一次可以选择一个进程执行一次（如果每一个时刻CPU只能执行一个）</p>
<h3 id="11-2-2-Fork-Bomb"><a href="#11-2-2-Fork-Bomb" class="headerlink" title="11.2.2 Fork Bomb"></a>11.2.2 Fork Bomb</h3><p>可以创建一个无限创建进程的程序，一开始的fork变成两个fork，每个创建的fork又可以创建fork，无休止创建下去。</p>
<h3 id="11-2-3-Fork行为分析"><a href="#11-2-3-Fork行为分析" class="headerlink" title="11.2.3 Fork行为分析"></a>11.2.3 Fork行为分析</h3><p>对于Fork创建进程的行为进行分析<br><strong>代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">2</span> ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fork();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i&lt;n ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行行为：</strong><br>第一次i &#x3D; 0时，进入for然后执行一次fork()，此时进程会进行分叉变成两个进程，两个进程拥有完全一致的状态，因此都会进入printf然后输出。<br>第二次i&#x3D;1时，当前已经有了两个fork，而这两个fork都会各自进行复制，因此会有四个进程取执行printf()然后输出Hello</p>
<p><strong>Printf行为分析：</strong><br>第一点：fork就只是一个无情的拷贝状态的机器<br>第二点：因为fork只是一个无情的状态拷贝机器，因此其会把库函数内部的状态也给其复制一份。<br>将Printf直接打印到屏幕上面：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>
<p>如果不适用fflush，库函数会先将其放在buffer当中。</p>
<ul>
<li>line buffer<ul>
<li>直接把每一行buffer输出出来</li>
</ul>
</li>
<li>full buffer<ul>
<li>只有满足buffer大小要求后才输出出来，不然就先给到buffer</li>
</ul>
</li>
</ul>
<p>fork的问题：多个线程下，fork的行为问题</p>
<h2 id="11-3-进程与execve"><a href="#11-3-进程与execve" class="headerlink" title="11.3 进程与execve()"></a>11.3 进程与execve()</h2><h3 id="11-3-1-execve行为"><a href="#11-3-1-execve行为" class="headerlink" title="11.3.1 execve行为"></a>11.3.1 execve行为</h3><p>fork创建了新的进程之后，可以检查其pid是否等于0，如果不为0则执行，进入背景现成，如果为0则为父进程，此时执行execve()，接着就会重置状态机，将当前运行的状态机重置为另一个程序的初始状态。<br>定义：execute the program referred to by pathname.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">exceve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span>* cons envp[])</span>;</span><br></pre></td></tr></table></figure>
<p>使用代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* <span class="type">const</span> argv[] = </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;env&quot;</span>,<span class="literal">NULL</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* <span class="type">const</span> envp[] = </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;HELLO=WORLD&quot;</span>,<span class="literal">NULL</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	execve(argv[<span class="number">0</span>],argv,envp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello,World\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-3-2-环境变量"><a href="#11-3-2-环境变量" class="headerlink" title="11.3.2 环境变量"></a>11.3.2 环境变量</h3><p>环境变量就是应用程序执行的环境，当状态机重置时，其他状态不变，当前状态机的状态被更改。<br>所有程序执行的第一行总是execvve，新的状态的启动总是要被重置，即使用execve</p>
<ul>
<li>环境变量<ul>
<li>PATH<ul>
<li>程序执行路径的环境变量</li>
</ul>
</li>
<li>PWD<ul>
<li>当前路径</li>
</ul>
</li>
<li>HOME<ul>
<li>HOME目录</li>
</ul>
</li>
<li>DISPLAY<ul>
<li>图形输出</li>
</ul>
</li>
<li>PS1<ul>
<li>shell提示符</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>LINUX也只不过是在这些环境变量当中找到 内容，然后执行</p>
<p><strong>PATH环境变量</strong><br>PATH就是可执行文件的搜索路径。当执行gcc之后，此时gcc的系统调用就是寻找其当前程序有可能的可执行文件的目录，搜索顺序就是PATH中指定的顺序。</p>
<hr>
<h2 id="11-4-进程与exit"><a href="#11-4-进程与exit" class="headerlink" title="11.4 进程与exit()"></a>11.4 进程与exit()</h2><p>进程需要进行销毁，当前状态机世界当中所有的状态都不变，除了当前执行exit()的进程直接从OS当中消失</p>
<ul>
<li>问题<ul>
<li>多线程的程序，exit的行为如何？</li>
<li>是所有线程结束还是只结束调用的线程？</li>
</ul>
</li>
<li>多种exit<ul>
<li>stdlib当中的exit</li>
<li>glibc当中的_exit(0)</li>
<li>syscall(SES_exit,0)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 13：系统调用与Shell</title>
    <url>/2023/08/3dbfbd52ee49.html</url>
    <content><![CDATA[<h2 id="我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell-前言：作为操作系统的用户，“我们”到底是怎么使用操作系统的？"><a href="#我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell-前言：作为操作系统的用户，“我们”到底是怎么使用操作系统的？" class="headerlink" title="我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell&gt; 前言：作为操作系统的用户，“我们”到底是怎么使用操作系统的？"></a>我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。<br>在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell<br><span id="more"></span><br>&gt; 前言：作为操作系统的用户，“我们”到底是怎么使用操作系统的？</h2><h2 id="13-1-Shell简介"><a href="#13-1-Shell简介" class="headerlink" title="13.1 Shell简介"></a>13.1 Shell简介</h2><h3 id="13-1-1-用户角度的Shell"><a href="#13-1-1-用户角度的Shell" class="headerlink" title="13.1.1 用户角度的Shell"></a>13.1.1 用户角度的Shell</h3><p>我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。<br>在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell</p>
<h3 id="13-1-2-早期的Shell"><a href="#13-1-2-早期的Shell" class="headerlink" title="13.1.2 早期的Shell"></a>13.1.2 早期的Shell</h3><p><strong>概念：</strong><br>早期的OS没有复杂结构，系统调用就像是库函数，那个时代的Shell就是命令行终端机。<br>核心：<strong>Shell就是一门把用户指令翻译为系统调用的编程语言</strong></p>
<p>手册：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man sh</span><br></pre></td></tr></table></figure>
<p>这是一个非常简单的手册，包含很多shell的内容，建立对UNIX Shell的基础认识。</p>
<h2 id="13-2-复刻简易UNIX"><a href="#13-2-复刻简易UNIX" class="headerlink" title="13.2 复刻简易UNIX"></a>13.2 复刻简易UNIX</h2><h3 id="13-2-1-简易UNIX代码初设置"><a href="#13-2-1-简易UNIX代码初设置" class="headerlink" title="13.2.1 简易UNIX代码初设置"></a>13.2.1 简易UNIX代码初设置</h3><p>早期的计算机设计由于性能低下，设计不能太消耗性能以及复杂<br>代码：<a href="http://jyywiki.cn/pages/OS/2022/demos/sh-xv6.c">http://jyywiki.cn/pages/OS/2022/demos/sh-xv6.c</a><br>零库函数依赖、可以作为最小可用的Linux的init程序<br>由于其链接任何库函数，因此可以ffreestanding</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -ffreestanding sh-xv6.c -g -O2</span><br><span class="line">ld sh-xv6.o -o sh</span><br></pre></td></tr></table></figure>
<p>第一行是将其编译，然后第二行将其静态链接<br>当使用反汇编模式进行调试时，直接从_Start()，用C写的这个函数处开始执行。此程序可以直接以命令行的形式进行运行。<br>![[Pasted image 20230827140800.png]]</p>
<h3 id="12-2-2-第一步：读取命令"><a href="#12-2-2-第一步：读取命令" class="headerlink" title="12.2.2 第一步：读取命令"></a>12.2.2 第一步：读取命令</h3><p>代码：<br>解析：不停的getcmd()来获得用户的输入，这其中直接使用read的系统调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> nread = <span class="built_in">syscall</span>(SYS_read,<span class="number">0</span>,buf,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>一直读到换行符才停止：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(*(buf++)==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>将命令读取到buf缓冲区里</p>
<h3 id="12-2-3-第二步：可能性-解释执行命令"><a href="#12-2-3-第二步：可能性-解释执行命令" class="headerlink" title="12.2.3 第二步：可能性|解释执行命令"></a>12.2.3 第二步：可能性|解释执行命令</h3><p>代码：<br>![[Pasted image 20230301181806.png]]<br>解析：<br>首先判断是不是一条’cd’命令，并且其当中不能有空格<br>使用系统调用，读取buf+3之后的数据</p>
<h3 id="12-2-4-第二步：可能性-新进程创建"><a href="#12-2-4-第二步：可能性-新进程创建" class="headerlink" title="12.2.4 第二步：可能性|新进程创建"></a>12.2.4 第二步：可能性|新进程创建</h3><p>解析：可能性|如果不是cd命令，此时创建一个新的进程，在新的进程里面把进程解析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">syscall</span>(SYS_fork) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">runcmd</span>(<span class="built_in">parsecmd</span>(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-5-第三步：程序解释器"><a href="#12-2-5-第三步：程序解释器" class="headerlink" title="12.2.5 第三步：程序解释器"></a>12.2.5 第三步：程序解释器</h3><p>其行为就和表达式求值一模一样。<br>求值表达式：<br>eval评估根节点，然后递归的评估子节点，等到两边的值都返回之后得到最后的解。Shell的每一个语句都有其语义。<br>命令解释：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">( echo a ; echo b) | wc -l</span><br></pre></td></tr></table></figure>

<p>每执行一个命令，其实就是使用execve()创建一个新的进程，函数的参数就是传入的命令。首先递归的执行左边的部分，然后再递归的执行右边的部分。</p>
<ul>
<li>命令与管道<ul>
<li>管道和命令关系<ul>
<li>管道的左边和右边都可以任意复杂：   </li>
<li>可以是一个很长的式子：<code>(echo a;each b;echo c;echo d)|wc -l</code></li>
<li>把管道左边的输出作为右边的输入，这就是管道的形式语义。</li>
</ul>
</li>
<li>管道解析<ul>
<li>pipe()创建一个管道，管道返回两个描述符：</li>
<li>pipe[0]是读口，pipe[1]是写口</li>
<li>之后会使用fork创建两个新的进程，这两个新的进程完全复制的父进程的状态，因此此时这三个进程完全共享管道，并且共进共出。</li>
<li>之后将p[0]的文件描述符关闭，后背又将p[1]的文件描述符关掉</li>
<li>之后再进行Fork，子进程编号为1的进程指向管道的左边，Fork出来的子进程再进行上述出现的行为</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="12-2-5-1-将strace中信息保存至文件"><a href="#12-2-5-1-将strace中信息保存至文件" class="headerlink" title="12.2.5.1 将strace中信息保存至文件"></a>12.2.5.1 将strace中信息保存至文件</h4><p>对sh进行使用，然后保存其strace获得的系统调用信息，将其保存至文件当中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace -f -o /tmp/strace.log ./sh</span><br></pre></td></tr></table></figure>
<p>打开strace.log文件之后，即可看到系统调用存储成文件后的内容：<br>首先读取指令，使用fork创建进程：<br>![[Pasted image 20230303170109.png]]<br>然后主进程打印内容，退出子进程：</p>
<h2 id="13-3-UNIX-Shell"><a href="#13-3-UNIX-Shell" class="headerlink" title="13.3 UNIX Shell"></a>13.3 UNIX Shell</h2><p>UNIX Shell就是编程语言，写命令行就是编程</p>
<p><strong>Shell与Job Control</strong><br>即使是1990年代的Shell，也可以实现现在的操作系统的Job控制功能，只不过是使用的命令行，而非图形化界面</p>
<h3 id="13-3-1-Shell作为OS封装的API"><a href="#13-3-1-Shell作为OS封装的API" class="headerlink" title="13.3.1 Shell作为OS封装的API"></a>13.3.1 Shell作为OS封装的API</h3><p>我们需要一个用户能够直接操作的程序，管理操作系统对象，Shell就是操作系统的外壳，帮助人类和OS进行交互</p>
<p><strong>1970年代的Shell</strong><br>1970年代的命令，在“自然语言”和“机器语言”以及计算机的算力之间达到平衡。<br>但其也有缺点，比如命令之间的优先级，以及不同的Shell对编程语言的解读是不一样的</p>
<p><strong>空格带来的麻烦</strong><br>文本数据当中，对于空格的不同理解以及行为导致的程序后果<br>PowerShell：使用对象流管道解决</p>
<h3 id="13-3-2-现代Shell展望"><a href="#13-3-2-现代Shell展望" class="headerlink" title="13.3.2 现代Shell展望"></a>13.3.2 现代Shell展望</h3><p>现代的Shell功能不变，都是人和机器之间的API，但是其形式可以发生变化</p>
<ul>
<li>界面自带StackOverflow？</li>
<li>结合神经网络？</li>
<li>智能补全？</li>
<li>POPL20</li>
</ul>
<h2 id="13-4-终端与任务控制"><a href="#13-4-终端与任务控制" class="headerlink" title="13.4 终端与任务控制"></a>13.4 终端与任务控制</h2><h3 id="13-4-1-终端机制"><a href="#13-4-1-终端机制" class="headerlink" title="13.4.1 终端机制"></a>13.4.1 终端机制</h3><p>问题：为什么有时候使用Ctrl + C可以退出程序，有时候不可以？为什么有些进程可以退出，当管道创建了很多个进程时，使用Ctrl + C 将退出哪个进程？如果时Fork了一个Shell，那使用Ctrl + C 是不是要退出Shell？tmux是怎么实现的？</p>
<p><strong>解决方案：终端</strong><br>Shell连接了人和程序，而人和机器之间交互的设备就是输入和输出设备，这个设备就是终端<br>终端是UNIX当中一类特别的设备，其也作为文件来存在，可以在文件系统中新建多个终端，同时以多个窗口来访问</p>
<p><strong>tmux原理</strong><br>可以使用strace来读取tmux的行为，将其信息保存在文件系统中；<br>不管当前是哪一个窗口，tmux都会把当前的输入捕捉下来，然后相应的将按键的信息转发给不同的终端</p>
<h3 id="13-4-2-信号机制"><a href="#13-4-2-信号机制" class="headerlink" title="13.4.2 信号机制"></a>13.4.2 信号机制</h3><p>信号是终端产生的（比如Ctrl + C是一个信号），给前台进程发一个信号，收到信号之后会有对于的信号处理程序</p>
<p><strong>信号处理程序：</strong><br><img src="/../../image/Pasted%20image%2020230829192041.png"><br>Ctrl + C 给所有的前台的进程发信号，UNIX世界当中，登陆了Shell当中会先打开Session，然后进入进程组，这些进程组可以放在前台或者后台。前台组无论什么进程，创建进程后都是前台复制过来的，属于前台进程。此时按下Ctrl + C就会对前台的所有进程发送信号</p>
<h4 id="13-4-2-1-Job-Control机制"><a href="#13-4-2-1-Job-Control机制" class="headerlink" title="13.4.2.1 Job Control机制"></a>13.4.2.1 Job Control机制</h4><p>手册：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man setpgid</span><br></pre></td></tr></table></figure>
<p>手册当中告诉，每个session就是一个单独的控制终端，在任何时候，只有一个进程组是前台的进程组，Ctrl + C会给前台的所有进程发送信号。如果有好几个进程组都是前台进程，则此时往前台发送数据可能会产生数据竞争。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 15：Fork的应用</title>
    <url>/2023/08/3d8a9bfbeeea.html</url>
    <content><![CDATA[<p>Fork：操作系统就是一个大的状态机，OS在一般的情况下，使用Syscall执行Fork时会复制一个新的状态。而此状态由于是对于原本被Fork对象的复制，因此会和原本状态完全一致，因此如果原线程上在本地打开了一个文件描述符，那新的线程也会打开它，即指向了同一个OS中的对象</p>
<span id="more"></span>
<blockquote>
<p>前言：从这节课开始，会逐渐进入到如何实现OS相关的内容，即往OS的内核来走</p>
</blockquote>
<h2 id="15-1-fork-行为的补充解释"><a href="#15-1-fork-行为的补充解释" class="headerlink" title="15.1 fork()行为的补充解释"></a>15.1 fork()行为的补充解释</h2><h3 id="15-1-1-操作系统的状态机"><a href="#15-1-1-操作系统的状态机" class="headerlink" title="15.1.1  操作系统的状态机"></a>15.1.1  操作系统的状态机</h3><p><strong>概念复习</strong><br>Fork：操作系统就是一个大的状态机，OS在一般的情况下，使用Syscall执行Fork时会复制一个新的状态。而此状态由于是对于原本被Fork对象的复制，因此会和原本状态完全一致，因此如果原线程上在本地打开了一个文件描述符，那新的线程也会打开它，即指向了同一个OS中的对象（行为类似于指针共享）<br>Execve：进程执行了Execve，状态机就会被重置，但是在重置之后，OS当中的对象还在，因此即使状态被重置，这个指向依然存在，比如其打开的文件描述符依然存在。</p>
<h3 id="15-1-2-文件描述符"><a href="#15-1-2-文件描述符" class="headerlink" title="15.1.2 文件描述符"></a>15.1.2 文件描述符</h3><p><strong>概念</strong><br><strong>文件描述符就是一个指向操作系统内对象的指针</strong>，只能通过OS运行的方式去访问这些对象。但是对于一个文本对象，write一个对象的时候，应该是具有一个文件内的偏移量，进而可以使得两个write写入的内容不是被覆盖，而是都可以被写入。</p>
<p>文件描述符可以通过Open来得到，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open(<span class="string">&quot;a.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>此时会获得一个文件描述符，并且指向这个 a.txt 对象<br>在使用Open打开文件描述符时，可以使用一个O_APPEND的方式写入。不管文件的数量多少，都会以file offset的方式在文件的末尾进行追加。</p>
<p><strong>文件描述符的复制</strong><br>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;a.txt&quot;</span>,O_WROLY | O_CREAT);<span class="comment">//用creat打开，如果不存在就被创造</span></span><br><span class="line">assert(fd &gt; <span class="number">0</span>);</span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line">assert(pid&gt;<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	write(fd,<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	write(fd,<span class="string">&quot;World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>问题一：文件偏移量的管理<br>以上代码的结果，是Hello被World覆盖掉，还是两者都被输出？即当两个相同状态的进程进行write时，其两者用于相同的文件描述符的前提下，两者是共享偏移量还是其他行为？ </p>
</li>
<li><p>问题二：dup复制文件描述符<br><strong>什么是dup</strong><br>假设原本存在一个fd为3的文件描述符，指向了OS中的一个对象。当使用了dup之后，此时会再出现一个文件描述符，其fd为4，同样也指向了此OS中的一个对象。<br>但是如果带有文件偏移量，那此时究竟应该是共享offset，还是独立offset？</p>
</li>
</ul>
<h2 id="15-2-fork的实现"><a href="#15-2-fork的实现" class="headerlink" title="15.2 fork的实现"></a>15.2 fork的实现</h2><h3 id="15-2-1-fork设计的问题"><a href="#15-2-1-fork设计的问题" class="headerlink" title="15.2.1 fork设计的问题"></a>15.2.1 fork设计的问题</h3><p>创建副本这件事情的代价很大，进程可能有很大的地址空间，如果此时对一个非常大的地址空间fork一份，并且在这之后立马就execve，此时就会产生十分大的性能浪费，此时OS会怎么应对这种状况？</p>
<p><strong>OS中的进程地址空间设计</strong><br>每一个进程会有一个地址空间，并且在地址空间当中会进行分页（MMU），而进程其本身拥有的只是一个映射表。映射表提供了相关的信息，表示不同的内容会映射到分页之后的哪个页面，所以概念上进程拥有这些页面，其实实际上依然是由OS控制着所有这些内容。</p>
<h3 id="15-2-2-共享只读设计"><a href="#15-2-2-共享只读设计" class="headerlink" title="15.2.2 共享只读设计"></a>15.2.2 共享只读设计</h3><p>当一个进程拥有两个页面时，内容如下：<br><img src="/../../image/Pasted%20image%2020230829192242.png"><br>当指向了一个fork之后，其状态如下;<br><img src="/../../image/Pasted%20image%2020230829192306.png"><br>此时这两个进程都同时指向了一个可写的页面，因此Old进程可以写，New进程也可以写。但是此时OS会偷偷的抹掉这个可写的权限，进而可能发生缺页中断（段错误）。但如果OS发现，这个缺页中断只是被偷偷抹掉的，此时OS会将此页引用计数减1，然后将其拷贝一份到另外的可写权限的空间，从而把读写的权限重新还给NEW进程。<br><img src="/../../image/Pasted%20image%2020230829192322.png"><br><strong>优点：</strong><br>这种设计Copy on Write的设计，当遇到非常大的地址空间中需要映射的内容时，有时可以不需要为其创建新的内容，只有在使用时才产生这种Copy On Write。<br><strong>例子：libc</strong><br>整个OS里面，只有一份libc的副本，OS当中有很多的进程，此时这些不同的进程都是指向同一个libc。</p>
<p><strong>代码证明Copy On Write</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPROC 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MB 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE (MB * (1 &lt;&lt; 20))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xstr(s) str(s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> str(s) #s</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *data = <span class="built_in">malloc</span>(SIZE); <span class="comment">// 128MB shared memory</span></span><br><span class="line">  <span class="built_in">memset</span>(data, <span class="string">&#x27;_&#x27;</span>, SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NPROC - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// NPROC processes go here</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;.fill 1048576 * &quot;</span> xstr(MB) <span class="string">&quot;, 1, 0x90&quot;</span>)</span>; <span class="comment">// 128MB shared code</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, O_RDONLY); assert(fd &gt; <span class="number">0</span>);</span><br><span class="line">  read(fd, &amp;idx, <span class="keyword">sizeof</span>(idx));</span><br><span class="line">  close(fd);</span><br><span class="line">  idx %= <span class="number">1048576</span> * MB;</span><br><span class="line"></span><br><span class="line">  data[idx] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pid = %d, write data[%u]\n&quot;</span>, getpid(), idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// not terminate</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行了这个代码之后，在OS当中有1000个进程在进行，并且上述代码在SO中，每个都要求分配了128MB的内存。但是OS并没有Crash掉，实际只是用了1GB左右的内存。这就是Copy On Write的实现。</p>
<p><strong>关于进程内存占有量</strong><br>由此推导出一个结论：证明一个进程用的多少的内存就是一个伪命题。如果简单的将一个进程映射的内存之和相加作为其内存大小，mmap可以映射一大片的内存（比如20T内存），但是这些内存是按需使用的，其只是做了一个映射，然后使用时只会用多少分配多少，并且还有很多内存是共享的（Libc）。</p>
<h2 id="15-3-状态机的复制"><a href="#15-3-状态机的复制" class="headerlink" title="15.3 状态机的复制"></a>15.3 状态机的复制</h2><h3 id="15-3-1-状态机视角"><a href="#15-3-1-状态机视角" class="headerlink" title="15.3.1 状态机视角"></a>15.3.1 状态机视角</h3><p><strong>概念：平行宇宙与fork</strong><br>物理世界上不同的粒子状态，可以定义出不同时间下的状态。如果此时要进行时间穿越，此时行为就是将未来的部分状态带到过去，并且从此状态开始进行分叉，而这个分叉就是fork()。<br>OS运行开发者使用fork()实现平行宇宙。</p>
<h3 id="15-3-2-fork与并行化"><a href="#15-3-2-fork与并行化" class="headerlink" title="15.3.2 fork与并行化"></a>15.3.2 fork与并行化</h3><p><strong>例子1：码交换搜索问题</strong><br>和不同的部分进行交换，就会进入不同的状态。可以使用状态机的视角，将所有的状态进行探索。<br>![[Lecture 15：Fork的应用 2023-03-16 16.57.00.excalidraw]]</p>
<p><strong>例子2：基于fork的dfs</strong><br>原本的dfs会使用深度遍历进行探索，然后使用回溯法回到原本的状态，回溯的过程十分耗时。而如果基于fork，使用状态机的视角来进行迁移，则可以只会跳回到初始状态（通过使用exit()来实现）。<br>其启示是：可以使用fork实现dfs；使用fork来进入不同的状态，并且联合OS来帮助进行管理，此时进入新的状态后原本的平行宇宙也可以被消除掉，每探索完一个平行宇宙都将其删除掉。<br>并且，还可以创造多个平行宇宙，并行的得到所有状态，然后程序结束。</p>
<h3 id="15-3-3-fork与跳过初始化"><a href="#15-3-3-fork与跳过初始化" class="headerlink" title="15.3.3 fork与跳过初始化"></a>15.3.3 fork与跳过初始化</h3><p><strong>问题</strong><br>假设你的NEMU需要启动很多份elf头文件，而如果NEMU进行初始化要花很多的时间（比如花费大量时间来初始化一片128MB的内存），此时如果为每个elf来进行启动就会产生大量消耗，此时可以按照以下行为分析：<br>![[Lecture 15：Fork的应用 2023-03-16 17.29.53.excalidraw]]<br><strong>处理方法</strong><br>此时可以只执行一次nemu_init()的内容，之后只需要每进来一个需要启动的内容，就fork一份，然后找到没有处理的文件，将其进行处理，就可以完成操作。并且因为只进行一次init，因此可以加速程序执行第一个文件的速度。</p>
<p><strong>跳过初始化的实际应用</strong><br>应用：安卓应用的秒启动</p>
<ul>
<li>简介：每一个安卓的程序都会通过以上的跳过初始化的方式进行启动。</li>
<li>原理：安卓应用是一个Java程序，而Java是运行在JVM虚拟机上面，对于安卓而言是一个Android Runtime（自己实现的虚拟机）。而安卓和Java都会有一个十分大的标准库，如果每一个程序是采取冷启动，即从0开始执行整个Java程序，不可能几秒内完成加载，此时就是使用了跳过初始化的思想，所有的Java程序只进行初始化一次。</li>
<li>Zygote Process：会有一个所有Android程序的父进程，名称为Zygote Process。其会完成所有必要的安卓程序的必要的类的加载，此时如果开始了一个新的程序，只要在init之后的状态基础之上fork一份即可完成创建。</li>
<li>一次加载，全员使用<br>应用：Chrome浏览器</li>
<li>简介：Chrome可以成功的原因之一，就是其速度非常的快。</li>
<li>原理：Chrome当中，每一个网页就是一个进程，使用跳过初始化的思想来进行网页的快速加载</li>
</ul>
<p><strong>核心：只要是从一个状态出发，需要很多个副本的，都可以使用fork。</strong></p>
<h3 id="15-3-4-fork与备份"><a href="#15-3-4-fork与备份" class="headerlink" title="15.3.4 fork与备份"></a>15.3.4 fork与备份</h3><p><strong>简介：</strong><br>要是我们可以对有Bug的程序总是能在任何状态“试一试”，然后试错了还能回到过去，就好了。<br><strong>概念：</strong><br>当过去某个节点发生了一个Bug，我们能否回到过去，在产生一次这个Bug?特别是出现并发Bug，此类Bug或许十分难以重现，拥有此存档机制就可以去复现过去状态下的Bug。<br>在任何状态下，可以使用fork()开启另一条平行宇宙，然后在此基础上进行存档。然后如果顺着正常的路径进行执行，但是之后在这主分支之上发生了Crash，此时就可以拿回之前的存档，从之前的存档开始。<br><img src="/../../image/Pasted%20image%2020230829192347.png"><br>然后拿回了之前的存档后，从此存档开始执行，并且需要更改一些环境。很多Bug都是由于环境导致的（比如许多的并发Bug）。<br>![[Lecture 15：Fork的应用 2023-03-17 21.27.15.excalidraw]]<br>这就是可以进行容错的机制。如果有轻量级的快照，就可以使用平行宇宙来复查一些Bug。甚至如果是想要还原并发这种Bug，甚至不需要复杂的Fork的快照，只需要有一个Setjmp寄存器的快照。</p>
<h2 id="15-4-对于Fork的讨论"><a href="#15-4-对于Fork的讨论" class="headerlink" title="15.4 对于Fork的讨论"></a>15.4 对于Fork的讨论</h2><h3 id="15-4-1-A-Fork-in-the-road"><a href="#15-4-1-A-Fork-in-the-road" class="headerlink" title="15.4.1 A Fork() in the road"></a>15.4.1 A Fork() in the road</h3><p><strong>简介：</strong><br>对于Unix Fork的批评。<br><strong>概述：</strong><br>fork使用的最舒服的时候，就是在一个简单的管道模型当中。但是随着OS发展，进程不止是有地址空间和文件描述符，但是之后进程会有信号（fork之后，发信号是两个都发，还是只发一个？），线程，进程间通信对象，ptrace等等。<br>fork的开发者对于这些问题进行了修复，但是结果就是导致现在的fork十分的复杂。比如出现线程之后。</p>
<p><strong>这些都是由进程拥有了一些更加复杂的对象所引发出的问题。</strong></p>
<h3 id="15-4-2-线程对于Fork的影响"><a href="#15-4-2-线程对于Fork的影响" class="headerlink" title="15.4.2 线程对于Fork的影响"></a>15.4.2 线程对于Fork的影响</h3><p><strong>线程概述</strong><br>在一个进程当中，会有一片地址空间，两个不同的线程共享这些地址空间，所有的页面都是共享的（因为页面是由OS持有的）。<br><img src="/../../image/Pasted%20image%2020230829192415.png"><br><strong>问题</strong><br>此时如果fork了一份这个进程，这当中的这些线程会怎么样？</p>
<p><strong>分析</strong><br>首先，肯定是进程当中的某一个线程执行了fork，在执行了fork之后，是对应进程复制，另一个进程消失，还是两者都被复制？<br>正确答案是 只复制执行了fork的进程。<br><img src="/../../image/Pasted%20image%2020230829192444.png"></p>
<h3 id="15-4-3-更安全的创建一个进程"><a href="#15-4-3-更安全的创建一个进程" class="headerlink" title="15.4.3 更安全的创建一个进程"></a>15.4.3 更安全的创建一个进程</h3><p><strong>创建进程：POSIX Spawn</strong><br>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">posix_spawn</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">pid_t</span> *pid,</span></span><br><span class="line"><span class="params"><span class="type">char</span> *path,</span></span><br><span class="line"><span class="params"><span class="type">posix_spawnattr_t</span> *attrp,</span></span><br><span class="line"><span class="params"><span class="type">char</span>* argv[],</span></span><br><span class="line"><span class="params"><span class="type">char</span>* envp[]</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>其是一个在fork发明出来之后的API，比fork更加的简单。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Fork</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 17：动态链接与加载</title>
    <url>/2023/08/7c3f50531736.html</url>
    <content><![CDATA[<blockquote>
<p>前言：可执行文件就是一个描述状态机初始状态的数据结构；<br>问题：<br>    1、可执行文件如何被OS加载？<br>    2、什么是动态链接&#x2F;动态加载？</p>
</blockquote>
<span id="more"></span>
<h2 id="17-1-静态ELF文件加载器"><a href="#17-1-静态ELF文件加载器" class="headerlink" title="17.1 静态ELF文件加载器"></a>17.1 静态ELF文件加载器</h2><h3 id="17-1-1-ELF文件"><a href="#17-1-1-ELF文件" class="headerlink" title="17.1.1 ELF文件"></a>17.1.1 ELF文件</h3><p><strong>ELF文件定义</strong><br>在OS下面的“&#x2F;usr&#x2F;include&#x2F;elf.h”文件中，可以看到ELF文件定义描述；<br><img src="/../../image/Pasted%20image%2020230829193028.png"><br><strong>获得程序的ELF</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf a.out</span><br></pre></td></tr></table></figure>
<p>使用此指令来获得可执行文件的elf文件信息，并将其翻译出来；<br>ELF文件描述了一个数据结构，这个数据结构描述了进程在execve之后被Loader使用时如何加载；</p>
<h3 id="17-1-2-ELF加载器"><a href="#17-1-2-ELF加载器" class="headerlink" title="17.1.2 ELF加载器"></a>17.1.2 ELF加载器</h3><p>Loader所作行为：解析数据结构 + 复制信息到内存 + 跳转<br><strong>Loader需加载内容</strong></p>
<ul>
<li>1、ELF文件里面的信息</li>
<li>2、设置一些运行时状态<ul>
<li>argv</li>
<li>envp<br>以上两部分内容共同构成进程的初始状态；</li>
</ul>
</li>
</ul>
<p><strong>Loader实现了解</strong><br>Loader只是个程序，其通过动态链接的方式编译；<br>在编译之后，可以往Loader传入一个参数：比如某个程序，此时Loader会开始将ELF文件搬到指定的位置上，并且可以是使用此Loader加载其他程序。<br>在Loader当中，使用mmap + ELF信息映射到内存当中； Loader解析ELF数据结构，然后把对应内容放到内存；<br>当所有的内容都使用mmap搬进内存之后，可以使用pmap观看其地址空间：<br>可以看到其地址空间当中有两份程序，一份是loader的内存，一份是minimal的内容；即当前ELF所有具体的内容都被加载；</p>
<h3 id="17-1-3-进程初始状态设置"><a href="#17-1-3-进程初始状态设置" class="headerlink" title="17.1.3 进程初始状态设置"></a>17.1.3 进程初始状态设置</h3><p>完成对于进程的栈以及其他空间的初始化设置；<br>实例化进程Stack：<br><img src="/../../image/Pasted%20image%2020230829193055.png"><br>比如：当中指明了rsp寄存器指向Argument Count，并且8 + rsp执行后续的参数；<br>有了这个手册之后，之后的行为就是把这些内容实现成代码。</p>
<p><strong>初始化代码实现</strong></p>
<ol>
<li>先静态分配一片空间，将此空间设置为栈空间；<ol>
<li>![[Pasted image 20230329190038.png]]</li>
</ol>
</li>
<li>定义对应的push指令，可以将内容push到栈中；</li>
<li>对照着实例化进程文档，将内容push到栈上；<ol>
<li>![[Pasted image 20230329190137.png]]</li>
<li>argc、argv以及环境变量等，依次压入栈中；</li>
</ol>
</li>
<li>最后执行跳转<ol>
<li>![[Pasted image 20230329190308.png]]</li>
<li>将程序的入口地址给到指针，将rdx和rsp清零；</li>
</ol>
</li>
</ol>
<p><strong>OS、Loader与execve之间关系</strong><br>以上实现的第一个Loader是在OS上实现的，基于操作系统中的open、mmap、close，使用这些系统调用实现了一个execve，因此execve在某种程度上不是必须的，Linux可以基于ld静态链接，加上mmap、open等系统调用，就完成程序的加载。<br>由此可知：相当一部分系统调用可以实现成用户态的；</p>
<h3 id="17-1-4-Boot-Block-Loader"><a href="#17-1-4-Boot-Block-Loader" class="headerlink" title="17.1.4 Boot Block Loader"></a>17.1.4 Boot Block Loader</h3><p><strong>什么是Boot Block Loader</strong><br>由固件实现的Boot Block Loader，将OS通过固件，一点一点加载到磁盘上、内存里。并且除了这512字节的最开始的block，在这之后还有1024字节的main args，在这之后是OS的Kernel内核文件。</p>
<p><strong>加载OS内核</strong><br>哪怕ELF文件只有512字节的二进制文件，也可以为其写一个Loader；</p>
<ul>
<li>![[Pasted image 20230329191754.png]]<br>把Main函数的参数加载进来，并在之后把elf32复制，创建状态机的状态；<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">load_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  Elf32_Ehdr *elf32 = (<span class="type">void</span> *)<span class="number">0x8000</span>;</span><br><span class="line">  Elf64_Ehdr *elf64 = (<span class="type">void</span> *)<span class="number">0x8000</span>;</span><br><span class="line">  <span class="type">int</span> is_ap = boot_record()-&gt;is_ap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!is_ap) &#123;</span><br><span class="line">    <span class="comment">// load argument (string) to memory</span></span><br><span class="line">    copy_from_disk((<span class="type">void</span> *)MAINARG_ADDR, <span class="number">1024</span>, <span class="number">-1024</span>);</span><br><span class="line">    <span class="comment">// load elf header to memory</span></span><br><span class="line">    copy_from_disk(elf32, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (elf32-&gt;e_machine == EM_X86_64) &#123;</span><br><span class="line">      load_elf64(elf64);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      load_elf32(elf32);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// everything should be loaded</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (elf32-&gt;e_machine == EM_X86_64) </span><br><span class="line">  &#123;</span><br><span class="line">    ((<span class="type">void</span>(*)())(<span class="type">uint32_t</span>)elf64-&gt;e_entry)();<span class="comment">//设置程序进入点</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  &#123;</span><br><span class="line">    ((<span class="type">void</span>(*)())(<span class="type">uint32_t</span>)elf32-&gt;e_entry)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="17-2-Linux内核加载器"><a href="#17-2-Linux内核加载器" class="headerlink" title="17.2 Linux内核加载器"></a>17.2 Linux内核加载器</h2><p>使用make进行编译，然后即可以对其进行调试；之后可以使用GDB，和调试其他的可执行程序一样来调试这个Linux代码，只要将BreakPoint放在代码的EntryPoint上即可。<br>之后如果想进行进一步的调试，就得开始使用一些更加现代的工具以及IDE，比如VSCode来把Linux内核放入到VSCode当中；<br>可以将Linux生成的哪些链接信息给到VSCode，这样就可以在编辑界面当中来动态的获得一个内容的链接内容；</p>
<h2 id="17-3-动态链接与加载"><a href="#17-3-动态链接与加载" class="headerlink" title="17.3 动态链接与加载"></a>17.3 动态链接与加载</h2><h3 id="17-3-1-为什么需要动态链接"><a href="#17-3-1-为什么需要动态链接" class="headerlink" title="17.3.1 为什么需要动态链接"></a>17.3.1 为什么需要动态链接</h3><p><strong>静态链接问题</strong></p>
<ul>
<li>随着项目越来越大，库函数越来越大，文件系统会越来越膨胀，需要占有大量的磁盘空间；即不希望每个库函数都在可执行文件里面进行库函数的拷贝；</li>
<li>同时，大型项目有把应用程序拆开的需求；</li>
</ul>
<p><strong>动态链接</strong><br>只要库函数遵循一定的标准，那么就可以把这个库在运行动态的链接；编译一部分，不用重新链接；</p>
<p><strong>工业界实际的ELF问题</strong><br>ELF是一个数据结构，这个数据结构当中有专门的符号表，将一些概念上紧密相关的东西在数据结构中通过符号表（为了提升性能）强行拆散；</p>
<h3 id="17-3-2-自顶向下设计的动态链接实现"><a href="#17-3-2-自顶向下设计的动态链接实现" class="headerlink" title="17.3.2 自顶向下设计的动态链接实现"></a>17.3.2 自顶向下设计的动态链接实现</h3><p><strong>基本假设</strong><br>假设所有的加载器、编译器、链接器都完全收你控制，此时生成一个最小的用于动态链接的数据结构，然后再在此基础上针对ELF进行优化；</p>
<p><strong>最小的ELF</strong><br>当想要实现自己的库函数，当中有一个putchar的符号需要被动态加载，如何进行设计？<br>简化之后，动态链接最基本的行为：</p>
<ul>
<li>LOAD（“libc.dl”）&#x2F;&#x2F;加载动态库</li>
<li>IMPORT（putchar）&#x2F;&#x2F;加载外部符号</li>
<li>EXPORT（hello）&#x2F;&#x2F;为动态库导出符号</li>
<li>在代码中引用一个外部库的符号</li>
</ul>
<h4 id="17-3-2-1-最小加载器实现"><a href="#17-3-2-1-最小加载器实现" class="headerlink" title="17.3.2.1 最小加载器实现"></a>17.3.2.1 最小加载器实现</h4><p>JYY实现的最小动态链接加载器；<br>![[Pasted image 20230330174916.png]]<br>自己实现的最简单的二进制文件格式：<br>![[Pasted image 20230330175114.png]]</p>
<h4 id="17-3-3-2-动态链接Header定义"><a href="#17-3-3-2-动态链接Header定义" class="headerlink" title="17.3.3.2 动态链接Header定义"></a>17.3.3.2 动态链接Header定义</h4><p>使用此Header定义此二进制可执行文件的格式；<br>最简单的二进制动态链接文件：就是由一个头文件和一个符号表构成的；</p>
<p><strong>dl_Header代码：</strong><br>![[Pasted image 20230414182843.png]]<br><strong>dl_Header图示：</strong><br>![[Lecture 17：动态链接与加载 2023-04-14 18.22.19.excalidraw]]</p>
<p><strong>定义的四个宏</strong><br>![[Pasted image 20230414182950.png]]<br>第一个：IMPORT</p>
<ol>
<li>在Imoort当中使用DSYM函数</li>
<li>在DSYM函数中当中传入sym（比如说是putchar，目标链接函数名称）</li>
<li>当前sym当中传入间接寻址的地址rip，然后putchar指向symbol当中的offset。<br>第二个：EXPORT<br>向当中传入一个外部符号的调用，为了导出这个符号，在offset当中保存这个符号的相对于符号头部的偏移量；</li>
</ol>
<p><strong>程序预编译之后</strong><br>![[Pasted image 20230414184042.png]]<br>每一个symbol都被对齐到32字节，offset开始时为0，此时加载器发现了这个符号的offset的值为零，此时就会开始间接调转，查询符号表，将地址填入到这当中。</p>
<p>符号链接：当你想要跳转到一个你所不知道的地址上时，就现找一块数据（offset）填上零，然后做一个间接跳转，在加载器进行加载的时候，查符号表，将地址填进去；</p>
<p><strong>二进制视角文件</strong><br>![[Pasted image 20230414185023.png]]<br>第20行，前面八位的全零部分标志，以及libc.dl表示的需要链接的程序；<br>包括90，a0部分的全零内容，对应的多个struct symbol之后的全零字段；<br>然后c0,d0之后就是代码的部分；</p>
<h3 id="17-3-3-对动态链接定义的加载"><a href="#17-3-3-对动态链接定义的加载" class="headerlink" title="17.3.3 对动态链接定义的加载"></a>17.3.3 对动态链接定义的加载</h3><p><strong>对dl的加载代码：</strong><br>![[Pasted image 20230414185311.png]]<br>就是扫描符号表，将dl二进制文件中对应的符号找到其需要的地址；碰到LOAD就打印其名称，碰到EXTERN就打印其对应内容；</p>
<p><strong>objump实现</strong><br>![[Pasted image 20230414185450.png]]<br>两个For循环内的内容：</p>
<ul>
<li>第一层for循环：遍历符号表</li>
<li>第二层：遍历代码的每一个字节<ul>
<li>当代码的某一个字节刚好对应某一个符号的时候，执行一个反汇编，使用ndisasm反汇编器将代码输出出来；</li>
</ul>
</li>
</ul>
<p><strong>加载器主要部分：dlopen</strong><br>![[Pasted image 20230414190056.png]]<br>首先获得dl的hdr头文件，然后把path文件打开，解析文件头；<br>通过解析文件头知道了文件有多大后，使用mmap将其需要的内容直接映射到内存当中；<br>如果内存映射成功，在for循环内遍历符号表，如果符号表当中是+号则进行递归加载，如果是问号，则直接赋值offset内容；</p>
<h3 id="17-3-4-自己设计DL文件中的缺陷"><a href="#17-3-4-自己设计DL文件中的缺陷" class="headerlink" title="17.3.4 自己设计DL文件中的缺陷"></a>17.3.4 自己设计DL文件中的缺陷</h3><p><strong>代码分段</strong><br>自己编写的代码只能可读可写可执行，想要不同部分不同类型，就需要进行分段；<br><strong>指定加载器</strong><br>需要指定一个加载器</p>
<p>写一个编译器的时候，在编译器的视角里面，C代码当中出现的函数，不知道其是静态链接的还是动态链接；不知道是用call还是call DASM，而且不知道外部符号在哪里；并且call是不需要间接跳转的；<br>当链接时发现是一个动态链接符号的话，就需要靠plt去找内容，因此就发明了GOT和PLT；</p>
<p>全局偏移表：<br>![[Pasted image 20230414191207.png]]<br>在ELF文件之下：<br>![[Pasted image 20230414191222.png]]<br>所有的间接跳转，全部都在PLT里面；</p>
<p><strong>GOT</strong><br>我们的符号表就是GOT（Global Offset Table）</p>
<p><strong>对于静态、动态链接的统一</strong><br>无论静态动态，都统一使静态链接先；<br>然后增加一层间接层：Procedure Linkage Table（PLT），将所有未被解析的符号都统一翻译成call。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">putchar</span> PLT:</span><br><span class="line">	call DSYM（<span class="built_in">putchar</span>）</span><br><span class="line">main:</span><br><span class="line">	call <span class="built_in">putchar</span> PLT</span><br></pre></td></tr></table></figure>

<p>作业：读实例代码；</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>链接</tag>
        <tag>ELF</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 14：C标准库的实现</title>
    <url>/2023/08/68a724658d83.html</url>
    <content><![CDATA[<p>操作系统内核对外面提供的API就是Syscall，而当中和用户交互的就是Shell。而在Shell的外面，OS提供了一个框架性程序，帮助开发者实现应用程序（因为没有人愿意在没有库函数的情况下，直接使用汇编、系统调用来制作应用程序）</p>
<blockquote>
<p>· 在系统调用之上构建可以普遍使用的标准库：libc</p>
</blockquote>
<span id="more"></span>
<h2 id="14-1-系统调用的封装"><a href="#14-1-系统调用的封装" class="headerlink" title="14.1 系统调用的封装"></a>14.1 系统调用的封装</h2><h3 id="14-1-1-熟悉又陌生的libc"><a href="#14-1-1-熟悉又陌生的libc" class="headerlink" title="14.1.1 熟悉又陌生的libc"></a>14.1.1 熟悉又陌生的libc</h3><p><strong>为什么需要libc</strong><br>虽然不借助任何的库函数也可以写程序，但是在自己写的时候还是要进行封装（一些固定的功能）。<br>裸奔式的编程是不可行的，即使是实现最简单的程序也有很多可以重用的部分。</p>
<h3 id="14-1-2-libc提供的类型系统"><a href="#14-1-2-libc提供的类型系统" class="headerlink" title="14.1.2 libc提供的类型系统"></a>14.1.2 libc提供的类型系统</h3><p><strong>第一种：类型系统</strong><br>问题：size of int 是多少大小？C语言编译器可以将其实现为八字节，也可以是四字节<br>解释：这种不同字节大小的类型，在进行跨平台交叉编译时，其移植性具有很大的障碍，因为其在不同平台上大小可能不同。<br>方法：libc标准库专门提供对应的标准基本类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在使用的时候，直接使用标注上字节大小的int或bool:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> a;</span><br><span class="line">	<span class="type">uint64_t</span> x;</span><br><span class="line">	<span class="type">intptr_t</span> ptr;<span class="comment">//可以保证，把这个指针cast成一个int之后不会丢失任何的数据</span></span><br><span class="line">	<span class="comment">//intptr_t ptr = (intptr_t)main;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是使用int替代intptr_t时，可能会丢失信息。</p>
<p>常见、在freestanding下也可以使用的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stddef.h -&gt; <span class="type">size_t</span></span><br><span class="line">stdint.h -&gt; <span class="type">int32_t</span>,<span class="type">uint64_t</span></span><br><span class="line">stdbool.h -&gt; <span class="type">bool</span>,<span class="literal">true</span>,<span class="literal">false</span></span><br><span class="line"><span class="type">float</span>.h</span><br><span class="line">limits.h</span><br><span class="line">stdarg.h</span><br></pre></td></tr></table></figure>
<p>系统syscall使用到的stdarg.h；<br>另一个问题：long type<br>long type32位机上是四字节，在其他机器上可能是八字节；</p>
<h3 id="14-1-3-libc对系统调用的封装"><a href="#14-1-3-libc对系统调用的封装" class="headerlink" title="14.1.3 libc对系统调用的封装"></a>14.1.3 libc对系统调用的封装</h3><p><strong>对execve()系统调用的封装</strong><br>execve()并不好用，平时使用的时候使用麻烦。<br>比如execve()的第一个路径必须为是一个合法的路径，可以是相对路径，但必须是合法的路径：<code>../../../../../../.././bin/echo</code><br>execve如果不给合法的路径，其会直接拒绝用户，但用户想要实现的是找到path当中的echo，而不是找完全准确的那个path。<br>平时写代码可能会用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execlp(<span class="string">&quot;echo&quot;</span>,<span class="string">&quot;echo&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;OS course&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//打印结果：hello OS course</span></span><br></pre></td></tr></table></figure>
<p>用静态的方式编译，然后查看其系统调用：<br><img src="/../../image/Pasted%20image%2020230829192141.png"><br>execve会尝试每一个path当中的路径，然后直到成功找到那个程序，然后使用execve进程reset。这当中也介绍了更高情商的API：execlp<br><em>补充：在看手册的时候，手册当中经常会有很大的引用，比如在execve的手册当中，其当中可以看到SEE ALSO，顺着这些引用往下看就可以算是实现了一次文献调研</em><br>libc就是对在系统调用的基础上，面向人类易用性进行的封装。</p>
<h3 id="14-1-4-libc对string、数组的封装"><a href="#14-1-4-libc对string、数组的封装" class="headerlink" title="14.1.4 libc对string、数组的封装"></a>14.1.4 libc对string、数组的封装</h3><p><strong>main函数中的参数</strong><br>main函数会有三个参数。当中有一个数组：<code>char *argv[]*</code></p>
<p>memset实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span>* s <span class="type">int</span> c,<span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;n ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		((<span class="type">char</span>*)s)[i] = c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>memset对于数据竞争的态度：直接不管你，谁最后把数据写进去，内存单元就是哪个进程的，并且标准库只对“标准库内部数据”的线程安全性负责。<br>使用clang对其进行编译后的结果：</p>
<p><strong>补充：libc实现的复杂性</strong><br>对于libc的实现者而言，因为Libc会被很多人调用，因此其正确性必须得得到验证。并且作为Libc，其必须得跑得快，而且还得兼顾各种的机器，在不同机器上面跑的快不快……<br>在多个线程使用其时，会不会产生数据竞争，是不是还得考虑安全……新的机制来了，当前代码还得支持。</p>
<p><em>补：现在的C语言 &#x3D; 大号的汇编语言 + 大家还能接受的API的标准</em></p>
<h3 id="14-1-5-其他的例子"><a href="#14-1-5-其他的例子" class="headerlink" title="14.1.5 其他的例子"></a>14.1.5 其他的例子</h3><p>数学库的实现：过于复杂，比如浮点数的性质，比如在接近0的时候如何保证精度。而OS要对纯粹的计算进行封装。</p>
<hr>
<h2 id="14-2-文件描述符与进程封装"><a href="#14-2-文件描述符与进程封装" class="headerlink" title="14.2 文件描述符与进程封装"></a>14.2 文件描述符与进程封装</h2><p>操作系统中存在大量的对象，比如终端、对于Shell来说连接的终端。libc的职责之一，就是对于这些常见对象的封装</p>
<h3 id="14-2-1-什么是文件描述符"><a href="#14-2-1-什么是文件描述符" class="headerlink" title="14.2.1 什么是文件描述符"></a>14.2.1 什么是文件描述符</h3><p>文件描述符就是一个打开的文件，而Linux当中一切都是文件，因此可以使用文件描述符来打开一切对象。因此Libc必须要对文件描述符进行一定的封装。 </p>
<p>例：往文件系统里面写文件的一段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* fp = fopen(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;Hello,OS world\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>使用gcc编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -g a.c &amp;&amp; ./a.out</span><br></pre></td></tr></table></figure>

<p>这是OS视角下，当前程序的行为。但也可以从用户的视角来看一下，这个代码发生的行为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p *fp</span><br></pre></td></tr></table></figure>
<p>对文件描述符的指针解引用，得出的结果（部分）：<br>![[Pasted image 20230307171858.png]]<br>由此可以看到：FILE* 背后就是封装了一个文件描述符。同时一个FILE只能返回一个文件描述符，要么是读口要么是写口。<br>装填了值之后，fp解引用会变成这样：<br>![[Pasted image 20230307172411.png]]<br>可以清晰的看到libc为其设置的不同区域的大小以及对应的内容。</p>
<p>popen和pclose的设计具有缺陷（或者说相比于现代的语言，不易用）</p>
<h3 id="14-2-2-其他进程-操作系统功能"><a href="#14-2-2-其他进程-操作系统功能" class="headerlink" title="14.2.2 其他进程&#x2F;操作系统功能"></a>14.2.2 其他进程&#x2F;操作系统功能</h3><p><strong>错误信息处理</strong><br>所有的API都有可能失败，此时Shell可能会发出一个error message，比如“No Such file or directory”。并且不止是这一个错误发出了这个信息，还有很多的其他err message都是这个，是不是背后有一个共通的错误反应的内容？<br>因为这背后都使用了一样的libc当中的错误处理代码，一代一代的传承出来（除非有一个打破者，比如rust出现）</p>
<p><strong>环境变量</strong><br>可以自己实现env.c这样的命令，借助Linux提供的env.c机制，可以实现非常简单的env环境变量实现。<br>在C语言当中可以使用环境变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br></pre></td></tr></table></figure>
<p>而这些环境变量在执行之前就已经有值，这些值是谁设置的？如何查看这些内容？<br>可以使用gdb调试，从starti开始执行。<br>先编译一下env.c代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc env.c -g -static</span><br></pre></td></tr></table></figure>
<p>受用gdb使用时，最开始starti时没有值，再往下执行后，可以看到时__libc_start_main()给其赋值<br>gdb断点查看：<br>![[Pasted image 20230308165300.png]]</p>
<h2 id="14-3-地址空间的封装"><a href="#14-3-地址空间的封装" class="headerlink" title="14.3 地址空间的封装"></a>14.3 地址空间的封装</h2><h3 id="14-3-1-内存分配行为"><a href="#14-3-1-内存分配行为" class="headerlink" title="14.3.1 内存分配行为"></a>14.3.1 内存分配行为</h3><p><strong>简介</strong><br>libc的一个非常重要的功能之一就是内存管理，而这块主要就是malloc和free，任何的应用程序都需要大量的分配内存。</p>
<p><strong>行为分析</strong><br>在一个大区间中维护互不相交的区间的集合，大区间由mmap来实现，mmap基于当前进程的地址空间，从当中挖去一大块内存。<br>在一个左闭右开的区间，维护一个数据结构，这些被分配的内存互相不相交，在这片内存当中进行malloc和free，可以往一片空区分配内存，或者将已经分配的内存释放掉。因此malloc和free就是区间管理。</p>
<p><strong>内存分配的效率问题</strong><br>当想要在设计内存管理的时候，使用类似红黑树、B+树类似的算法思路想要去实现算法复杂度的log(n)时，就已经陷入误区。<br>在OS上，在多处理器的方案下，光是想要实现安全性就够困难了。</p>
<p><strong>任何脱离workflow的性能优化都是耍流氓</strong>，在考虑性能之前，需要先考虑需要什么样的性能。</p>
<h3 id="14-3-2-内存管理workflow分析"><a href="#14-3-2-内存管理workflow分析" class="headerlink" title="14.3.2 内存管理workflow分析"></a>14.3.2 内存管理workflow分析</h3><p><strong>指导思想</strong><br>内存被分配出来就是为了被使用的，O(n)大小的对象分配至少需要有相对应数量级的读写操作，不然就是性能Bug。<br>必须是在需要对应的对象，需要那么多的内存时才分配那部分内存。</p>
<p><strong>问题</strong></p>
<ul>
<li>越小的对象创建&#x2F;分配越频繁<ul>
<li>字符串、临时对象等</li>
<li>生存周期可长可短</li>
</ul>
</li>
<li>较为频繁的分配中等大小的对象<ul>
<li>较大的数组、复杂的对象</li>
<li>更长的生命周期</li>
</ul>
</li>
<li>低频率的大对象<ul>
<li>巨大的容器、分配器</li>
<li>很长的生存周期</li>
</ul>
</li>
<li>挑战：并行化的分配问题<ul>
<li>所有的分配都会在处理器上发生，而处理器是并发、相互高度用总线连接的</li>
</ul>
</li>
</ul>
<h3 id="14-3-3-内存问题的两种方案"><a href="#14-3-3-内存问题的两种方案" class="headerlink" title="14.3.3 内存问题的两种方案"></a>14.3.3 内存问题的两种方案</h3><p>设置两套系统：</p>
<ul>
<li>fast path<ul>
<li>性能好，并行度好，覆盖大部分情况</li>
<li>可以很快的解决问题，但是有小概率失败</li>
</ul>
</li>
<li>slow path<ul>
<li>性能没那么好，但是要求把事情做好</li>
</ul>
</li>
<li>人的fast系统和slow系统<ul>
<li>直觉式的反应系统和推力式的反应系统</li>
</ul>
</li>
</ul>
<p><strong>Malloc：Fast Path设计</strong><br>简介：使得所有的CPU都可以并行的申请内存<br>实现：想实现更快的分配，因此不能进行上锁，如果此时有两个线程，此时可以以page的方式，在page的基础上维护一个空闲链表，当一个page分配完了，再从全局的page当中分配一个page，往其上一把锁，然后把这个page返回给需要的地方。<br>当快速的在page上分配内存时是fast path，但是当内存不够，分配更多的page时，此时是slow path。通过这种设计实现slow path的访问变少，性能变好。<br>如果不想在page上使用链表维护时，还可以设置最小的分配单元位32b、64b、…4kb，此时有一个64kb的page，在此page上有个Header，除了这个Header之外，在这个Page上就是一堆16b的对象（或者其他格式），可以为每个分配的大小单独分配结构。</p>
<p><strong>小内存的分段设计</strong><br>基于一个个Segregation上进行分配，每个slab里面的对象大小都一致，每个线程都在本地拥有立即分配完成的权限。</p>
<p><strong>大内存的大锁设计</strong><br>需要分配大内存时，此时就是使用线段树，将一串区域切分成树，然后变成了一个算法问题。使用一把大锁保证其安全。</p>
<h2 id="14-4-总结"><a href="#14-4-总结" class="headerlink" title="14.4 总结"></a>14.4 总结</h2><h3 id="14-4-1-相关手册"><a href="#14-4-1-相关手册" class="headerlink" title="14.4.1 相关手册"></a>14.4.1 相关手册</h3><p><strong>Libc手册</strong><br>The GNU C Library</p>
<p>Libc的实现：Newlib</p>
<h3 id="14-4-2-从C走向世界"><a href="#14-4-2-从C走向世界" class="headerlink" title="14.4.2 从C走向世界"></a>14.4.2 从C走向世界</h3><p>基于C，可以实现C++的编译器<br>基于C++，可以实现C++标准库<br>基于C++，可以是西安OpenJDK<br>基于C++，可以实现JS，进而实现整个浏览器当中的世界</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 28：持久数据的可靠性</title>
    <url>/2023/08/2a905fcc408b.html</url>
    <content><![CDATA[<ul>
<li>前言：文件系统和OS的耦合度<ul>
<li>相比于进程以及虚拟化部分，文件系统和OS的耦合程度相对较低；</li>
<li>从 1-bit 数据 -&gt; 设备 -&gt; 驱动 -&gt; Block IO（Bread&#x2F;Bwrite） -&gt; Block Array 在块的数组上构建文件系统 -&gt; 目录结构</li>
<li>这当中已经经过了很多层的抽象，对于底层的实现细节抽象程度高；</li>
</ul>
</li>
<li>文件系统算法与持久化<ul>
<li>文件系统算法的基本假设是：内存可靠，以及接受断电数据丢失（这部分内容是文件系统的数据结构实现的假设）</li>
<li>但：磁盘上的数据是不接受丢失的。如何保证持久数据的可靠性；<span id="more"></span></li>
</ul>
</li>
</ul>
<h2 id="28-1-RAID"><a href="#28-1-RAID" class="headerlink" title="28.1 RAID"></a>28.1 RAID</h2><p>RAID：Redundant Array of lnexpensiveDisks；</p>
<h3 id="28-1-1-存储需求"><a href="#28-1-1-存储需求" class="headerlink" title="28.1.1 存储需求"></a>28.1.1 存储需求</h3><p><strong>持久存储的需求：性能</strong><br>因为有超大容量的计算中心，才能实现现在互联网上大量的数据。只要CPU处理的过来，就尽可能多的放硬盘；<br>因此在计算中心当中，有专门用于存储数据的服务器，这当中有上百块磁盘：<br><img src="/../../image/Pasted%20image%2020230829204003.png"></p>
<p><strong>持久存储的需求：可靠性</strong></p>
<ul>
<li>基本前提<ul>
<li>任何物理存储的介质都有失效的可能性；</li>
<li>小概率事件：硬盘损坏（但 大量重复 &#x3D; 必然发生）</li>
</ul>
</li>
</ul>
<p><strong>两方面的需求：性能与可靠性</strong><br>当性能高时，大量的设备就会增加出错的可能性，进而减少可靠性；但依然需要可靠性，才能保证系统正常使用；</p>
<ul>
<li>解决方法：RAID<ul>
<li>存储设备的虚拟化</li>
<li>图灵奖论文：<a href="https://dl.acm.org/doi/10.1145/971701.50214">https://dl.acm.org/doi/10.1145/971701.50214</a></li>
<li>内容：证明了可靠性和性能可以兼得；</li>
</ul>
</li>
</ul>
<h3 id="28-1-2-RAID：存储设备的虚拟化"><a href="#28-1-2-RAID：存储设备的虚拟化" class="headerlink" title="28.1.2 RAID：存储设备的虚拟化"></a>28.1.2 RAID：存储设备的虚拟化</h3><p><strong>RAID内容</strong><br>对于磁盘内容反向的虚拟化；</p>
<ul>
<li>内容简介：<ul>
<li>不同的虚拟化<ul>
<li>进程：把一个CPU分时虚拟成多个虚拟CPU</li>
<li>虚存：把一份内存通过MMU虚拟成多个地址空间；</li>
<li>文件：把一个存储设备虚拟成多个虚拟磁盘；</li>
</ul>
</li>
<li>可以有很多个磁盘，每一个都不太可靠。可以把这些磁盘的整体当成是一个虚拟的磁盘。当有一个磁盘消失时，虚拟磁盘不会收到任何的影响；</li>
</ul>
</li>
</ul>
<p><strong>RAID基本假设</strong></p>
<ul>
<li>假设一：磁盘可能在某个时候就突然彻底无法访问；<ul>
<li>机械故障；</li>
<li>芯片故障；</li>
</ul>
</li>
<li>假设二：有很多个磁盘；</li>
</ul>
<h3 id="28-1-3-RAID实现：最简单的版本"><a href="#28-1-3-RAID实现：最简单的版本" class="headerlink" title="28.1.3 RAID实现：最简单的版本"></a>28.1.3 RAID实现：最简单的版本</h3><p>假设现在有v1和v2两个虚拟磁盘，然后还有A和B两个物理磁盘；<br>当需要保证可靠性时，只需要让v1的数据和v2的数据各自在AB上存储一份：<br><img src="/../../image/Pasted%20image%2020230829212321.png"><br>因此，任何一块盘丢了之后都不会对系统产生致命影响，大幅提高了可靠性；<br>并且，当需要对磁盘进行读写时，速度可以更快，因为可以A和B一起读，各自读一半的数据，因此速度提高了一倍：<br><em>不过写入的速度还是50%</em><br><img src="/../../image/Pasted%20image%2020230829212645.png"></p>
<h3 id="28-1-4-RAID实现：设计空间"><a href="#28-1-4-RAID实现：设计空间" class="headerlink" title="28.1.4 RAID实现：设计空间"></a>28.1.4 RAID实现：设计空间</h3><ul>
<li><p>例子：把两个1t的物理磁盘（AB）虚拟化成一个2t的虚拟磁盘；</p>
<ul>
<li>此时如果相对盘进行读写时，比如读V1和V2，此时速度并没有翻倍。</li>
<li>因为B1、B2在看戏；<br><img src="/../../image/Pasted%20image%2020230829213035.png"></li>
</ul>
</li>
<li><p>设计目的：同时利用带宽</p>
<ul>
<li>将内容随机映射，使得AB都有空间；</li>
<li>此时如果读V3V4，此时在虚拟磁盘上还是连续的，并且可以同时读写；<br><img src="/../../image/Pasted%20image%2020230829213258.png"></li>
</ul>
</li>
</ul>
<p><strong>设计空间</strong><br>此时对于文件而言，就是以下过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(i)： 如何把Vi映射到f(i)块上，即设计空间</span><br></pre></td></tr></table></figure>
<p><img src="/../../image/Pasted%20image%2020230829213624.png"></p>
<p><strong>RAID-10</strong><br>假设有4块盘，此时可以先用两块组成RAID1，在用两外两块组成RAID2；最终一起组成RAID0；<br>一起对应成4块物理磁盘ABCD；<br><img src="/../../image/Pasted%20image%2020230829214052.png"><br>此时V1234分别放在了ABCD上，并且用于很高的带宽及其稳定度。其可以容忍任何一块磁盘出现事故；并且可以并行的方式进行读写；<br>并且：假设A和C都坏了，V1234都还正常存储；</p>
<ul>
<li>RAID-10：有时能容忍两块盘坏，有时候却不能。如果我们有很多块盘，能否减少浪费?</li>
</ul>
<h3 id="28-1-5-RAID实现：奇偶校验和"><a href="#28-1-5-RAID实现：奇偶校验和" class="headerlink" title="28.1.5 RAID实现：奇偶校验和"></a>28.1.5 RAID实现：奇偶校验和</h3><p>当前如果有4块盘，可以有3块专门用于存放数据，还有一块专门用于存放奇偶校验；<br>把ABC当作是RAID0，并且V234依然是连续的；<br>磁盘D专门用于存储校验和。<br><img src="/../../image/Pasted%20image%2020230829214910.png"></p>
<p>当有100块盘时，可以用99块来存储数据，1块来存储奇偶校验和。</p>
<ul>
<li>问题<ul>
<li>这种方法读取速度很快，连续写入很快；</li>
<li>但是随机写入的速度十分的满；</li>
<li>随机写的性能成为了性能的瓶颈；</li>
</ul>
</li>
</ul>
<h3 id="28-1-6-RAID实现：每块盘都是奇偶盘"><a href="#28-1-6-RAID实现：每块盘都是奇偶盘" class="headerlink" title="28.1.6 RAID实现：每块盘都是奇偶盘"></a>28.1.6 RAID实现：每块盘都是奇偶盘</h3><p>可以在每一盘上面都放上奇偶盘；每一块盘都可以作为奇偶盘。<br><img src="/../../image/Pasted%20image%2020230829215520.png"></p>
<p><strong>性能分析：盘越多，速度越快</strong><br>RAID把很多不可靠的磁盘，变成了又快有可靠的磁盘；<br><img src="/../../image/Pasted%20image%2020230829215605.png"></p>
<p><strong>But：谷歌把所有不可靠的计算机，变得分布式的可靠</strong><br>因此云计算革掉了大型机计算的命。计算机进入大数据时代。</p>
<h2 id="28-2-崩溃一致性与崩溃恢复"><a href="#28-2-崩溃一致性与崩溃恢复" class="headerlink" title="28.2 崩溃一致性与崩溃恢复"></a>28.2 崩溃一致性与崩溃恢复</h2><p>在有了RAID之后，可以保证数据的存储的可靠性；但是对于一致性的实现还需要这部分内容；</p>
<ul>
<li><strong>即使磁盘现在是可靠的，但软件依然可能不可靠</strong><ul>
<li>比如OS突然蓝屏了，电脑Crash；操作系统内容Crash然后蓝屏；</li>
<li>系统随时可能会发生断电；<ul>
<li>但从此时有可能正在往文件系统里面写入数据，写入到磁盘上；</li>
</ul>
</li>
<li>但：文件系统是OS上的一个数据结构</li>
</ul>
</li>
</ul>
<h3 id="28-2-1-文件存储行为"><a href="#28-2-1-文件存储行为" class="headerlink" title="28.2.1 文件存储行为"></a>28.2.1 文件存储行为</h3><p><strong>一个文本文件的存储</strong><br>当现在有一个文本文件，且需要往里面写入一段数据时，此时行为就是：</p>
<ul>
<li>把文件 变成一堆 bwrite和bread 的指令，并且此时文件的元数据也需要更改；</li>
<li>并且此时会有一块新写入数据的Data区域；</li>
<li>文件系统的EOF也需要更改<ul>
<li><img src="/../../image/Pasted%20image%2020230831213400.png"></li>
<li>fat1 </li>
<li>fat2</li>
</ul>
</li>
</ul>
<p><strong>如果想要把一个文件持久化保存时，此时一个文件需要多个数据块（bwrite和bread）；</strong><br>问题：应该按照什么样的顺序将其存入进去呢？并且如果此时断电，该如何应对呢？<br>并且还可能出现数据不一致的状态；</p>
<ul>
<li>文件系统<ul>
<li>即使只是加上一个字节，也涉及多块磁盘的更改；</li>
</ul>
</li>
</ul>
<h3 id="28-2-2-崩溃一致性"><a href="#28-2-2-崩溃一致性" class="headerlink" title="28.2.2 崩溃一致性"></a>28.2.2 崩溃一致性</h3><p>Crash Consistency: Move the file system from one consistentstate (e.g: before themle got appended to) to anotheratomically (e.g: after the inode, bitmap, and new data blockhave been written to disk)<br>所有平时编程时假设不会发生的事情，OS都需要进行兜底；磁盘不仅不支持多块读些的功能，甚至还不支持顺序读写；</p>
<ul>
<li>当有多条存储指令到来时，有可能会发生乱序进行的情况；</li>
</ul>
<p><strong>bwrite和bread之外，OS提供的指令：bflush</strong><br>可以在两个有顺序要求的指令之间，插入一条bflush指令，即要求此命令的执行顺序不能越过此bflush指令；</p>
<ul>
<li>类似于并发里面的barrier</li>
</ul>
<p><strong>磁盘乱序的后果</strong><br>任何一个写入的子集都有乱序的可能：有可能在某一个move的操作时，就有可能发生问题；随时都有可能因为磁盘写入时的状态不一致，导致损坏产生；</p>
<h3 id="28-2-3-FSCK"><a href="#28-2-3-FSCK" class="headerlink" title="28.2.3 FSCK"></a>28.2.3 FSCK</h3><p>文件系统检查：File System Checking<br><strong>核心：根据磁盘上的已有信息，恢复出最有可能的数据结构</strong></p>
<ul>
<li>文件系统可能会有不一致的情况；</li>
<li>通过制定一定的规则，恢复磁盘上的数据结构；<br><img src="/../../image/Pasted%20image%2020230831235530.png"><br><em>针对crash，需要一个更可靠的方法</em><br>比如在文件崩溃断电后，此时重写挂载会进行磁盘一致性（状态）检查。但如果此时又发生一次断电，这些数据可能就永远消失了；</li>
</ul>
<p><strong>FSCK方法的局限性</strong><br>FSCK方法并不是解决崩溃不一致性的最终方法，根本性的方法是：用数据结构的方法；</p>
<h3 id="28-2-4-日志"><a href="#28-2-4-日志" class="headerlink" title="28.2.4 日志"></a>28.2.4 日志</h3><p><strong>不用数据结构记录，而是记录操作</strong><br>除了会有当前全部数据所构成的状态；包括当前数据里面所有的结构、数据、字段、数等等内容；<br>但同时，还可以构建另外一种状态，此状态<strong>存储了当前对于数据的操作序列</strong>；比如什么时候插入一个序列，什么时候删除一个数据等等。<br>只要“Append”only，就可以把状态恢复出来。（即把所有的历史操作记录下来）</p>
<p><strong>日志</strong><br>当数据结构发生变化时，先用append only记录日志。当日志落盘后，在更新实际数据的数据结构；<br>崩溃没关系，只要重放日志并清楚，就可以redo log：把需要的数据再读写一遍；</p>
<p><strong>如何实现：随意append任意大小的数据</strong><br>如何通过用bread，bwrite和bflush实现append()？<br><img src="/../../image/Pasted%20image%2020230901000727.png"></p>
<ol>
<li>定位到 journal 的末尾 (bread)</li>
<li>bwrite TXBegin 和所有数据结构操作</li>
<li>bflush 等待数据落盘</li>
<li>bwrite TXEnd</li>
<li>bflush 等待数据落盘</li>
<li>将数据结构操作写入实际数据结构区域</li>
<li>等待数据落盘后，删除 (标记) 日志</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
        <tag>操作系统</tag>
        <tag>日志系统</tag>
        <tag>RAID</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 16：什么是可执行文件</title>
    <url>/2023/08/92c8110645cf.html</url>
    <content><![CDATA[<p>目前已经把操作系统表层上的内容都创建好了，这部分之后会再次回归到最开始的地方。</p>
<ul>
<li>重新回到可执行文件：可执行文件是什么，其如何在OS上运行；<span id="more"></span></li>
</ul>
<h2 id="16-1-可执行文件"><a href="#16-1-可执行文件" class="headerlink" title="16.1 可执行文件"></a>16.1 可执行文件</h2><h3 id="16-1-1-手册的逻辑"><a href="#16-1-1-手册的逻辑" class="headerlink" title="16.1.1 手册的逻辑"></a>16.1.1 手册的逻辑</h3><p><strong>链接</strong><br>关于可执行文件的手册地址：<a href="http://jyywiki.cn/pages/OS/manuals/sysv-abi.pdf">http://jyywiki.cn/pages/OS/manuals/sysv-abi.pdf</a></p>
<p><strong>读手册的逻辑</strong><br>如果想要了解某部分知识，需要去观看包含其的对应的手册。但是很多手册（Friendly Manual）都有大量的依赖知识，只有拥有了这些依赖知识才能读懂这个手册。因此不能直接读手册，而是先学习简单的模型，回到7、80年代的概念，然后在学习手册当中最核心的部分，随着积累越来越多在逐渐往外扩展。</p>
<h3 id="16-1-2-可执行文件：状态机的描述"><a href="#16-1-2-可执行文件：状态机的描述" class="headerlink" title="16.1.2 可执行文件：状态机的描述"></a>16.1.2 可执行文件：状态机的描述</h3><p><strong>简介</strong><br>可执行文件在OS当中是被execve调用的，而execve是把当前进程的状态机进行重置。所以由此可以进行一个推论：<br><strong>可执行文件，是一个状态机的初始状态的描述</strong>（或者说时描述一个状态机被重置之后的状态），并且还描述了状态机之后的数据迁移。<br>[[Lecture 11：操作系统上的进程#11.3 进程与execve()]]</p>
<p><strong>问题：如果自己要实现一个可执行文件，应该涵盖什么</strong><br>因为可执行文件就是用于描述状态机重置之后的初始状态，那状态机的状态无非就是：</p>
<ol>
<li><p>寄存器<br>查看方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info registers</span><br></pre></td></tr></table></figure>
<p><img src="/../../image/Pasted%20image%2020230829192659.png"><br>这当中有些值是由在状态机的初始状态下直接将其赋为0，比如r8~r15寄存器，其不需要在二进制数据中进行指定；有些是需要指定的，比如rip寄存器的值；还有些是由OS来为其分配的，比如rsp寄存器；</p>
</li>
<li><p>内存（地址空间）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info inferiors //获得进程号</span><br><span class="line">pmap 390489    //打印地址空间</span><br></pre></td></tr></table></figure></li>
</ol>
<p>所有这些地址空间中的数据，比如592k的可读可执行，首先会有两个问题：1、其地址在哪里；2、其初始值为多少；这些就是其初始值信息。<br>[[Lecture 12：进程的地址空间]]</p>
<p><strong>可执行文件的本质</strong><br>可执行文件就是一个数据结构，描述了状态机的 初始状态 + 迁移，然后再思考将什么信息放入到二进制文件里。</p>
<h3 id="16-1-3-操纵系统上的可执行文件"><a href="#16-1-3-操纵系统上的可执行文件" class="headerlink" title="16.1.3 操纵系统上的可执行文件"></a>16.1.3 操纵系统上的可执行文件</h3><p><strong>文件的可执行权限</strong><br>更改文件权限指令：<br>以下是添加一个可执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x a.out</span><br></pre></td></tr></table></figure>
<p>如果将一个可执行文件的可执行权限抹除掉，此时再对其进行执行将产生报错；而如果将一个源代码文件的可执行权限打开，强行将一个源代码文件改为可执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x a.c</span><br></pre></td></tr></table></figure>
<p>此时将产生一个Permission denied的报错。</p>
<p><strong>是谁决定了一个文件能不能执行？</strong><br>执行一个程序时会使用execve系统调用，在使用execve读取可执行文件时，OS才会去检查其可执行权限；<br>![[Pasted image 20230322163623.png]]<br>但是如果将a.out文件的可执行权限抹除掉，此时再使用strace观察进程的系统调用会变成如下情况：<br>![[Pasted image 20230322163934.png]]<br>此时操作系统返回了EACCES，给了一个错误信息；<br>但如果将一个a.c文件，将其权限改为可执行文件，此时再去观测去strace其报错会变成：Exec format error信息，表示OS无法识别此可执行文件。 </p>
<h3 id="16-1-4-常见的可执行文件"><a href="#16-1-4-常见的可执行文件" class="headerlink" title="16.1.4 常见的可执行文件"></a>16.1.4 常见的可执行文件</h3><p>核心：<strong>可执行文件就是一个操作系统内的普通对象；</strong></p>
<p><strong>She-bang</strong><br>可以在一个c语言的文件中写入以下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#感叹号/usr/bin/python3</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<p>此时这个a.c文件就变得可执行了，并且输出了Hello。</p>
<p>She-bang机制：可以在代码当中跟一个可执行文件，然后程序会去执行它。<br>当操作系统发现了一个“#！”后，execve会把#！后背的内容填写到execve的第一个参数，把file文件填写到第二个参数；<br>所以She-bang就是一个偷梁换柱的execve。</p>
<h2 id="16-2-解析可执行文件"><a href="#16-2-解析可执行文件" class="headerlink" title="16.2 解析可执行文件"></a>16.2 解析可执行文件</h2><h3 id="16-2-1-GNU-binutils-工具"><a href="#16-2-1-GNU-binutils-工具" class="headerlink" title="16.2.1 GNU binutils 工具"></a>16.2.1 GNU binutils 工具</h3><p>部分工具：<br>![[Pasted image 20230322190921.png]]<br>这些工具可以用在可执行文件上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf -h a.out</span><br></pre></td></tr></table></figure>

<p>可执行文件就是描述状态机初始状态的数据结构，而binutils就是解析这个数据结构的工具；比如objdump就是把代码的汇编语言解析出来，其就是对于数据结构的查看、生成、修改的工具。</p>
<h3 id="16-2-2-可执行文件的运行时状态"><a href="#16-2-2-可执行文件的运行时状态" class="headerlink" title="16.2.2 可执行文件的运行时状态"></a>16.2.2 可执行文件的运行时状态</h3><p>还可以使用调试器来获得可执行文件的运行时状态，info可以帮助debugger获得运行时状态。<br>GDB获得调用栈信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb)bt</span><br></pre></td></tr></table></figure>
<p>为什么GDB可以打印程序的back trace?GDB如何通过内存里面的信息打印出以上的信息？<br>因为二进制文件当中有一些额外信息，这些额外信息可以帮助你实现<code>addr2line</code>命令；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">addr2line 0x401cfb a.out</span><br></pre></td></tr></table></figure>
<p>然后会打印目标位置对应的行号：</p>
<h3 id="16-2-3-调试信息"><a href="#16-2-3-调试信息" class="headerlink" title="16.2.3 调试信息"></a>16.2.3 调试信息</h3><p>在进行GCC编译的时候，如果加上了-S 选项，会加上一些额外的调试信息；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -static source.c -g -S</span><br></pre></td></tr></table></figure>
<p>使用-g表示生成汇编代码，在这其中生成了很多更多的调试信息；</p>
<p><strong>DWARF通用调试信息</strong><br>编译器在编译时会生成很多额外的信息（DWARF调试信息），这些调试信息十分通用；其允许你对于任何一段内存定义一个函数f()，然后如果你的程序指针pc指向这里，每一段内存都有一个f()函数，调用这个f()就可以把这些内存当中存储的信息获得出来。</p>
<p><strong>优化后的调试信息问题</strong><br>但是因为编译器的优化，导致在进行分析调试信息的时候，经常会产生一些错误，即把二进制的状态转换成汇编层面的语义十分具有挑战性。</p>
<p><strong>程序BackTrace与GCC优化Bug</strong><br>在获得程序的backtrace时，需要获得每个被调用函数的地址。此时如果将函数在栈上通过寄存器的数值保存的rbp的数值来生成一个链表，可以通过访问此链表的方式来获得当前函数的每个地址信息。但是如果使用了gcc的-O2优化，则很多个函数会在优化后被合成一个函数，此时就无法获得其在C语言语言层面上的调用栈信息，进而无法获得其函数调用的backtrace。</p>
<p><strong>逆向工程</strong><br>如果想获得一个商业软件的可执行文件里面，恢复其尽可能多的信息，就需要进行你想工程。<br>工具：ida<br>书籍：《IDApro权威指南》</p>
<h2 id="16-3-链接与重定位"><a href="#16-3-链接与重定位" class="headerlink" title="16.3 链接与重定位"></a>16.3 链接与重定位</h2><h3 id="16-3-1-从C代码到二进制文件"><a href="#16-3-1-从C代码到二进制文件" class="headerlink" title="16.3.1 从C代码到二进制文件"></a>16.3.1 从C代码到二进制文件</h3><p>在使用gcc编译链接之后，一个代码当中对于未定义函数的使用，是如何通过链接，访问到其他代码当中的函数的？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是main函数，f()未定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//这里是f()的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用gcc将main()函数对应的代码变成汇编代码之后，程序的大部分内容都已经被确定，但是还剩下部分callq指令（函数调用）未被确定：<br>![[Pasted image 20230328192912.png]]<br>此时其还不知道此函数的地址，其会生成00来填充；</p>
<p><strong>汇编且还未链接的程序的设计语义</strong>：main.o就是一个数据结构，在这个数据结构当中包含了所有重要的代码，并且还包含了其<strong>未来需要满足的内容的约束</strong>。而在函数调用时，其就是相对偏移量的约束，S(目标函数位置) + A(-4) - P(P &#x3D; main + 0xb)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assert(</span><br><span class="line">	(<span class="type">char</span> *)hello == </span><br><span class="line">	(<span class="type">char</span> *)main + </span><br><span class="line">	<span class="number">0xf</span> +</span><br><span class="line">	*(<span class="type">int32_t</span> *)((<span class="type">uintptr_t</span>)main + <span class="number">0xb</span>));</span><br></pre></td></tr></table></figure>

<h3 id="16-3-2-重新理解编译、链接过程"><a href="#16-3-2-重新理解编译、链接过程" class="headerlink" title="16.3.2 重新理解编译、链接过程"></a>16.3.2 重新理解编译、链接过程</h3><p><strong>编译器（gcc）</strong></p>
<ul>
<li>High-level semantics (C 状态机) → low-level semantics (汇编)</li>
</ul>
<p><strong>汇编器 (as)</strong></p>
<ul>
<li>Low-level semantics → Binary semantics (状态机容器)<ul>
<li>“一一对应” 地翻译成二进制代码<ul>
<li>sections, symbols, debug info</li>
</ul>
</li>
<li>不能决定的要留下 “之后怎么办” 的信息<ul>
<li>relocations</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>链接器 (ld)</strong></p>
<ul>
<li>合并所有容器，得到 “一个完整的状态机”<ul>
<li>ldscript (<code>-Wl,--verbose</code>); 和 C Runtime Objects (CRT) 链接</li>
<li>missing&#x2F;duplicate symbol 会出错</li>
</ul>
</li>
</ul>
<p><strong>图示：</strong><br><img src="/../../image/Pasted%20image%2020230829192839.png"></p>
<p>而在这些过程当中，ELF只不过是一个描述以上过程的一个“容器数据结构”，包含了完成以上过程所需的必要信息：<br><img src="/../../image/Pasted%20image%2020230829192904.png"><br>正确的理解ELF的方式是：当你自己想要实现一个ELF时，有哪些部分是必不可少的？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">executable</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="type">uint32_t</span> entry; <span class="comment">//代码的进入点地址：代码、数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">segment</span> *<span class="title">segments</span>;</span> <span class="comment">//不同的段</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reloc</span> *<span class="title">relocs</span>;</span><span class="comment">//重定位</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">symbol</span> *<span class="title">symbols</span>;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="type">uint32_t</span> flags, size; <span class="comment">//每个段是可执行可读？还是可执行？可写？</span></span><br><span class="line">	<span class="type">char</span> data[<span class="number">0</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reloc</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="type">uint32_t</span> S, A, P;<span class="comment">//用于计算重定位后的地址</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">32</span>]; <span class="comment">//重定位地址的名字</span></span><br><span class="line">	&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symbol</span> &#123;</span> <span class="type">uint32_t</span> off; <span class="type">char</span> name[<span class="number">32</span>]; &#125;;</span><br></pre></td></tr></table></figure>
<p>然后在这么一个最简单的数据结构当中，会有很多缺陷，围绕这这些缺陷进行更多的设计，最终就形成了现在所看到的繁杂的ELF文件。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>链接</tag>
        <tag>可执行文件</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>【Game Engine】P1：引擎事件系统</title>
    <url>/2023/08/73d34ee8e11a.html</url>
    <content><![CDATA[<p>引擎事件系统框架编写</p>
<span id="more"></span>

<h2 id="1-事件类型基础"><a href="#1-事件类型基础" class="headerlink" title="1.事件类型基础"></a>1.事件类型基础</h2><h3 id="1-1-事件类型枚举"><a href="#1-1-事件类型枚举" class="headerlink" title="1.1 事件类型枚举"></a>1.1 事件类型枚举</h3><p>描述事件系统的基础事件类型，用枚举表示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">EventType</span></span><br><span class="line">&#123;</span><br><span class="line">	None = <span class="number">0</span>,</span><br><span class="line">	WindowClose, WindowResize, WindowFocus, WindowLostFocus, WindowMoved,</span><br><span class="line">	AppTick, AppUpdate, AppRender,</span><br><span class="line">	KeyPressed, KeyReleased,</span><br><span class="line">	MouseButtonPressed, MouseButtonReleased, MouseMoved, MouseScrolled</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-事件分类"><a href="#1-2-事件分类" class="headerlink" title="1.2 事件分类"></a>1.2 事件分类</h3><p>定义了事件分类，并且可以向0进行过滤、偏移；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EventCategory</span></span><br><span class="line">&#123;</span><br><span class="line">	None = <span class="number">0</span>,</span><br><span class="line">	EventCategoryApplication = <span class="built_in">BIT</span>(<span class="number">0</span>),</span><br><span class="line">	EventCategoryInput = <span class="built_in">BIT</span>(<span class="number">1</span>),</span><br><span class="line">	EventCategoryKeyboard = <span class="built_in">BIT</span>(<span class="number">2</span>),</span><br><span class="line">	EventCategoryMouse = <span class="built_in">BIT</span>(<span class="number">3</span>),</span><br><span class="line">	EventCategoryMouseButton = <span class="built_in">BIT</span>(<span class="number">4</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BIT的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT(x) (1 &lt;&lt; x)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-Event基类设计"><a href="#2-Event基类设计" class="headerlink" title="2.Event基类设计"></a>2.Event基类设计</h2><ul>
<li>内容：<ul>
<li>m_Handled：用于表示此内容是否已经被处理过；</li>
<li>IsInCategory：现在处理的事件，是否是属于类型的部分；使用此方法快速的进行过滤； </li>
<li>GetName：仅用在Debug模式；</li>
<li>ToString：默认输出名字，也可以继承后修改以及扩展此行为；<ul>
<li>实现细节：stringstream的性能很差，但目前Debug模式可以先不考虑；</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> Event</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">EventDispatcher</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> EventType <span class="title">GetEventType</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetCategoryFlags</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetName</span>(); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsInCategory</span><span class="params">(EventCategory category)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GetCategoryFlags</span>() &amp; category;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">bool</span> m_Handled = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-抽象函数的实现宏"><a href="#2-1-抽象函数的实现宏" class="headerlink" title="2.1 抽象函数的实现宏"></a>2.1 抽象函数的实现宏</h3><p>因为在Event当中有抽象函数需要实现，每一个子类都需要手动进行实现的话会导致浪费。可以将其写成一个宏函数，在子类当中只需传入类型，既可以自动实现其子类的抽象函数的实现；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_CLASS_TYPE(type) static EventType GetStaticType() &#123; return EventType::##type; &#125;\</span></span><br><span class="line"><span class="meta">								virtual EventType GetEventType() const override &#123; return GetStaticType(); &#125;\</span></span><br><span class="line"><span class="meta">								virtual const char* GetName() const override &#123; return #type; &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-KeyEvent类设计"><a href="#3-KeyEvent类设计" class="headerlink" title="3.KeyEvent类设计"></a>3.KeyEvent类设计</h2><p><strong>KeyEvent概念</strong><br>需要处理案件的事件。并且按键的事件至少具有以下三种状态：</p>
<ol>
<li>第一次按下</li>
<li>按下中</li>
<li>第一次抬起<br>KeyEvent需要能够处理并表达这三种状态。</li>
</ol>
<p><strong>继承</strong><br>KeyEvent是其他更多按键事件的父类，是Event类的子类；</p>
<p><strong>KeyEvent代码</strong><br>此代码的内容类似于是抽象类，只是用于提供继承；不能实例化一个Key Event；</p>
<ul>
<li>内容：<ul>
<li>构造函数：构造函数被设置为protected，表示此类作用为提供继承；</li>
<li>Get Key Code：返回KeyCode数值；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> KeyEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetKeyCode</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_KeyCode; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryKeyboard | EventCategoryInput)</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">KeyEvent</span>(<span class="type">int</span> keycode)</span><br><span class="line">		: <span class="built_in">m_KeyCode</span>(keycode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_KeyCode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>EVENT_CLASS_CATEGORY内容</strong><br>因为KeyBoard键盘输入同时也是一般Input的一种，因此其进行分类时同属于这两种类型；</p>
<h3 id="3-1-KeyPressedEvent类设计"><a href="#3-1-KeyPressedEvent类设计" class="headerlink" title="3.1 KeyPressedEvent类设计"></a>3.1 KeyPressedEvent类设计</h3><p>此类是一个可以被实际实例化的类；</p>
<p><strong>构造函数</strong><br>此类的构造函数传入repeatCount，表示此按键的重复次数。当此数值不为0时，此内容表示当前Event在被重复按下；</p>
<p><strong>ToString重写</strong><br>输出”KeyPressedEvent: “ 加上 KeyCode 的数值；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> KeyPressedEvent : <span class="keyword">public</span> KeyEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">KeyPressedEvent</span>(<span class="type">int</span> keycode, <span class="type">int</span> repeatCount)</span><br><span class="line">		: <span class="built_in">KeyEvent</span>(keycode), <span class="built_in">m_RepeatCount</span>(repeatCount) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetRepeatCount</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_RepeatCount; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;KeyPressedEvent: &quot;</span> &lt;&lt; m_KeyCode &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; m_RepeatCount &lt;&lt; <span class="string">&quot; repeats)&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(KeyPressed)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_RepeatCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-KeyReleasedEvent类设计"><a href="#3-2-KeyReleasedEvent类设计" class="headerlink" title="3.2 KeyReleasedEvent类设计"></a>3.2 KeyReleasedEvent类设计</h3><p>和Pressed类基本一致，只不过没有repeatCount的计数内容；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> KeyReleasedEvent : <span class="keyword">public</span> KeyEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">KeyReleasedEvent</span>(<span class="type">int</span> keycode)</span><br><span class="line">		: <span class="built_in">KeyEvent</span>(keycode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;KeyReleasedEvent: &quot;</span> &lt;&lt; m_KeyCode;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(KeyReleased)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-EventDispatcher"><a href="#4-EventDispatcher" class="headerlink" title="4.EventDispatcher"></a>4.EventDispatcher</h2><p><strong>作用</strong><br>让我们可以实际的去发布一个事件，基于需要发布事件的类型；<br>创建一个Dispatcher的实例，并且拥有一个Event的引用。在这个Dispatcher中拥有一个Dispatch()方法，可以接受一个EventFn函数。然后如果类型一致，可以实际的在Dispatch中运行这个EventFn的函数。</p>
<p><strong>构造函数</strong><br>Event基类作为参数，接受各种事件类型，赋值在私有的Event变量上；</p>
<p><strong>Dispatch()方法</strong><br>在此方法内需要使用上Event，进行判断泛型传入的类型T的事件类型，和当前Dispatch中存储的Event的类型是否一致（通过GetEventType()方法，调用GetStaticType()方法）；<br>一致时，会调用EventFn中存储的函数，并返回bool；</p>
<p><strong>EventFn函数</strong><br>使用std的function，并且返回bool类型，接受T&amp;引用（可以为任何类型的Event）作为参数；</p>
<ul>
<li>补充：<strong>std::function()</strong><ul>
<li>可以把std::function看做一个函数对象，用于表示并存储函数这个抽象概念。</li>
<li>std::function的实例可以存储、复制和调用任何可调用对象（函数指针，类成员函数指针，bind表达式等等），存储的可调用对象称为std::function的目标，若std::function不含目标，则称它为空</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventDispatcher</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">using</span> EventFn = std::function&lt;<span class="built_in">bool</span>(T&amp;)&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">EventDispatcher</span>(Event&amp; event)</span><br><span class="line">		: <span class="built_in">m_Event</span>(event)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="type">bool</span> <span class="title">Dispatch</span><span class="params">(EventFn&lt;T&gt; func)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Event.<span class="built_in">GetEventType</span>() == T::<span class="built_in">GetStaticType</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			m_Event.m_Handled = <span class="built_in">func</span>(*(T*)&amp;m_Event);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Event&amp; m_Event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-MouseEvent设计"><a href="#5-MouseEvent设计" class="headerlink" title="5.MouseEvent设计"></a>5.MouseEvent设计</h2><p><strong>MouseMovedEvent</strong><br>传入x、y表示两个坐标位置，用于存储鼠标移动事件所需要的信息；<br>同理MouseScrolledEvent。<br>下面内容基本类似，主要关注构造函数中传入的参数的差别，代表了此种类型事件所实际需要使用到的数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseMovedEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MouseMovedEvent</span>(<span class="type">float</span> x, <span class="type">float</span> y)</span><br><span class="line">		: <span class="built_in">m_MouseX</span>(x), <span class="built_in">m_MouseY</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_MouseX; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetY</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_MouseY; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;MouseMovedEvent: &quot;</span> &lt;&lt; m_MouseX &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; m_MouseY;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(MouseMoved)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryMouse | EventCategoryInput)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> m_MouseX, m_MouseY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseScrolledEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MouseScrolledEvent</span>(<span class="type">float</span> xOffset, <span class="type">float</span> yOffset)</span><br><span class="line">		: <span class="built_in">m_XOffset</span>(xOffset), <span class="built_in">m_YOffset</span>(yOffset) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetXOffset</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_XOffset; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetYOffset</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_YOffset; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;MouseScrolledEvent: &quot;</span> &lt;&lt; <span class="built_in">GetXOffset</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="built_in">GetYOffset</span>();</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(MouseScrolled)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryMouse | EventCategoryInput)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> m_XOffset, m_YOffset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseButtonEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetMouseButton</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Button; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryMouse | EventCategoryInput)</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">MouseButtonEvent</span>(<span class="type">int</span> button)</span><br><span class="line">		: <span class="built_in">m_Button</span>(button) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Button;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseButtonPressedEvent : <span class="keyword">public</span> MouseButtonEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MouseButtonPressedEvent</span>(<span class="type">int</span> button)</span><br><span class="line">		: <span class="built_in">MouseButtonEvent</span>(button) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;MouseButtonPressedEvent: &quot;</span> &lt;&lt; m_Button;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(MouseButtonPressed)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseButtonReleasedEvent : <span class="keyword">public</span> MouseButtonEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MouseButtonReleasedEvent</span>(<span class="type">int</span> button)</span><br><span class="line">		: <span class="built_in">MouseButtonEvent</span>(button) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;MouseButtonReleasedEvent: &quot;</span> &lt;&lt; m_Button;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(MouseButtonReleased)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-ApplicationEvent设计"><a href="#6-ApplicationEvent设计" class="headerlink" title="6.ApplicationEvent设计"></a>6.ApplicationEvent设计</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> WindowResizeEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">WindowResizeEvent</span>(<span class="type">unsigned</span> <span class="type">int</span> width, <span class="type">unsigned</span> <span class="type">int</span> height)</span><br><span class="line">		: <span class="built_in">m_Width</span>(width), <span class="built_in">m_Height</span>(height) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Width; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Height; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;WindowResizeEvent: &quot;</span> &lt;&lt; m_Width &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; m_Height;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(WindowResize)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_Width, m_Height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> WindowCloseEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">WindowCloseEvent</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(WindowClose)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> AppTickEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AppTickEvent</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(AppTick)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> AppUpdateEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AppUpdateEvent</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(AppUpdate)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> AppRenderEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AppRenderEvent</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(AppRender)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>游戏引擎</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
        <tag>事件</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 29：Xv6文件系统实现</title>
    <url>/2023/09/a4bbdf6f0414.html</url>
    <content><![CDATA[<p><strong>什么是文件系统</strong><br>图书馆支持的所有操作，就是文件系统需要的所有操作；</p>
<ul>
<li>新建一个书架-&gt;新建文件夹</li>
<li>在书架的基础上：加上一本书</li>
<li>书签：文件描述符</li>
</ul>
<p><strong>FAT文件系统实现</strong><br>使用链表将一个个的文件Cluster连起来；在目录的最前面使用metadata来描述一些元信息：文件大小、目录结构等等；<br>这些链表如果是顺序存储情况下，在内存里面也将是连续的。但如果出现不是线性的存储，则其链表以及Cluster可能会分布在内存的各地；<br><img src="/../../image/Pasted%20image%2020230904200953.png"></p>
<ul>
<li>UNIX文件系统实现<ul>
<li>UNIX的文件系统，把以上的FAT当中用于连接cluster的链表全部存储在了内存当中的一个固定的地方，此时可以通过读取此固定的地方来知道如何对文件进行操作；<span id="more"></span></li>
</ul>
</li>
</ul>
<h2 id="1-mkfs：创建文件系统"><a href="#1-mkfs：创建文件系统" class="headerlink" title="1.mkfs：创建文件系统"></a>1.mkfs：创建文件系统</h2><p><strong>实现：只管分配，不管回收</strong><br>这个mkfs就是只管分配，不管回收的代码；</p>
<ul>
<li>rsect&#x2F;wsect (bread&#x2F;bwrite)</li>
<li>balloc&#x2F;bzero</li>
<li>ialloc</li>
<li>iappend</li>
<li>rinode&#x2F;winode<br>不管是FAT还是UNIX，最基础的内容都是rsect和wsect函数（由OS提供）；</li>
</ul>
<p><strong>如何阅读xv6的文件系统部分代码</strong><br>无论代码多么复杂，最后都会变成rsect和wsect这两个接口的调用；<br>因此只要可以把这两个接口的调用全部找出来，就可以更轻松的阅读这部分代码；</p>
<ul>
<li>用Python写的控制gdb的脚本<ul>
<li>trace(gdb.Breakpoint)：打一个break点；<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TRACED = <span class="string">&#x27;bwrite balloc ialloc iappend rinode winode rsect wsect&#x27;</span>.split()</span><br><span class="line">IGNORE = <span class="string">&#x27;ip xp buf&#x27;</span>.split()</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">trace</span>(gdb.Breakpoint):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        f, bt = gdb.selected_frame(), []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> f <span class="keyword">and</span> f.is_valid():</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (name := f.name()) <span class="keyword">in</span> TRACED:</span><br><span class="line"></span><br><span class="line">                lvars = [<span class="string">f&#x27;<span class="subst">&#123;sym.name&#125;</span>=<span class="subst">&#123;sym.value(f)&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> sym <span class="keyword">in</span> f.block()</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> sym.is_argument <span class="keyword">and</span> sym.name <span class="keyword">not</span> <span class="keyword">in</span> IGNORE]</span><br><span class="line"></span><br><span class="line">                bt.append(<span class="string">f&#x27;\033[32m<span class="subst">&#123;name&#125;</span>\033[0m(<span class="subst">&#123;<span class="string">&quot;, &quot;</span>.join(lvars)&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            f = f.older()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;    &#x27;</span> * (<span class="built_in">len</span>(bt) - <span class="number">1</span>) + bt[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># won&#x27;t stop at this breakpoint</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">gdb.execute(<span class="string">&#x27;set prompt off&#x27;</span>)</span><br><span class="line">gdb.execute(<span class="string">&#x27;set pagination off&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> fn <span class="keyword">in</span> TRACED:</span><br><span class="line">    trace(fn)</span><br><span class="line">gdb.execute(<span class="string">&#x27;run fs.img README user/_ls&#x27;</span>)</span><br><span class="line">gdb.execute(<span class="string">&#x27;quit&#x27;</span>)</span><br></pre></td></tr></table></figure>
使用此指令来执行以上代码：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb -ex &#x27;source mkfs/trace.py&#x27; mkfs/mkfs</span><br></pre></td></tr></table></figure>
mkfs 就是在磁盘上创建了一个数据结构，这个数据结构就是往一个文件的后背写入一些数据，不用管怎么删除。将代码最终变成 bread 和 bwrite；</li>
</ul>
</li>
</ul>
<h3 id="1-1-mkfs-问题"><a href="#1-1-mkfs-问题" class="headerlink" title="1.1 mkfs 问题"></a>1.1 mkfs 问题</h3><p><strong>mkfs 问题</strong><br>使用 mkfs 的时候，其会使用大量的 bread 和 bwrite ，并且一个简单的目录创建也会使用大量的代码。为了优化性能，另一种设计是使用 buffer cache 的技术。</p>
<h2 id="2-buffer-cache"><a href="#2-buffer-cache" class="headerlink" title="2.buffer cache"></a>2.buffer cache</h2><h3 id="2-1-buffer-cache-基础概念"><a href="#2-1-buffer-cache-基础概念" class="headerlink" title="2.1 buffer cache 基础概念"></a>2.1 buffer cache 基础概念</h3><p><strong>什么是 buffer cache</strong><br>在计算机操作系统中，Buffer Cache（缓冲区高速缓存）是一种机制，用于加速对磁盘和其他块设备的访问。它通过在内存中维护一个缓冲区来实现。</p>
<p><strong>作用：</strong><br>Buffer Cache 在操作系统中扮演着重要的角色，具体包括以下作用：</p>
<ol>
<li><strong>加速磁盘访问</strong>：通过存储最近读取的数据块，Buffer Cache 减少了直接从磁盘读取数据的次数，提高了读取操作的速度。  </li>
<li><strong>减少磁盘访问次数</strong>：当应用程序读取磁盘数据时，操作系统首先检查缓冲区是否存在所需的数据块，如果缓冲区中已有数据，直接从内存获取避免了频繁的磁盘访问。 </li>
<li><strong>优化写入操作</strong>：Buffer Cache 也用于写入操作。当应用程序要写入数据到磁盘时，操作系统首先将数据写入缓冲区，并记录更新信息。通过延迟将数据刷新到磁盘，系统可以在内存中进行高效的数据操作。</li>
</ol>
<p><strong>如何优化 buffer cache ?</strong><br>使用一定的算法，预测哪一些部分的数据更经常的被使用，然后提前将其读入到 buffer cache 当中；</p>
<h3 id="2-2-调试系统调用"><a href="#2-2-调试系统调用" class="headerlink" title="2.2 调试系统调用"></a>2.2 调试系统调用</h3><p><strong>写操作实现</strong><br>一个写的操作，会被分成很多个更小的写的操作；</p>
<ul>
<li>1 GB 文件的写入<ul>
<li>拆分成若干个 4 kb 的文件；</li>
<li>每一个小的 4 kb 文件可能可以执行 all or nothing 操作；</li>
</ul>
</li>
<li>写入指令<ul>
<li>应用程序实际上使用的不是 bwrite ，应用程序使用的是 logwrite 方法；</li>
<li>因为 bwrite 指令在进行存储的时候不具有原子性；<ul>
<li>一个写操作会对 block 的多个数据记录项进行修改；</li>
<li>bitmap</li>
<li>block </li>
<li>superdata</li>
<li>这些操作必须全部都进行，不然就会出现数据不一致；</li>
</ul>
</li>
<li><strong>所有对于磁盘的写都会变成对于日志的写</strong>；</li>
<li>然后再进行整块的写入；</li>
</ul>
</li>
<li>写入的时机<ul>
<li>执行 <code>end_op</code> 的时候；</li>
<li>执行一个 <code>commit()</code> 方法；</li>
<li>核心：<strong>由 log 系统调用 bread 和 bwrite 方法</strong>；</li>
</ul>
</li>
</ul>
<h2 id="3-崩溃恢复"><a href="#3-崩溃恢复" class="headerlink" title="3.崩溃恢复"></a>3.崩溃恢复</h2><p><strong>问题：是否可以恢复已经崩溃的代码？</strong><br>Xv 6 是否真的在崩溃发生后，可以把内容恢复回来；</p>
<p><strong>故障注入</strong><br>Crash &#x3D; 断电；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">crash</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> count = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">if</span> (--count &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">printf</span>(<span class="string">&quot;crash\n&quot;</span>);</span><br><span class="line">	  *((<span class="type">int</span> *)<span class="number">0x100000</span>) = <span class="number">0x5555</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以设置一个计数器为 count，每一次执行 bread 的时候此 count 都会减一；<br>当其小于零时，会执行 <code>*((int *)0x100000) = 0x5555;</code> 代码，然后虚拟机就可以关闭；</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
        <tag>操作系统</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>【Game Engine】P3：Window抽象与GLFW</title>
    <url>/2023/09/dad31b7b45e4.html</url>
    <content><![CDATA[<ol>
<li>GLFW与premake文件</li>
<li>项目Premake代码修改</li>
<li>Window 代码设计与实现<span id="more"></span></li>
</ol>
<h2 id="1-GLFW与premake文件"><a href="#1-GLFW与premake文件" class="headerlink" title="1.GLFW与premake文件"></a>1.GLFW与premake文件</h2><p>文件包含代码：<br>引用了项目需要用到的和GLFW相关的代码文件（for windows）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">files</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="string">&quot;include/GLFW/glfw3.h&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;include/GLFW/glfw3native.h&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;src/glfw_config.h&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;src/context.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;src/init.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;src/input.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;src/monitor.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;src/vulkan.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;src/window.c&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>以下是完整premake代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project &quot;GLFW&quot;</span><br><span class="line">    kind &quot;StaticLib&quot;</span><br><span class="line">    language &quot;C&quot;</span><br><span class="line">    </span><br><span class="line">	targetdir (&quot;bin/&quot; .. outputdir .. &quot;/%&#123;prj.name&#125;&quot;)</span><br><span class="line">    objdir (&quot;bin-int/&quot; .. outputdir .. &quot;/%&#123;prj.name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">	files</span><br><span class="line">	&#123;</span><br><span class="line">        &quot;include/GLFW/glfw3.h&quot;,</span><br><span class="line">        &quot;include/GLFW/glfw3native.h&quot;,</span><br><span class="line">        &quot;src/glfw_config.h&quot;,</span><br><span class="line">        &quot;src/context.c&quot;,</span><br><span class="line">        &quot;src/init.c&quot;,</span><br><span class="line">        &quot;src/input.c&quot;,</span><br><span class="line">        &quot;src/monitor.c&quot;,</span><br><span class="line">        &quot;src/vulkan.c&quot;,</span><br><span class="line">        &quot;src/window.c&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	filter &quot;system:windows&quot;</span><br><span class="line">        buildoptions &#123; &quot;-std=c11&quot;, &quot;-lgdi32&quot; &#125;</span><br><span class="line">        systemversion &quot;10.0.17134.0&quot;</span><br><span class="line">        staticruntime &quot;On&quot;</span><br><span class="line">        </span><br><span class="line">        files</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;src/win32_init.c&quot;,</span><br><span class="line">            &quot;src/win32_joystick.c&quot;,</span><br><span class="line">            &quot;src/win32_monitor.c&quot;,</span><br><span class="line">            &quot;src/win32_time.c&quot;,</span><br><span class="line">            &quot;src/win32_thread.c&quot;,</span><br><span class="line">            &quot;src/win32_window.c&quot;,</span><br><span class="line">            &quot;src/wgl_context.c&quot;,</span><br><span class="line">            &quot;src/egl_context.c&quot;,</span><br><span class="line">            &quot;src/osmesa_context.c&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		defines </span><br><span class="line">		&#123; </span><br><span class="line">            &quot;_GLFW_WIN32&quot;,</span><br><span class="line">            &quot;_CRT_SECURE_NO_WARNINGS&quot;</span><br><span class="line">		&#125;</span><br><span class="line">    filter &#123; &quot;system:windows&quot;, &quot;configurations:Release&quot; &#125;</span><br><span class="line">        buildoptions &quot;/MT&quot;</span><br></pre></td></tr></table></figure>

<p><strong>给项目添加GLFW代码</strong><br><img src="/../../image/Pasted%20image%2020230905010507.png"></p>
<h1 id="2-项目premake代码修改"><a href="#2-项目premake代码修改" class="headerlink" title="2.项目premake代码修改"></a>2.项目premake代码修改</h1><p><strong>增加代码，引用GLFW到Satsuki项目</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">-- Include directories relative to root folder (solution directory)</span><br><span class="line"></span><br><span class="line">IncludeDir = <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">IncludeDir<span class="punctuation">[</span><span class="string">&quot;GLFW&quot;</span><span class="punctuation">]</span> = <span class="string">&quot;Satsuki/vendor/GLFW/include&quot;</span></span><br><span class="line"></span><br><span class="line">include <span class="string">&quot;Satsuki/vendor/GLFW&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>include “Satsuki&#x2F;vendor&#x2F;GLFW”<ul>
<li>将GLFW中的premake代码直接粘贴到这个位置；</li>
</ul>
</li>
<li>IncludeDir[“GLFW”] &#x3D; “Satsuki&#x2F;vendor&#x2F;GLFW&#x2F;include”<ul>
<li>增加编译时引用的路径；</li>
</ul>
</li>
</ul>
<p><strong>link设置</strong><br>GLFW作为静态链接库，被项目引用；</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">includedirs</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="string">&quot;%&#123;prj.name&#125;/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;%&#123;prj.name&#125;/vendor/spdlog/include&quot;</span></span><br><span class="line">	<span class="string">&quot;%&#123;prj.name&#125;/vendor/spdlog/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;%&#123;IncludeDir.GLFW&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">links</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;GLFW&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;opengl32.lib&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="3-Window-代码设计与实现"><a href="#3-Window-代码设计与实现" class="headerlink" title="3.Window 代码设计与实现"></a>3.Window 代码设计与实现</h1><h2 id="3-1-抽象-Window-类实现"><a href="#3-1-抽象-Window-类实现" class="headerlink" title="3.1 抽象 Window 类实现"></a>3.1 抽象 Window 类实现</h2><p><strong>Windows 类解析</strong><br>此类的作用是用于被其他具体的平台实现，因此都是抽象函数或者函数指针，并不实际拥有数据；</p>
<ul>
<li>回调函数<ul>
<li>在 Windows 类当中，有一个 EventCallbackFn 函数指针；</li>
</ul>
</li>
<li>Create 函数<ul>
<li>等待被实现，用于在不同的平台创建 Window ；</li>
</ul>
</li>
<li>其余都是抽象接口，等待被实现</li>
</ul>
<p><strong>WindowProps 类</strong><br>用于存储和 Window 相关的属性数据；</p>
<ul>
<li>标题</li>
<li>高度、宽度</li>
<li>默认属性</li>
</ul>
<p>完整 Window.h 代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;skpch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Satsuki/Core.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Events/Event.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Satsuki &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">WindowProps</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::string Title;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> Width;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> Height;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">WindowProps</span>(<span class="type">const</span> std::string&amp; title = <span class="string">&quot;Satsuki Engine&quot;</span>,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> width = <span class="number">1280</span>,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> height = <span class="number">720</span>)</span><br><span class="line">			: <span class="built_in">Title</span>(title), <span class="built_in">Width</span>(width), <span class="built_in">Height</span>(height)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Interface representing a desktop system based Window</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> Window</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">using</span> EventCallbackFn = std::function&lt;<span class="built_in">void</span>(Event&amp;)&gt;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Window</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Window attributes</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetEventCallback</span><span class="params">(<span class="type">const</span> EventCallbackFn&amp; callback)</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetVSync</span><span class="params">(<span class="type">bool</span> enabled)</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsVSync</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">static</span> Window* <span class="title">Create</span><span class="params">(<span class="type">const</span> WindowProps&amp; props = WindowProps())</span></span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-Windows-Window-具体类实现"><a href="#3-2-Windows-Window-具体类实现" class="headerlink" title="3.2 Windows Window 具体类实现"></a>3.2 Windows Window 具体类实现</h2><p><strong>Window Data 结构体</strong><br>用于传输 Window 的数据，并且可以将其传入 GLFW 当中；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">WindowData</span></span><br><span class="line">&#123;</span><br><span class="line">	std::string Title;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> Width, Height;</span><br><span class="line">	<span class="type">bool</span> VSync;</span><br><span class="line"></span><br><span class="line">	EventCallbackFn EventCallback;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>WindowsWindow 类（头文件）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Satsuki/Window.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Satsuki &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">WindowsWindow</span> : <span class="keyword">public</span> Window</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">WindowsWindow</span>(<span class="type">const</span> WindowProps&amp; props);</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">WindowsWindow</span>();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_Data.Width; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_Data.Height; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Window attributes</span></span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SetEventCallback</span><span class="params">(<span class="type">const</span> EventCallbackFn&amp; callback)</span> <span class="keyword">override</span> </span>&#123; m_Data.EventCallback = callback; &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">SetVSync</span><span class="params">(<span class="type">bool</span> enabled)</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">IsVSync</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		GLFWwindow* m_Window;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">WindowData</span></span><br><span class="line">		&#123;</span><br><span class="line">			std::string Title;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> Width, Height;</span><br><span class="line">			<span class="type">bool</span> VSync;</span><br><span class="line"></span><br><span class="line">			EventCallbackFn EventCallback;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		WindowData m_Data;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>WindowsWindow 类实现（CPP 文件）</strong></p>
<ul>
<li>Create 函数实现<ul>
<li>返回一个具体的 WindowsWindow 类的实例；</li>
</ul>
</li>
<li>构造函数<ul>
<li>实例化一个 WindowsWindow 的 Proc ；</li>
</ul>
</li>
<li>Init 函数<ul>
<li>设置基础的属性；</li>
<li>虽然需要创建多个窗口，但需要保证 GLFW 只被实例化一次；<br>创建一个 Window 在 GLFW 中：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_Window = <span class="built_in">glfwCreateWindow</span>((<span class="type">int</span>)props.Width, (<span class="type">int</span>)props.Height, m_Data.Title.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(m_Window);</span><br><span class="line"><span class="built_in">glfwSetWindowUserPointer</span>(m_Window, &amp;m_Data);</span><br><span class="line"><span class="built_in">SetVSync</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>以下是完整代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;skpch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;WindowsWindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Satsuki/Log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Satsuki &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">bool</span> s_GLFWInitialized = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Window* <span class="title">Window::Create</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsWindow</span>(props);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	WindowsWindow::<span class="built_in">WindowsWindow</span>(<span class="type">const</span> WindowProps&amp; props)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Init</span>(props);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	WindowsWindow::~<span class="built_in">WindowsWindow</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Shutdown</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WindowsWindow::Init</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Data.Title = props.Title;</span><br><span class="line">		m_Data.Width = props.Width;</span><br><span class="line">		m_Data.Height = props.Height;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">SK_CORE_INFO</span>(<span class="string">&quot;Creating window &#123;0&#125; (&#123;1&#125;, &#123;2&#125;)&quot;</span>, props.Title, props.Width, props.Height);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!s_GLFWInitialized)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> glfwTerminate on system shutdown</span></span><br><span class="line">			<span class="type">int</span> success = <span class="built_in">glfwInit</span>();</span><br><span class="line">			<span class="built_in">SK_CORE_ASSERT</span>(success, <span class="string">&quot;Could not intialize GLFW!&quot;</span>);</span><br><span class="line"></span><br><span class="line">			s_GLFWInitialized = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		m_Window = <span class="built_in">glfwCreateWindow</span>((<span class="type">int</span>)props.Width, (<span class="type">int</span>)props.Height, m_Data.Title.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">		<span class="built_in">glfwMakeContextCurrent</span>(m_Window);</span><br><span class="line">		<span class="built_in">glfwSetWindowUserPointer</span>(m_Window, &amp;m_Data);</span><br><span class="line">		<span class="built_in">SetVSync</span>(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WindowsWindow::Shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">glfwDestroyWindow</span>(m_Window);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WindowsWindow::OnUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(m_Window);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WindowsWindow::SetVSync</span><span class="params">(<span class="type">bool</span> enabled)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (enabled)</span><br><span class="line">			<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">glfwSwapInterval</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		m_Data.VSync = enabled;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">WindowsWindow::IsVSync</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Data.VSync;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-1-补充：ASSERT-与-Log-h"><a href="#3-2-1-补充：ASSERT-与-Log-h" class="headerlink" title="3.2.1 补充：ASSERT 与 Log.h"></a>3.2.1 补充：ASSERT 与 Log.h</h3><p>新增加的输出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SK_ENABLE_ASSERTS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SK_ASSERT(x, ...) &#123; <span class="keyword">if</span>(!(x)) &#123; SK_ERROR(<span class="string">&quot;Assertion Failed: &#123;0&#125;&quot;</span>, __VA_ARGS__); __debugbreak(); &#125; &#125;</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SK_CORE_ASSERT(x, ...) &#123; <span class="keyword">if</span>(!(x)) &#123; SK_CORE_ERROR(<span class="string">&quot;Assertion Failed: &#123;0&#125;&quot;</span>, __VA_ARGS__); __debugbreak(); &#125; &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SK_ASSERT(x, ...)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SK_CORE_ASSERT(x, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>内容</strong><br>判断 Assert 当中的 bool 数值是否为假，如果为假，则输出 Asseertion Failed 信息（参数中传入的信息），并且打一个断电（break）；</p>
<ul>
<li>并且可以轻松的设置，通过 <code>ifdef</code> 代码，可以实现轻松在 Debug 模式和 Release 模式之间的切换，去掉所有的 Asseertion 语句；</li>
</ul>
]]></content>
      <categories>
        <category>游戏引擎</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
        <tag>C++</tag>
        <tag>OpenGL</tag>
        <tag>GLFW</tag>
      </tags>
  </entry>
  <entry>
    <title>【Game Engine】P2：Precompiled Header</title>
    <url>/2023/08/d5920372157c.html</url>
    <content><![CDATA[<p>很多代码当中都会有include其他库的代码，可以把这部分代码全部写在一个.h文件当中，并统一的为项目添加。</p>
<span id="more"></span>
<h1 id="1-编写预编译头"><a href="#1-编写预编译头" class="headerlink" title="1.编写预编译头"></a>1.编写预编译头</h1><p><strong>C++中的PCH</strong><br>很多代码当中都会有include其他库的代码，可以把这部分代码全部写在一个.h文件当中，并统一的为项目添加。以下是负责的.h代码；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HZ_PLATFORM_WINDOWS</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="2-将预编译头内容加入到premake"><a href="#2-将预编译头内容加入到premake" class="headerlink" title="2.将预编译头内容加入到premake"></a>2.将预编译头内容加入到premake</h1><p>加入到Premake中<br>需要把内容加入到premake当中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">project <span class="string">&quot;Satsuki&quot;</span></span><br><span class="line"></span><br><span class="line">    location <span class="string">&quot;Satsuki&quot;</span></span><br><span class="line"></span><br><span class="line">    kind <span class="string">&quot;SharedLib&quot;</span></span><br><span class="line"></span><br><span class="line">    language <span class="string">&quot;C++&quot;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">targetdir</span> (<span class="string">&quot;bin/&quot;</span>..outputdir..<span class="string">&quot;/%&#123;prj.name&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">objdir</span> (<span class="string">&quot;bin-int/&quot;</span>..outputdir..<span class="string">&quot;/%&#123;prj.name&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    pchheader <span class="string">&quot;skpch.h&quot;</span></span><br><span class="line"></span><br><span class="line">    pchsource <span class="string">&quot;Satsuki/src/skpch&quot;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    files</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;%&#123;prj.name&#125;/src/**.h&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;%&#123;prj.name&#125;/src/**.cpp&quot;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    includedirs</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;%&#123;prj.name&#125;/src&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;%&#123;prj.name&#125;/vendor/spdlog/include&quot;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>游戏引擎</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
        <tag>C++</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏引擎原理】P1：GPU驱动的几何管线</title>
    <url>/2023/08/fd049e549b6a.html</url>
    <content><![CDATA[<p>传统渲染问题：<br>在CPU端发出一个Draw Call，在此过程中GPU可能会一直在等待Draw Call，因此浪费大量性能；<br>在GPU中设置好数据，还要在CPU中处理各种计算，而且GPU要花费大量的时间在等待CPU的时间中，因为就算是计算一个非常简单的index，也需要把整个Render跑一遍。</p>
<span id="more"></span>
<h2 id="1-传统渲染管线"><a href="#1-传统渲染管线" class="headerlink" title="1 传统渲染管线"></a>1 传统渲染管线</h2><h3 id="1-1-传统渲染问题"><a href="#1-1-传统渲染问题" class="headerlink" title="1.1 传统渲染问题"></a>1.1 传统渲染问题</h3><p><strong>核心：所有的需求是在CPU那端发起</strong><br>在CPU端发出一个Draw Call，在此过程中GPU可能会一直在等待Draw Call，因此浪费大量性能；<br>在GPU中设置好数据，还要在CPU中处理各种计算，而且GPU要花费大量的时间在等待CPU的时间中，因为就算是计算一个非常简单的index，也需要把整个Render跑一遍。<br><strong>Draw Graphics API</strong><br>传统渲染管线跑现代游戏无法满足，现代CPU得先把数据准备好，然后再把数据给到GPU；</p>
<h3 id="1-2-Compute-Shader与GPU驱动管线"><a href="#1-2-Compute-Shader与GPU驱动管线" class="headerlink" title="1.2 Compute Shader与GPU驱动管线"></a>1.2 Compute Shader与GPU驱动管线</h3><p><strong>Compute Shader核心概念</strong><br>计算机不需要再CPU和GPU中来回导数据，所有的计算都在GPU的内部；<br>方法：</p>
<ol>
<li>在GPU中内置一些计算模块，很多计算直接在GPU中完成；把很多只有在CPU中才可以做的通用计算放到GPU上面；</li>
<li>单个Draw Call可以绘制多个Mesh；</li>
</ol>
<p><strong>更加进阶的状态：GPU驱动Render管线</strong><br>GPU控制什么对象该被实际的渲染，包括Lod Selection，Visibility Culling On GPU<br>CPU不触碰GPU的数据，尽量让CPU不那么忙；</p>
<p><strong>GPU驱动Render管线在材质中应用</strong><br>在《刺客信条大革命》中大场景的渲染，大场景当中有大量不可见的物体以及材质；</p>
<ul>
<li>解决方法<ul>
<li>对每个游戏世界中的物体，按照其Mesh把其分成无数个小的Clusters，计算这个小Clusters是否被遮挡</li>
<li>因为这种小粒度的Cluster在GPU中可以被批量处理，因此实际上性能更高，对于三角形有尽可能高的利用率；</li>
</ul>
</li>
</ul>
<p><strong>GPU驱动Pipeline概述</strong><br>流程图：<br><img src="/../../image/Pasted%20image%2020230827161631.png"></p>
<p>CPU阶段进行粗略的Culling，在GPU阶段进行更加精细的Culling，每一个物体被分成不同的Cluster，然后打包进一个非常大的Index Buffer当中。最后一个Draw Call一次性完成计算。<br>核心：通过前面GPU一大堆的计算，一次性将不可见的几何完成绘制；</p>
<p><strong>Work in CPU Side</strong><br>在CPU端只需要</p>
<h2 id="2-Occlusion-Culling与相机以及阴影"><a href="#2-Occlusion-Culling与相机以及阴影" class="headerlink" title="2 Occlusion Culling与相机以及阴影"></a>2 Occlusion Culling与相机以及阴影</h2><p>如何将观测或者光照不到的地方的渲染变得尽可能廉价；</p>
<p><strong>核心概念</strong><br>对于所有基于Cluster渲染的管线而言，Occlusion的计算都是十分关键的部分；<br>而Occlusion的基本思想，就是尽可能快速且低成本的基于当前相机的位置构建index buffer，类似于形成了一层幕布；当想渲染任何一个物体的时候，使用cluster渲染时使用这个index buffer在GPU中快速进行测试，快速将不需要渲染的部分剔除掉；</p>
<h3 id="2-1-Occlusion-Depth-Generation"><a href="#2-1-Occlusion-Depth-Generation" class="headerlink" title="2.1 Occlusion Depth Generation"></a>2.1 Occlusion Depth Generation</h3><p>遮挡深度生成：这个根据场景生成的Depth Buffer可以被重用；</p>
<p><strong>深度Pre-Pass与最好的Occluders在完整的像素当中</strong></p>
<ol>
<li>选择最好的occluders通过艺术资源或者heuristic</li>
<li>重新计算occluder</li>
<li>合并以及重投影与十六分之一的像素版本；</li>
<li>生成Z-Buffer用于GPU Culling计算；</li>
</ol>
<p><strong>两个阶段的Occlusion Culling</strong><br>第一阶段：把上一帧里面的所有物体，依据Z buffer数据测试一遍，对所有通过上一帧Z-Buffer的物体先绘制一遍；把可能可见的物体先跑一遍得出画面；<br>问题：此时得出的z很有可能是错误的，此时应该把所有认为可能不可见的物体也测试一遍Z-Buffer<br>第二阶段：在第一阶段过滤完之后，重新再测试一遍被忽略掉的物体，从而减少大量的渲染量，准确并且高效完成；<br><img src="/../../image/Pasted%20image%2020230827161702.png"></p>
<h3 id="2-2-可视化内容处理渲染管线"><a href="#2-2-可视化内容处理渲染管线" class="headerlink" title="2.2 可视化内容处理渲染管线"></a>2.2 可视化内容处理渲染管线</h3><p><strong>Visiblity Buffer</strong><br>Visiblity Buffer是一种新的越来越瘦关注的Buffer；<br>如果使用传统的Shading，每一次渲染都需要全部进行处理，处理的数据量非常大，因此可以把这些Texture可以全部打包放到一个Shading当中</p>
<p><strong>Deferred Shading 与 G-Buffer 存在的意义与问题</strong><br>Deffered Shading：在Deferred Shader中处理很多三角形的场景时，其不会保证优先绘制靠近相机的物体，因此对于同一个像素可能会渲染十几次，因为在这个像素上可能会有多个物体在其射线上；<br>大量的对G-Buffer的读写会产生大量的性能浪费；</p>
<p><strong>Visiblity Buffer</strong><br>解决方法：在第一帧渲染的时候，就只把几何数据渲染进去，而不是把Texture等其他数据全部在第一帧弄进去；在获得了这些几何体的位置信息后，再将其手动的把每个顶点该有的信息输入进去；<br>Shading阶段时，把几何体的每个像素位置拿到，反算出来其像素点应该有的反射率等信息，接下来对其进行Shading；<br>其非常适合在场景当中有大量的小物体，而且这些物体经常会被其他物体遮挡住；</p>
<p><strong>Visiblity Buffer与Deferred Shading结合</strong><br>将Visiblity和G-Buffer结合，G-Buffer的数据可以来自于传统渲染管线，也可以来自于Visiblity Buffer渲染管线；</p>
<h2 id="3-Nanite"><a href="#3-Nanite" class="headerlink" title="3 Nanite"></a>3 Nanite</h2><h3 id="3-1-前言"><a href="#3-1-前言" class="headerlink" title="3.1 前言"></a>3.1 前言</h3><p><strong>要解决的问题</strong><br>每个做Render的目标：在虚拟世界中还原现实世界，但现实世界中具有无限的几何细节。实时渲染的人希望在游戏当中实现无限的几何细节；</p>
<p><strong>Nanite基本的源头：Virtual Texture</strong><br>在真实的游戏场景当中拥有大量的texture，在游戏引擎中提出Virtual Texture的思想，即在游戏当中、离Camera的Texture精度高，离Camera远的Texture精度低；即先形成一大张的Virtual Texture；</p>
<p><strong>进一步推到：把几何Geometry也变成Virtual Map</strong><br>需要有一个方法把几何也变成Virtual Map；但这个过程十分困难，因为几何信息的处理比Texture困难很多；</p>
<ul>
<li>Voxels方法？<ul>
<li>难以表达高精度内容</li>
<li>数据量惊人</li>
<li>而且目前主流的艺术资产都不是基于Voxel表达的</li>
</ul>
</li>
<li>Subdivision Surfaces？<ul>
<li>增加几何的精细度</li>
<li>在实时给几何体细分表面</li>
</ul>
</li>
<li>Map-Based Method?<ul>
<li>难以表达表面特性</li>
<li>基于硬件的加密几何</li>
</ul>
</li>
</ul>
<p><strong>最后结果：基于三角形的几何构建</strong></p>
<h3 id="3-2-Virtual-Geometry"><a href="#3-2-Virtual-Geometry" class="headerlink" title="3.2 Virtual Geometry"></a>3.2 Virtual Geometry</h3><p><strong>Nanite中的几何表达</strong><br>无论增加多少的几何复杂度，屏幕上能够展示的几何数量终归是有限的，有像素上有一个或两个三角形就够了；<br>可以通过屏幕像素的精度来决定几何物体的精度；</p>
<ul>
<li>基于Cluster的几何表达<ul>
<li>将几何体分成不同的Cluster</li>
<li>让其根据View来决定Cluster的精度，不同的LOD在Cluster中具有不同的精度</li>
<li>对于屏幕空间最大化的利用<br><img src="/../../image/Pasted%20image%2020230827161729.png"></li>
</ul>
</li>
</ul>
<p><strong>Nanite的Cluster细分方法</strong><br>根据View的距离情况，根据LOD进行Cluster的简化，将其合成一份Cluster；<br>因此可以在游戏进行时，可以根据View距离加载不同的LOD；<br><strong>Cluster合并的问题</strong><br>不同LOD等级的物体之间衔接的时候会有问题，即本来是根据同一LOD构建出的几何体现在有部分表面其Cluster变成其他LOD是，分界处衔接有问题；<br>解决方法：把边给锁住；在边缘一直锁着LOD0的边；但是锁边的时候这些边的三角形数量也很高；并且因为人眼对于高频的信号感受力很强，因此对于这种边缘处突然出现的高频信号会有反应；</p>
<p><strong>对Cluster合并问题的解决：Cluster Group</strong><br>只缩Cluster Group的边，里面的Cluster再随意的去简化；<br>保证了在LOD切换的时候，不会在衔接处明显变化；<br>其希望被锁住的LOD的边在切换的时候不会注意到被缩边的Cluster Group;<br>如图是Cluster Group在不同LOD时变化：<br>乱中有序：底层的Cluster上层可能有多个，并且不会和上层的所有Cluster都产生关系；<br><img src="/../../image/Pasted%20image%2020230827161745.png"></p>
<h3 id="3-3-QEM"><a href="#3-3-QEM" class="headerlink" title="3.3 QEM"></a>3.3 QEM</h3><p>形成Cluster Group的流水线；<br><strong>LOD Selection For Cluster Group In Paralllel</strong><br>能不能让LOD的Selection可不可以被并行化，从左到右或者从右到左的遍历都有可能是不稳定的；<br>把Cluster节点组成的树状的LOD，变成数组的线性的LOD（通过把Cluster其对应父节点的信息存储进来）</p>
<ul>
<li>希望是独立的决策</li>
</ul>
]]></content>
      <categories>
        <category>游戏引擎</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
        <tag>技术美术</tag>
      </tags>
  </entry>
</search>
