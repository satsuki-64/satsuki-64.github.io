<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AI时代个人生存指南</title>
    <url>/2023/08/62011fb26306.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<ul>
<li><ol>
<li>ChatGPT使用基础</li>
</ol>
<ul>
<li>1.1 ChatGPT的使用之道</li>
<li>1.2 ChatGPT的使用之术</li>
</ul>
</li>
<li><ol start="2">
<li>Midjourney使用基础</li>
</ol>
<ul>
<li>2.1 Midjourney的使用之道</li>
<li>2.2 Midjourney的使用之术<span id="more"></span></li>
</ul>
</li>
</ul>
<h1 id="1-Chat-GPT使用基础"><a href="#1-Chat-GPT使用基础" class="headerlink" title="1.Chat GPT使用基础"></a>1.Chat GPT使用基础</h1><p><strong>核心思想：拥抱AI，理解AI，成为AI</strong></p>
<ul>
<li>拥抱AI<ul>
<li>率先掌握AI技能，掌握竞争优势；</li>
</ul>
</li>
<li>理解AI<ul>
<li>知道AI的能力，知道AI能做什么；</li>
<li>同时反推自己的发展方向：AI不能做什么，就是人未来能做的事情；</li>
</ul>
</li>
<li>成为AI<ul>
<li>率先向AI学习，让自己的思维和AI同步；</li>
<li>谁和AI最像，谁就获得了第一批AI带来的绝对优势；</li>
</ul>
</li>
</ul>
<h2 id="1-1-ChatGPT的使用之道"><a href="#1-1-ChatGPT的使用之道" class="headerlink" title="1.1 ChatGPT的使用之道"></a>1.1 ChatGPT的使用之道</h2><p><strong>前言：关于prompt</strong><br>虽然目前依然需要使用prompt来辅助AI，但未来的AI发展是其越来越理解人类想要什么，而不需要使用prompt来提示；</p>
<blockquote>
<p><em>prompt教程推荐：吴恩达的prompt视频（适合程序员）：<br><a class="link"   href="https://www.bilibili.com/video/BV1Z14y1Z7LJ/?spm_id_from=333.337.search-card.all.click&vd_source=3f70c2a1700b0323e22826080d18a119" >https://www.bilibili.com/video/BV1Z14y1Z7LJ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3f70c2a1700b0323e22826080d18a119 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></em></p>
</blockquote>
<p><strong>概念：ChatGPT能做什么</strong><br>首先思考AI能做什么，在了解AI能做的事情的情况下，再思考应该让它如何做这件事情；<br>AI的画像：<strong>一个学习过网上所有知识，保守而道德的名校大学生。理性思考5秒钟，回答10句话。</strong></p>
<ul>
<li>知识：只存留在2021年；</li>
<li>保守：没有独特思想；</li>
<li>道德：有人类设定的道德包袱；</li>
<li>名校本科生水平：不接受过于复杂的问题，可以回答大部分知识问题；</li>
<li>理性思考5秒钟：不能接受过度复杂问题；</li>
</ul>
<p><strong>道一：Chat GPT的道德</strong><br>AI的回答是很道德的回答。当和价值立场或者观点相关的问题时，只会给出不同的立场，而不表达观点；</p>
<ul>
<li>甚至会出现<strong>道德在事实之上</strong>；</li>
<li>为了保证道德的限制，甚至让道德在事实之上；<br><em>或许道德极大的限制了LLM的能力。</em></li>
</ul>
<p><strong>道二：Chat GPT的知识</strong><br>一般本科大学生的知识它都会；并且理解能力强。</p>
<p><strong>道三：Chat GPT的提问</strong><br>对于提问，遵循两个原则：<strong>拆分、直接</strong>；</p>
<ul>
<li>直接：<ul>
<li>提问不能太复杂，但是可以很困难；</li>
</ul>
</li>
<li>拆分：<ul>
<li>回答内容不能太长，所以一开始就设计多个问题，对各个部分拆分提问；</li>
<li>对很长内容的提问：先提问大纲内容，再对每个大纲的细分内容进行提问；</li>
</ul>
</li>
</ul>
<p><strong>道四：面对AI的幻觉</strong><br>AI是语言生成模型，即按照上一句话生成下一句话；</p>
<ul>
<li>AI会出现强行回答，AI自己也无法分辨真假；</li>
<li>如何面对AI回答的幻觉：<ul>
<li>逻辑推演；</li>
<li>拥有常识；</li>
<li>自行验证；</li>
</ul>
</li>
</ul>
<p><strong>道五：把寻找和使用AI工具，纳入接受新工作的思考流程</strong><br>在接受一份新工作的时候，首先就可以想一想：当中有哪些工作是AI可以做的；并且把它纳入到生成流程当中。</p>
<p><strong>补充：AI大模型的数据截止到2021年</strong><br>在2021年之前的数据，在LLM当中都有；但2021年之后的数据，AI自己也需要去查（通过OpenAI的服务器去访问这些网站）；</p>
<p><strong>应用场合</strong></p>
<ul>
<li>文字工作<ul>
<li>套路文章创作，润色，翻译，取标题，举例子</li>
</ul>
</li>
<li>生活助手<ul>
<li>普通问题咨询</li>
</ul>
</li>
</ul>
<h2 id="1-2-ChatGPT的使用之术"><a href="#1-2-ChatGPT的使用之术" class="headerlink" title="1.2 ChatGPT的使用之术"></a>1.2 ChatGPT的使用之术</h2><p><strong>术一：描述好背景信息</strong><br>在向AI咨询一个问题前，一定要先描述好问题的背景信息；<br>如果不清楚描述什么背景，可以<strong>向AI提问，这个问题需要了解什么背景信息</strong>；</p>
<p><strong>术二：提问计算方法，再得到结果</strong><br>如果直接问AI一个问题的答案，AI可能难以回答。但是如果提问AI一个问题的计算方法，AI的回答正确率更高；</p>
<ul>
<li>AI知道计算的方法，但不擅长计算</li>
<li>对AI进行复杂计算的提问：可以<strong>先问过程，再顺着过程问答案</strong>；</li>
</ul>
<p><strong>术三：让他扮演一个角色</strong><br>让他扮演一个角色，作为一个角色来回答你的问题；<br><em>你现是一个作家、你现在是一个软件公司的文案总监、你现在是一个法律顾问</em></p>
<h1 id="2-Midjourney使用基础"><a href="#2-Midjourney使用基础" class="headerlink" title="2.Midjourney使用基础"></a>2.Midjourney使用基础</h1><h2 id="2-1-Midjourney使用之道"><a href="#2-1-Midjourney使用之道" class="headerlink" title="2.1 Midjourney使用之道"></a>2.1 Midjourney使用之道</h2><p><strong>道一：创作具有艺术感的图像</strong><br>AI绘画可以模仿多种艺术风格，创造性的运用绘画技巧，并进行独特的构图和色彩搭配；</p>
<p><strong>道二：难以处理复杂边缘、空间关系的物体</strong><br>这与扩散模型的原理有关。现阶段，扩散模型可学习的样本图片的清晰度普遍较低，导致模型在处理某些细节时需要进行“猜测”。因此，我们常常发现AI绘制的手指存在错误，其他具有复杂边缘的物体也存在同样的问题。另外，扩散模型并非从空间角度理解图像，因此在处理物体间复杂的空间关系时，AI可能会遇到困难</p>
<p><strong>道三：难以同时绘制多个对象，并且每个对象有不同的属性</strong><br>AI可能无法准确理解多个对象和这些对象之间的属性关系，或者可能会忽略掉一些关键属性。 </p>
<h2 id="2-2-Midjourney使用之术"><a href="#2-2-Midjourney使用之术" class="headerlink" title="2.2 Midjourney使用之术"></a>2.2 Midjourney使用之术</h2><p><strong>术一：Prompt能力</strong><br>使用明确且具体的语言，来描述任务；</p>
<p><strong>术二：用尽可能清晰的语言</strong><br>Midjourney的语言文字理解能力不如Chat GPT；</p>
<p><strong>术三：工具本身的熟练程度</strong></p>
<ul>
<li>设置宽高比；</li>
<li>混乱程度；</li>
<li>使用种子；</li>
</ul>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 10：状态机模型的应用</title>
    <url>/2023/08/f8b821c31d0a.html</url>
    <content><![CDATA[<ul>
<li>状态机的确定性<ul>
<li>概念<ul>
<li>每一个状态都有一个确定的下一个状态</li>
<li>不确定的状态机，状态之后会有不同的分支状态</li>
</ul>
</li>
<li>宏观物理世界<ul>
<li>近似于决定性的状态机，状态之间用于牛顿机械式的逻辑关系</li>
<li>例子：Game Of Life</li>
</ul>
</li>
<li>微观物理世界<span id="more"></span></li>
</ul>
</li>
</ul>
<h2 id="10-1-状态机模型的物理世界应用"><a href="#10-1-状态机模型的物理世界应用" class="headerlink" title="10.1 状态机模型的物理世界应用"></a>10.1 状态机模型的物理世界应用</h2><h3 id="10-1-1-世界状态的确定性分析"><a href="#10-1-1-世界状态的确定性分析" class="headerlink" title="10.1.1 世界状态的确定性分析"></a>10.1.1 世界状态的确定性分析</h3><ul>
<li>状态机的确定性<ul>
<li>概念<ul>
<li>每一个状态都有一个确定的下一个状态</li>
<li>不确定的状态机，状态之后会有不同的分支状态</li>
</ul>
</li>
<li>宏观物理世界<ul>
<li>近似于决定性的状态机，状态之间用于牛顿机械式的逻辑关系</li>
<li>例子：Game Of Life</li>
</ul>
</li>
<li>微观物理世界</li>
</ul>
</li>
</ul>
<h3 id="10-1-2-状态机模型的应用"><a href="#10-1-2-状态机模型的应用" class="headerlink" title="10.1.2 状态机模型的应用"></a>10.1.2 状态机模型的应用</h3><p>这里不知道为什么会出现问题。。。</p>
<h2 id="在决定性的数学公理体系下，状态机模型的使用1-数学严谨的体系下，解释平行宇宙2-细胞的状态分析与还原"><a href="#在决定性的数学公理体系下，状态机模型的使用1-数学严谨的体系下，解释平行宇宙2-细胞的状态分析与还原" class="headerlink" title="在决定性的数学公理体系下，状态机模型的使用1. 数学严谨的体系下，解释平行宇宙2. 细胞的状态分析与还原"></a>在决定性的数学公理体系下，状态机模型的使用<br>1. 数学严谨的体系下，解释平行宇宙<br>2. 细胞的状态分析与还原</h2><h2 id="10-2-状态机模型下的编译器和现代CPU"><a href="#10-2-状态机模型下的编译器和现代CPU" class="headerlink" title="10.2 状态机模型下的编译器和现代CPU"></a>10.2 状态机模型下的编译器和现代CPU</h2><h3 id="10-2-1-编译器模型"><a href="#10-2-1-编译器模型" class="headerlink" title="10.2.1 编译器模型"></a>10.2.1 编译器模型</h3><h2 id="编译器：从源代码S（状态机）-二进制代码C（状态机）在不同的SystemCall之中，保证语义一致性（保证结果的最终一致）-10-2-2-编译器优化的正确性核心：源代码状态机和二进制状态机的可观测行为的一致性例子：现代的CPU在一个时钟周期当中可以执行两条指令甚至更多-10-2-3-查看状态机执行程序执行-状态机执行例子：通过strace观测系统调用的行为以及所花费的时间。-查看所有的状态机行为-方法：使用GDB进行调试-单步调试-反汇编调试-通过调试器展示的状态的一部分-寄存器-内存-变量状态机视角下，Debug可进行的行为：1-复制当前状态机的状态2-回溯状态机的上一个状态3-进入状态机的下一个状态4-记录一个状态机的完整执行-状态机的状态回溯-概念：-虽然当前程序的状态机的状态可能十分复杂，但是在不同指令之间进行执行时，如果只是将指令的行为记录下来，即可回走-每次状态切换时更改的内容有效-例子：-在一个用于随机情况的方法条件下，可以通过gcc的record将状态记录下来-，当想要还原这个随机性的Bug时只需要恢复当时的状态即可实现-记录状态机的完整执行-决定性程序：-如果程序是完全决定性的，只要程序的初始状态知道，之后的状态都可以据此由此复现出来-拥有系统调用、Random的程序：-待记录内容：-1-指令数-2-结果-3-n份以上内容-可使用此功能-指令：-rr-record-想记录下函数的全部行为：-需要知道从上一条指令到下一条指令有多少决定性的指-令-程序的io-程序的中断-程序可以完整的记录程序的执行-例子：老游戏的replay"><a href="#编译器：从源代码S（状态机）-二进制代码C（状态机）在不同的SystemCall之中，保证语义一致性（保证结果的最终一致）-10-2-2-编译器优化的正确性核心：源代码状态机和二进制状态机的可观测行为的一致性例子：现代的CPU在一个时钟周期当中可以执行两条指令甚至更多-10-2-3-查看状态机执行程序执行-状态机执行例子：通过strace观测系统调用的行为以及所花费的时间。-查看所有的状态机行为-方法：使用GDB进行调试-单步调试-反汇编调试-通过调试器展示的状态的一部分-寄存器-内存-变量状态机视角下，Debug可进行的行为：1-复制当前状态机的状态2-回溯状态机的上一个状态3-进入状态机的下一个状态4-记录一个状态机的完整执行-状态机的状态回溯-概念：-虽然当前程序的状态机的状态可能十分复杂，但是在不同指令之间进行执行时，如果只是将指令的行为记录下来，即可回走-每次状态切换时更改的内容有效-例子：-在一个用于随机情况的方法条件下，可以通过gcc的record将状态记录下来-，当想要还原这个随机性的Bug时只需要恢复当时的状态即可实现-记录状态机的完整执行-决定性程序：-如果程序是完全决定性的，只要程序的初始状态知道，之后的状态都可以据此由此复现出来-拥有系统调用、Random的程序：-待记录内容：-1-指令数-2-结果-3-n份以上内容-可使用此功能-指令：-rr-record-想记录下函数的全部行为：-需要知道从上一条指令到下一条指令有多少决定性的指-令-程序的io-程序的中断-程序可以完整的记录程序的执行-例子：老游戏的replay" class="headerlink" title="编译器：从源代码S（状态机）-&gt; 二进制代码C（状态机）在不同的SystemCall之中，保证语义一致性（保证结果的最终一致）### 10.2.2 编译器优化的正确性核心：源代码状态机和二进制状态机的可观测行为的一致性例子：现代的CPU在一个时钟周期当中可以执行两条指令甚至更多### 10.2.3 查看状态机执行程序执行 &#x3D; 状态机执行例子：通过strace观测系统调用的行为以及所花费的时间。+ 查看所有的状态机行为    + 方法：使用GDB进行调试        + 单步调试        + 反汇编调试    + 通过调试器展示的状态的一部分        + 寄存器        + 内存        + 变量状态机视角下，Debug可进行的行为：1. 复制当前状态机的状态2. 回溯状态机的上一个状态3. 进入状态机的下一个状态4. 记录一个状态机的完整执行+ 状态机的状态回溯    + 概念：        + 虽然当前程序的状态机的状态可能十分复杂，但是在不同指令之间进行执行时，如果只是将指令的行为记录下来，即可回走        + 每次状态切换时更改的内容有效    + 例子：        + 在一个用于随机情况的方法条件下，可以通过gcc的record将状态记录下来 ，当想要还原这个随机性的Bug时只需要恢复当时的状态即可实现+ 记录状态机的完整执行    + 决定性程序：        + 如果程序是完全决定性的，只要程序的初始状态知道，之后的状态都可以据此由此复现出来    + 拥有系统调用、Random的程序：        + 待记录内容：        + 1. 指令数        + 2. 结果        + 3. n份以上内容    + 可使用此功能        + 指令：            + rr record        + 想记录下函数的全部行为：            + 需要知道从上一条指令到下一条指令有多少决定性的指 令            + 程序的io            + 程序的中断        + 程序可以完整的记录程序的执行            + 例子：老游戏的replay"></a>编译器：从源代码S（状态机）-&gt; 二进制代码C（状态机）<br>在不同的SystemCall之中，保证语义一致性（保证结果的最终一致）<br>### 10.2.2 编译器优化的正确性<br><strong>核心：源代码状态机和二进制状态机的可观测行为的一致性</strong><br>例子：现代的CPU在一个时钟周期当中可以执行两条指令甚至更多<br>### 10.2.3 查看状态机执行<br>程序执行 &#x3D; 状态机执行<br>例子：通过strace观测系统调用的行为以及所花费的时间。<br>+ 查看所有的状态机行为<br>    + 方法：使用GDB进行调试<br>        + 单步调试<br>        + 反汇编调试<br>    + 通过调试器展示的状态的一部分<br>        + 寄存器<br>        + 内存<br>        + 变量<br>状态机视角下，Debug可进行的行为：<br>1. 复制当前状态机的状态<br>2. 回溯状态机的上一个状态<br>3. 进入状态机的下一个状态<br>4. 记录一个状态机的完整执行<br>+ 状态机的状态回溯<br>    + 概念：<br>        + 虽然当前程序的状态机的状态可能十分复杂，但是在不同指令之间进行执行时，如果只是将指令的行为记录下来，即可回走<br>        + 每次状态切换时更改的内容有效<br>    + 例子：<br>        + 在一个用于随机情况的方法条件下，可以通过gcc的record将状态记录下来 ，当想要还原这个随机性的Bug时只需要恢复当时的状态即可实现<br>+ 记录状态机的完整执行<br>    + 决定性程序：<br>        + 如果程序是完全决定性的，只要程序的初始状态知道，之后的状态都可以据此由此复现出来<br>    + 拥有系统调用、Random的程序：<br>        + 待记录内容：<br>        + 1. 指令数<br>        + 2. 结果<br>        + 3. n份以上内容<br>    + 可使用此功能<br>        + 指令：<br>            + rr record<br>        + 想记录下函数的全部行为：<br>            + 需要知道从上一条指令到下一条指令有多少决定性的指 令<br>            + 程序的io<br>            + 程序的中断<br>        + 程序可以完整的记录程序的执行<br>            + 例子：老游戏的replay</h2><h2 id="10-3-状态机与性能分析"><a href="#10-3-状态机与性能分析" class="headerlink" title="10.3 状态机与性能分析"></a>10.3 状态机与性能分析</h2><h3 id="10-3-1-采样状态机的执行"><a href="#10-3-1-采样状态机的执行" class="headerlink" title="10.3.1 采样状态机的执行"></a>10.3.1 采样状态机的执行</h3><h2 id="每当想进行性能优化的时候，总是要停下来想想，当下是否适合作性能优化。性能分析的核心原则：Premature-optimization-is-the-root-of-all-exil-问题：如何在代价很低的方法下，获得程序的summary（）？即获得性能摘要-性能优化的时机-分析程序在时间和空间上的调用-时间-空间-10-3-2-Profiler和性能摘要单点调试的问题：当使用gdb单点调试时，程序需要在每个指令下停止下来，无法测算每个指令执行的速度。此时只需要关注状态机的整体行为，观察程序在某一段时间中的关键信息（CPU、GPU、内存）数据。实现此步骤的方法是：中断-中断-概念：基于中断的机制，程序此时会进入到OS的代码。此时OS的代码可以访问到程序中断前的状态，并将此状态进行采样与输出-10-3-2-1-基于gcc进行性能摘要输出当前程序性能摘要：结果：将整个程序的Profiler记录，并打开报告：获得的每一条指令的时间：-10-3-3-实际中的性能优化百分之八十的时间都消耗在了百分之二十的代码上-工业界面到的性能优化-实际情况：木桶效应-每个部分都已经优化到了局部最优解"><a href="#每当想进行性能优化的时候，总是要停下来想想，当下是否适合作性能优化。性能分析的核心原则：Premature-optimization-is-the-root-of-all-exil-问题：如何在代价很低的方法下，获得程序的summary（）？即获得性能摘要-性能优化的时机-分析程序在时间和空间上的调用-时间-空间-10-3-2-Profiler和性能摘要单点调试的问题：当使用gdb单点调试时，程序需要在每个指令下停止下来，无法测算每个指令执行的速度。此时只需要关注状态机的整体行为，观察程序在某一段时间中的关键信息（CPU、GPU、内存）数据。实现此步骤的方法是：中断-中断-概念：基于中断的机制，程序此时会进入到OS的代码。此时OS的代码可以访问到程序中断前的状态，并将此状态进行采样与输出-10-3-2-1-基于gcc进行性能摘要输出当前程序性能摘要：结果：将整个程序的Profiler记录，并打开报告：获得的每一条指令的时间：-10-3-3-实际中的性能优化百分之八十的时间都消耗在了百分之二十的代码上-工业界面到的性能优化-实际情况：木桶效应-每个部分都已经优化到了局部最优解" class="headerlink" title="每当想进行性能优化的时候，总是要停下来想想，当下是否适合作性能优化。性能分析的核心原则：Premature optimization is the root of all exil.问题：如何在代价很低的方法下，获得程序的summary（）？即获得性能摘要+ 性能优化的时机    + 分析程序在时间和空间上的调用    + 时间    + 空间### 10.3.2 Profiler和性能摘要单点调试的问题：当使用gdb单点调试时，程序需要在每个指令下停止下来，无法测算每个指令执行的速度。此时只需要关注状态机的整体行为，观察程序在某一段时间中的关键信息（CPU、GPU、内存）数据。实现此步骤的方法是：中断+ 中断    + 概念：基于中断的机制，程序此时会进入到OS的代码。此时OS的代码可以访问到程序中断前的状态，并将此状态进行采样与输出#### 10.3.2.1 基于gcc进行性能摘要输出当前程序性能摘要：结果：将整个程序的Profiler记录，并打开报告：获得的每一条指令的时间：### 10.3.3 实际中的性能优化百分之八十的时间都消耗在了百分之二十的代码上+ 工业界面到的性能优化    + 实际情况：木桶效应    + 每个部分都已经优化到了局部最优解"></a>每当想进行性能优化的时候，总是要停下来想想，当下是否适合作性能优化。<br><em>性能分析的核心原则：Premature optimization is the root of all exil.</em><br>问题：如何在代价很低的方法下，获得程序的summary（）？即获得性能摘要<br>+ 性能优化的时机<br>    + 分析程序在时间和空间上的调用<br>    + 时间<br>    + 空间<br>### 10.3.2 Profiler和性能摘要<br><strong>单点调试的问题：</strong><br>当使用gdb单点调试时，程序需要在每个指令下停止下来，无法测算每个指令执行的速度。此时只需要关注状态机的整体行为，观察程序在某一段时间中的关键信息（CPU、GPU、内存）数据。<br>实现此步骤的方法是：中断<br>+ 中断<br>    + 概念：基于中断的机制，程序此时会进入到OS的代码。此时OS的代码可以访问到程序中断前的状态，并将此状态进行采样与输出<br>#### 10.3.2.1 基于gcc进行性能摘要<br>输出当前程序性能摘要：<br><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">perf stat ./a.out </span><br></pre></td></tr></table></figure></div><br>结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829191438.png"
                     
                ><br>将整个程序的Profiler记录，并打开报告：<br><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">perf record ./a.out</span><br><span class="line">perf report</span><br></pre></td></tr></table></figure></div><br>获得的每一条指令的时间：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829191456.png"
                     
                ><br>### 10.3.3 实际中的性能优化<br>百分之八十的时间都消耗在了百分之二十的代码上<br>+ 工业界面到的性能优化<br>    + 实际情况：木桶效应<br>    + 每个部分都已经优化到了局部最优解</h2><h2 id="10-4-状态机与程序验证"><a href="#10-4-状态机与程序验证" class="headerlink" title="10.4 状态机与程序验证"></a>10.4 状态机与程序验证</h2><h3 id="10-4-1-现在的Model-Check工具"><a href="#10-4-1-现在的Model-Check工具" class="headerlink" title="10.4.1 现在的Model Check工具"></a>10.4.1 现在的Model Check工具</h3><p>概念：状态机模型可以用于证明程序的正确性。使用bfs便利所有的状态，再使用execute给定一个并发程序的调度。<br>例子：for程序的并发Bug<br>**学术界的Model Check工具</p>
<ol>
<li>NASA的Java PathFinder：把Model Check扩充到了所有的Java代码</li>
<li>Spin：只可以使用其自己定义的语言</li>
<li>TLA Plus：用于亚马逊的并发式程序的正确性验证</li>
</ol>
<ul>
<li>现在的Model Check在分布式系统上的应用<ul>
<li>并发系统：<ul>
<li>分布式系统也是一种并发系统，但是其问题更大</li>
<li>并发系统假设其所有的节点都能够正常工作</li>
</ul>
</li>
<li>分布式系统<ul>
<li>在分布式系统中，必须假设所有的节点都可能出错（丢失）</li>
<li>在节点丢失的情况下还能进行tutorial</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="10-4-2-Model-Check可以做什么"><a href="#10-4-2-Model-Check可以做什么" class="headerlink" title="10.4.2 Model Check可以做什么"></a>10.4.2 Model Check可以做什么</h3><p>当探索不确定性程序的执行时，Model Check可以检查任何程序的执行；<br>Model Check可以检测当前不确定程序的任何一种可能性，并检查出Bug。</p>
<ul>
<li>不确定<ul>
<li>输入不确定</li>
<li>随机函数不确定<br>面对不确定性程序，可以检测程序的所有可能性空间<br><strong>问题：程序的状态空间太大</strong></li>
</ul>
</li>
</ul>
<ol>
<li>如何将这个状态的可能性减少？</li>
<li>如何将状态合并？</li>
<li>如何将状态往后延迟？</li>
</ol>
<ul>
<li>状态坍缩<ul>
<li>将大量可能性的状态转换为分支，延迟状态的展开，将状态合并，直到发现Bug再将其反向展开</li>
<li>分支成立：<ul>
<li>再检测有没有分支<ul>
<li>分支成立：<ul>
<li>在检测有没有分支：<ul>
<li>分支成立：<ul>
<li>当前红色的状态是否可达？</li>
<li>用约束求解器来计算</li>
<li>计算出当前程序的状态，此状态为Bug</li>
</ul>
</li>
<li>分支不成立：</li>
</ul>
</li>
</ul>
</li>
<li>分支不成立：</li>
</ul>
</li>
</ul>
</li>
<li>分支不成立：</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>Prompt编写指南</title>
    <url>/2023/08/081ae7892f5f.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<ul>
<li><ol>
<li>基础知识</li>
</ol>
<ul>
<li>1.1 两种LLM</li>
<li>1.2 提问原则</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h1><h2 id="1-1-两种LLM"><a href="#1-1-两种LLM" class="headerlink" title="1.1 两种LLM"></a>1.1 两种LLM</h2><p><strong>Base LLM</strong><br>基于文字数据进行文字的接龙，基于互联网的数据进行文本内容的猜测。</p>
<p><strong>Instruction Tuned LLM</strong><br>这种模型训练的方法：先训练出来Base LLM，然后再在Base LLM的基础之上，在大量的IO指令基础上进行微调，再通过RLHF技术进行进一步的优化。使得系统能够更好的接受输入以及输出。<br>对于大部分情况下，都为使用ITLLM进行学习以及开发。</p>
<ul>
<li>因为ITLLM是基于指令（关键词）进行的矫正、输出，因此当结果不合适时，应对重写选择合适的指令；</li>
</ul>
<h2 id="1-2-提问原则"><a href="#1-2-提问原则" class="headerlink" title="1.2 提问原则"></a>1.2 提问原则</h2><h3 id="1-2-1-原则一：编写明确、具体的指令"><a href="#1-2-1-原则一：编写明确、具体的指令" class="headerlink" title="1.2.1 原则一：编写明确、具体的指令"></a>1.2.1 原则一：编写明确、具体的指令</h3><p>明确 不等于 简短，为了明确的指令，可以提供更多的描述，来保证上下文信息的重组；</p>
<p><strong>具体方法1：使用分隔符清楚的指示输入的不同部分</strong></p>
<ul>
<li>分隔符可以是任何清晰的符号：引号、分割号、三引号、XML标记等</li>
<li>让模型知道：这是一个单独的部分</li>
</ul>
<p><strong>具体方法2：要求结构化的输出</strong><br>可以要求HTML、JSON、XML、MD等具体格式的输出；</p>
<p><strong>具体方法3：要求模型检查条件是否被满足</strong><br>当问题是基于某些假设时，可以先让模型检查这些假设；如果不满足条件，则指示停止尝试完全完成这些任务。</p>
<p><strong>具体方法4：少量训练提示</strong><br>在前面有成功回答的问题时，可以要求模型，它的任务是以一致的风格回答问题；</p>
<h3 id="1-2-2-原则二：给模型时间去思考"><a href="#1-2-2-原则二：给模型时间去思考" class="headerlink" title="1.2.2 原则二：给模型时间去思考"></a>1.2.2 原则二：给模型时间去思考</h3><p>模型无法处理过于复杂的问题。因此需要给模型“时间”去思考；</p>
<p><strong>具体方法1：指定完成任务所需的步骤</strong><br>具体指明回答时的步骤，比如：<br><em>第一步：总结要点<br>第二步：将要点翻译成英文<br>第三步：列出每一个要点的名称以及总结<br>第四步：输出JSON格式的内容</em></p>
<p><strong>具体方法2：指示模型在做出结论之前，先思考解决方案</strong><br>在模型给出具体的答案之前，先给时间去进行问题的实际思考；<br>比如让模型先用自己的计算方法进行计算，然后再和给出的答案进行比较；<br><em>1、先给出你自己的解决方案</em><br><em>2、再该处你自己的解决方案之前，不要决定解决方案是否正确</em></p>
<p><strong>具体方法3：面对幻觉时，要求模型先给出引用，再基于引用给出答案</strong><br>由于模型并不知道自己知识的边界，因此可能会编造出看起来十分正确的回答；<br>为了解决这种问题，可以要求：</p>
<ol>
<li>模型先给出针对问题的答案的引用；</li>
<li>要求模型基于这些引用，回答相关问题；</li>
</ol>
<h3 id="1-2-3-原则三：迭代得到答案"><a href="#1-2-3-原则三：迭代得到答案" class="headerlink" title="1.2.3 原则三：迭代得到答案"></a>1.2.3 原则三：迭代得到答案</h3><p>基于大模型给出的答案，很多时候第一次得到的都是错的。好的答案需要通过迭代来达成；</p>
<ul>
<li>输入 Idea</li>
<li>进行训练</li>
<li>得到数据</li>
<li>分析数据</li>
<li>再输入 Idea<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230911014920.png"
                     
                ></li>
</ul>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>ChatGPT</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 12：进程的地址空间</title>
    <url>/2023/08/d03400aa93d7.html</url>
    <content><![CDATA[<p>程序就是状态机，C语言的状态机被转换成汇编语言的状态机，在汇编语言的状态机当中直接看到内存地址空间。</p>
<span id="more"></span>
<h2 id="12-1-动-静态链接程序地址空间"><a href="#12-1-动-静态链接程序地址空间" class="headerlink" title="12.1 动&#x2F;静态链接程序地址空间"></a>12.1 动&#x2F;静态链接程序地址空间</h2><p>当指针指向一个不合法的位置时会直接得到一个错误，如果往一个合法的地址无权限的写入，也会获得一个访问错误。但就指针本身而言，其可以指向任何地方。如果想要真正知道哪些地方是可读的，即当前程序的地址空间，如何实现?</p>
<h3 id="12-1-1-最小C程序的地址空间"><a href="#12-1-1-最小C程序的地址空间" class="headerlink" title="12.1.1 最小C程序的地址空间"></a>12.1.1 最小C程序的地址空间</h3><p>在gdb下获得进程的进程号：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">info inferiors</span><br></pre></td></tr></table></figure></div>

<p>查看某一个进程地址空间代码：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">pmap 37491</span><br></pre></td></tr></table></figure></div>
<p>当中的37491为进程的id。</p>
<p><strong>查看结果：</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829191538.png"
                     
                ></p>
<p><strong>可以使用strace指令来获取pmap指令的系统调用：</strong></p>
<ul>
<li>除了可以用pmap之外，还可以直接在文件系统的proc中查看进程内存映射的关键信息。</li>
<li>proc当中有进程的编号，命令行从属的父子关系，还有当前进程内存映射的关键信息</li>
</ul>
<p>**相关手册：<code>mam 5 proc</code></p>
<h4 id="12-1-1-1-将strace信息以Vim打开"><a href="#12-1-1-1-将strace信息以Vim打开" class="headerlink" title="12.1.1.1 将strace信息以Vim打开"></a>12.1.1.1 将strace信息以Vim打开</h4><p>代码：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">strace ./a.out &amp;| vim -A</span><br></pre></td></tr></table></figure></div>

<h3 id="12-1-2-静态链接程序的地址空间"><a href="#12-1-2-静态链接程序的地址空间" class="headerlink" title="12.1.2 静态链接程序的地址空间"></a>12.1.2 静态链接程序的地址空间</h3><p>以下是在proc当中读取的地址空间信息：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829191738.png"
                     
                ><br>信息相比于前面最小的C程序要更多；<br>第一行：ELF文件头<br>第二行：因为有x表示可执行，所以为可执行代码<br>第三行：因为为只可读的数据，所以应该为字符串常量<br>第五行：可读可写，堆区</p>
<h3 id="12-1-3-动态链接程序的地址空间"><a href="#12-1-3-动态链接程序的地址空间" class="headerlink" title="12.1.3 动态链接程序的地址空间"></a>12.1.3 动态链接程序的地址空间</h3><p><strong>变化：</strong><br>相比于静态链接，动态链接程序的地址空间明显变得更复杂。并且其进程空间开始的地址相比于之前发生了较大的变化，因为OS进程地址随机化的机制，每一次动态链接程序的执行，其首地址空间位置都可能发生变化。<br>除此之外，还多了更多的映射区域。<br>以及一些没有文件的（但是可读可写）内存？是不是未初始化数据？如果在C程序当中分配一大段数组内存，此段空间将会承载此内容。<br><strong>通过改变程序的行为，观察程序的地址空间并且验证自己的假设。</strong></p>
<hr>
<h2 id="12-2-进程的地址空间管理"><a href="#12-2-进程的地址空间管理" class="headerlink" title="12.2 进程的地址空间管理"></a>12.2 进程的地址空间管理</h2><h3 id="12-2-1-VDSO、系统调用与非陷入式调用"><a href="#12-2-1-VDSO、系统调用与非陷入式调用" class="headerlink" title="12.2.1 VDSO、系统调用与非陷入式调用"></a>12.2.1 VDSO、系统调用与非陷入式调用</h3><p>操作系统上的程序是状态机，在程序当中有一类特殊的程序为SYSCALL系统调用，此指令会进入到操作系统内核执行，此时SYSCALL会因为转台的切换，带来更大的开销。<br>如何实现不进入OS内核的系统调用？</p>
<p>进程与时钟：<br>OS当中的进程是不知道时钟的，时钟本身是由OS维护的，这个时间原则上只有OS知道</p>
<p>程序中的time函数：<br>time函数没有进入libc，而是停在了vdso，把当前的地址相减寻址，得到一个不可访问的其他进程的地址。在执行了time函数之后，获得了一个极大的数值。<br>time函数可以在不进入操作系统内核的前提下，完成一个系统调用。因为在一片地址空间中，OS单独设置一块vvar，使得不进入OS的系统调用可以实现。因为这部分已经由OS提供了。</p>
<h3 id="12-2-2-系统调用的实现"><a href="#12-2-2-系统调用的实现" class="headerlink" title="12.2.2 系统调用的实现"></a>12.2.2 系统调用的实现</h3><p>一般教科书任何，需要通过中断来实现系统调用。但SYSCALL不需要int指令，就可以实现地址调用，甚至有更多</p>
<h3 id="12-2-3-mmap"><a href="#12-2-3-mmap" class="headerlink" title="12.2.3 mmap()"></a>12.2.3 mmap()</h3><p>操作系统需要提供一个机制来帮助我们管理地址空间;<br>OS需要提供相关指令，使得在程序执行的时候，在当前OS当中已有的内存当中找到一片新的内存，为其改变程序的地址空间，分配一片新的空间;<br>这个指令就是mmap；</p>
<p><strong>概念：</strong><br>mmap可以帮助程序在其状态当中，映射新的地址空间或者把已有的地址空间分配出去。在一个地址（addr）上面，映射一片长度为length的空间，向其传递访问的权限（prot），地址映射的方式（flags）。</p>
<p><strong>定义：</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="type">int</span> fd,<span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>mmap与程序加载器</strong><br>由于在Linux的设计哲学当中，一切都是文件，因此mmap当中有一个fd，有一个offset，就可以直接把一个非常大的文件直接映射到地址空间当中，然后再后背访问多少再进行加载多少。</p>
<h3 id="12-2-4-程序基于mmap的加载行为"><a href="#12-2-4-程序基于mmap的加载行为" class="headerlink" title="12.2.4 程序基于mmap的加载行为"></a>12.2.4 程序基于mmap的加载行为</h3><p>当程序想要加载某些文件，比如libc库时，此时只需要读取程序的ELF头文件（当中包含了这些文件的地址，要加载到什么位置），得到需要映射的文件信息，然后使用mmap将这些信息映射到当前程序的地址空间，即可完成加载。</p>
<h3 id="12-2-5-应用：使用mmap申请大内存"><a href="#12-2-5-应用：使用mmap申请大内存" class="headerlink" title="12.2.5 应用：使用mmap申请大内存"></a>12.2.5 应用：使用mmap申请大内存</h3><p>在申请太多内存的时候，OS会直接拒绝此行为。<br>代码：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829191917.png"
                     
                ></p>
<p><strong>代码解析：</strong><br>申请了3GB大小的内存，fd描述为1，读写它，一瞬间就完成。<br>使用strace观察行为可以知道，其只是使用mmap标记上了这段内存，在实际使用到的时候再进行加载。</p>
<h2 id="12-3-地址空间的隔离"><a href="#12-3-地址空间的隔离" class="headerlink" title="12.3 地址空间的隔离"></a>12.3 地址空间的隔离</h2><p>每一个指针只能访问当前进程的地址空间，mmap就是在当前程序的地址空间扩充一块，即mmap帮助了地址空间隔离的机制。</p>
<h3 id="12-3-1-老游戏修改器实现"><a href="#12-3-1-老游戏修改器实现" class="headerlink" title="12.3.1 老游戏修改器实现"></a>12.3.1 老游戏修改器实现</h3><p>命令与政府修改器实现的大致逻辑：</p>
<ul>
<li>第一步：获得游戏进程的PID（进程号）</li>
<li>第二步：由于Linux下的proc机制，其将程序的整个地址空间作为文件全部暴露出来了。可以将其作为文件使用<code>popen()</code>打开再扫过每一段内存。</li>
<li>第三步：使用解析代码<code>fscanf()</code>，找到每一段可读的内存</li>
<li>第四步：遍历此段内存，找到关键词数据</li>
<li>第五步：修改被关键字标记的内存</li>
</ul>
<h3 id="12-3-2-按键精灵-变速齿轮"><a href="#12-3-2-按键精灵-变速齿轮" class="headerlink" title="12.3.2 按键精灵&amp;变速齿轮"></a>12.3.2 按键精灵&amp;变速齿轮</h3><p>制作假的驱动，利用操作系统API模拟按下。<br>把游戏放在虚拟机上执行，可以任意调整时钟周期。</p>
<h3 id="12-3-3-代码注入"><a href="#12-3-3-代码注入" class="headerlink" title="12.3.3 代码注入"></a>12.3.3 代码注入</h3><p>在OS下，既可以改内存，也可以改代码。</p>
<h4 id="12-3-3-1-代码热更新原理"><a href="#12-3-3-1-代码热更新原理" class="headerlink" title="12.3.3.1 代码热更新原理"></a>12.3.3.1 代码热更新原理</h4><p>当程序当中有以下代码的时候，两次函数会输出一样的结果。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is old function&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo_new</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is new function&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	foo();</span><br><span class="line">	foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是如果代码执行热更新后，可以在运行时动态更改当前函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DSU</span><span class="params">(<span class="type">void</span>* old , <span class="type">void</span>* new)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ROUNDDOWN(ptr) ((void*)(((uintptr_t)ptr) &amp;~0xfff))</span></span><br><span class="line">	<span class="type">size_t</span> pg_size = ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>![[Pasted image 20230227204316.png]]<br>在原本的代码区中，将部分需要更新的代码更改为其他代码。<br>获得原本的代码地址，使用mprotect()函数将这片地址只读属性改成读写属性，然后再把新的地址（新函数的地址）给填写进去。</p>
<h4 id="12-3-3-2-基于人工智能的游戏外挂"><a href="#12-3-3-2-基于人工智能的游戏外挂" class="headerlink" title="12.3.3.2 基于人工智能的游戏外挂"></a>12.3.3.2 基于人工智能的游戏外挂</h4><p>使用深度学习算法，分析画面当中出现的特征画面，然后再抓取游戏引擎向底层OpenGL发出的渲染指令，分析其指令和画面的特征关系，从而抓取到其对应的代码，然后对其进行代码注入。</p>
<h3 id="12-3-4-地址空间Hack的攻与防"><a href="#12-3-4-地址空间Hack的攻与防" class="headerlink" title="12.3.4 地址空间Hack的攻与防"></a>12.3.4 地址空间Hack的攻与防</h3><p>概念一：保证控制&#x2F;数据 流的完整性；对独立的进程以及驱动进行完整性检验，保证部分区域的数据无法被读取，当用户尝试读取这部分数据时直接将其拉人黑名单。<br>概念二：AI监控；使用深度学习对用户数据信息进行建模，当发现某些玩家的数据分布和其他玩家的数据分配产生较大不同时，再来逐帧分析其运行<br>概念三：沙盒渲染；在计算机当中创建一片无法被读取的沙盒，将部分关键的运算放入沙盒当中进行计算，只有在计算结束之后才会返回数据；“计算不再信任操作系统”</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
        <tag>Fork</tag>
        <tag>Mmap</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 11：操作系统上的进程</title>
    <url>/2023/08/5b1cbd3ab6e9.html</url>
    <content><![CDATA[<blockquote>
<pre><code>1. 操作系统启动后做了什么？
2. 操作系统如何管理进程？
</code></pre>
</blockquote>
<span id="more"></span>
<h2 id="11-1-进程与Linux"><a href="#11-1-进程与Linux" class="headerlink" title="11.1 进程与Linux"></a>11.1 进程与Linux</h2><h3 id="11-1-1-操作系统的第一个进程"><a href="#11-1-1-操作系统的第一个进程" class="headerlink" title="11.1.1 操作系统的第一个进程"></a>11.1.1 操作系统的第一个进程</h3><p>操作系统的第一条程序执行之后，接下来的行为就是创建其他的程序，然后就把操作系统的全部控制权交给程序，即操作系统树根上的程序。<br>操作系统只是创建第一个树根进程，然后其他进程由此树根进程创建。</p>
<p><strong>Linux进入之后加载第一个程序的代码：</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829191238.png"
                     
                ></p>
<h4 id="11-1-1-1-gcc观看进程结构"><a href="#11-1-1-1-gcc观看进程结构" class="headerlink" title="11.1.1.1 gcc观看进程结构"></a>11.1.1.1 gcc观看进程结构</h4><p>以下shell指令执行后，将会输出当前OS的所有进程，而这些所有进程都是由根进程所创建：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">pstree</span><br><span class="line">systemd ---..其他进程</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829191308.png"
                     
                ></p>
<h3 id="11-1-2-最小Linux实现Linux-运行："><a href="#11-1-2-最小Linux实现Linux-运行：" class="headerlink" title="11.1.2 最小Linux实现Linux 运行："></a>11.1.2 最小Linux实现Linux 运行：</h3><ol>
<li>无图形界面</li>
<li>128m内存</li>
<li>linux内核</li>
<li>将initramfs<br>使用<code>make run</code>启动程序后，当前OS内核当中只有一个init在执行，此进程不可返回，不然OS就会发生Crash</li>
</ol>
<h4 id="11-1-2-1-OS内核链接至BusyBox"><a href="#11-1-2-1-OS内核链接至BusyBox" class="headerlink" title="11.1.2.1 OS内核链接至BusyBox"></a>11.1.2.1 OS内核链接至BusyBox</h4><p>将busybox链接至OS的<code>/bin/</code>目录下，生成的链接文件的名称为ps、arch、pst等这些Linux常见命令的名称，此时在OS中就可以直接使用这些程序。<br>只要当前程序是静态链接的，就可以被链接到OS当中</p>
<h3 id="11-1-3-略复杂一些的OS实现"><a href="#11-1-3-略复杂一些的OS实现" class="headerlink" title="11.1.3 略复杂一些的OS实现"></a>11.1.3 略复杂一些的OS实现</h3><p>内容：</p>
<ol>
<li>当中有更多挂载的磁盘</li>
<li>执行switch root系统调用，将initramfs销毁<br>把初始的文件系统销毁，然后创建一个新的文件系统</li>
</ol>
<p><strong>系统调用的三大类型</strong></p>
<ol>
<li>进程管理</li>
<li>文件管理</li>
<li>内存管理<br>有这三类系统调用，就可以实现整个OS世界</li>
</ol>
<hr>
<h2 id="11-2-进程与fork"><a href="#11-2-进程与fork" class="headerlink" title="11.2 进程与fork()"></a>11.2 进程与fork()</h2><p>OS必须要有一个创建进程的API，在Init加载了第一个进程后，使用fork()创建其他的进程</p>
<h3 id="11-2-1-什么是fork"><a href="#11-2-1-什么是fork" class="headerlink" title="11.2.1 什么是fork()"></a>11.2.1 什么是fork()</h3><p>当前进程有一个执行流，当执行到了fork()之后当前程序的执行流变成两条，完成分叉<br><strong>如何理解？</strong><br>操作系统在加载之后就创建了init这个状态机。当init执行了fork()后，执行流就会陷入到内核当中执行OS代码，fork会把当前进程状态机的状态完整复制一份，然后创建一个新的执行流</p>
<ul>
<li>完全一致的进程<ul>
<li>两个进程在内存上一模一样，寄存器一样</li>
<li>只有返回的值不一样：<ul>
<li>每一个进程都有一个唯一的编号</li>
<li>除了编号之外一切相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>当操作系统新创建了进程之后，就变成了一个并发程序。OS每一次可以选择一个进程执行一次（如果每一个时刻CPU只能执行一个）</p>
<h3 id="11-2-2-Fork-Bomb"><a href="#11-2-2-Fork-Bomb" class="headerlink" title="11.2.2 Fork Bomb"></a>11.2.2 Fork Bomb</h3><p>可以创建一个无限创建进程的程序，一开始的fork变成两个fork，每个创建的fork又可以创建fork，无休止创建下去。</p>
<h3 id="11-2-3-Fork行为分析"><a href="#11-2-3-Fork行为分析" class="headerlink" title="11.2.3 Fork行为分析"></a>11.2.3 Fork行为分析</h3><p>对于Fork创建进程的行为进行分析<br><strong>代码：</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">2</span> ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fork();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i&lt;n ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>执行行为：</strong><br>第一次i &#x3D; 0时，进入for然后执行一次fork()，此时进程会进行分叉变成两个进程，两个进程拥有完全一致的状态，因此都会进入printf然后输出。<br>第二次i&#x3D;1时，当前已经有了两个fork，而这两个fork都会各自进行复制，因此会有四个进程取执行printf()然后输出Hello</p>
<p><strong>Printf行为分析：</strong><br>第一点：fork就只是一个无情的拷贝状态的机器<br>第二点：因为fork只是一个无情的状态拷贝机器，因此其会把库函数内部的状态也给其复制一份。<br>将Printf直接打印到屏幕上面：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure></div>
<p>如果不适用fflush，库函数会先将其放在buffer当中。</p>
<ul>
<li>line buffer<ul>
<li>直接把每一行buffer输出出来</li>
</ul>
</li>
<li>full buffer<ul>
<li>只有满足buffer大小要求后才输出出来，不然就先给到buffer</li>
</ul>
</li>
</ul>
<p>fork的问题：多个线程下，fork的行为问题</p>
<h2 id="11-3-进程与execve"><a href="#11-3-进程与execve" class="headerlink" title="11.3 进程与execve()"></a>11.3 进程与execve()</h2><h3 id="11-3-1-execve行为"><a href="#11-3-1-execve行为" class="headerlink" title="11.3.1 execve行为"></a>11.3.1 execve行为</h3><p>fork创建了新的进程之后，可以检查其pid是否等于0，如果不为0则执行，进入背景现成，如果为0则为父进程，此时执行execve()，接着就会重置状态机，将当前运行的状态机重置为另一个程序的初始状态。<br>定义：execute the program referred to by pathname.</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">exceve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span>* cons envp[])</span>;</span><br></pre></td></tr></table></figure></div>
<p>使用代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* <span class="type">const</span> argv[] = </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;env&quot;</span>,<span class="literal">NULL</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* <span class="type">const</span> envp[] = </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;HELLO=WORLD&quot;</span>,<span class="literal">NULL</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	execve(argv[<span class="number">0</span>],argv,envp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello,World\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="11-3-2-环境变量"><a href="#11-3-2-环境变量" class="headerlink" title="11.3.2 环境变量"></a>11.3.2 环境变量</h3><p>环境变量就是应用程序执行的环境，当状态机重置时，其他状态不变，当前状态机的状态被更改。<br>所有程序执行的第一行总是execvve，新的状态的启动总是要被重置，即使用execve</p>
<ul>
<li>环境变量<ul>
<li>PATH<ul>
<li>程序执行路径的环境变量</li>
</ul>
</li>
<li>PWD<ul>
<li>当前路径</li>
</ul>
</li>
<li>HOME<ul>
<li>HOME目录</li>
</ul>
</li>
<li>DISPLAY<ul>
<li>图形输出</li>
</ul>
</li>
<li>PS1<ul>
<li>shell提示符</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>LINUX也只不过是在这些环境变量当中找到 内容，然后执行</p>
<p><strong>PATH环境变量</strong><br>PATH就是可执行文件的搜索路径。当执行gcc之后，此时gcc的系统调用就是寻找其当前程序有可能的可执行文件的目录，搜索顺序就是PATH中指定的顺序。</p>
<hr>
<h2 id="11-4-进程与exit"><a href="#11-4-进程与exit" class="headerlink" title="11.4 进程与exit()"></a>11.4 进程与exit()</h2><p>进程需要进行销毁，当前状态机世界当中所有的状态都不变，除了当前执行exit()的进程直接从OS当中消失</p>
<ul>
<li>问题<ul>
<li>多线程的程序，exit的行为如何？</li>
<li>是所有线程结束还是只结束调用的线程？</li>
</ul>
</li>
<li>多种exit<ul>
<li>stdlib当中的exit</li>
<li>glibc当中的_exit(0)</li>
<li>syscall(SES_exit,0)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 13：系统调用与Shell</title>
    <url>/2023/08/3dbfbd52ee49.html</url>
    <content><![CDATA[<h2 id="我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell-前言：作为操作系统的用户，“我们”到底是怎么使用操作系统的？"><a href="#我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell-前言：作为操作系统的用户，“我们”到底是怎么使用操作系统的？" class="headerlink" title="我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell&gt; 前言：作为操作系统的用户，“我们”到底是怎么使用操作系统的？"></a>我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。<br>在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell<br><span id="more"></span><br>&gt; 前言：作为操作系统的用户，“我们”到底是怎么使用操作系统的？</h2><h2 id="13-1-Shell简介"><a href="#13-1-Shell简介" class="headerlink" title="13.1 Shell简介"></a>13.1 Shell简介</h2><h3 id="13-1-1-用户角度的Shell"><a href="#13-1-1-用户角度的Shell" class="headerlink" title="13.1.1 用户角度的Shell"></a>13.1.1 用户角度的Shell</h3><p>我们需要一个用户能直接操作的程序，管理与你交互的设备，对应操作系统中的对象，而这就是Shell，第一个与人交互的程序就是Shell。<br>在操作系统的状态机当中，除了操作系统的内核之外，还会有一个程序负责输入和输出，负责包在Kernel之外的一层壳，帮助用户和OS交互：shell</p>
<h3 id="13-1-2-早期的Shell"><a href="#13-1-2-早期的Shell" class="headerlink" title="13.1.2 早期的Shell"></a>13.1.2 早期的Shell</h3><p><strong>概念：</strong><br>早期的OS没有复杂结构，系统调用就像是库函数，那个时代的Shell就是命令行终端机。<br>核心：<strong>Shell就是一门把用户指令翻译为系统调用的编程语言</strong></p>
<p>手册：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">man sh</span><br></pre></td></tr></table></figure></div>
<p>这是一个非常简单的手册，包含很多shell的内容，建立对UNIX Shell的基础认识。</p>
<h2 id="13-2-复刻简易UNIX"><a href="#13-2-复刻简易UNIX" class="headerlink" title="13.2 复刻简易UNIX"></a>13.2 复刻简易UNIX</h2><h3 id="13-2-1-简易UNIX代码初设置"><a href="#13-2-1-简易UNIX代码初设置" class="headerlink" title="13.2.1 简易UNIX代码初设置"></a>13.2.1 简易UNIX代码初设置</h3><p>早期的计算机设计由于性能低下，设计不能太消耗性能以及复杂<br>代码：<a class="link"   href="http://jyywiki.cn/pages/OS/2022/demos/sh-xv6.c" >http://jyywiki.cn/pages/OS/2022/demos/sh-xv6.c <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>零库函数依赖、可以作为最小可用的Linux的init程序<br>由于其链接任何库函数，因此可以ffreestanding</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -ffreestanding sh-xv6.c -g -O2</span><br><span class="line">ld sh-xv6.o -o sh</span><br></pre></td></tr></table></figure></div>
<p>第一行是将其编译，然后第二行将其静态链接<br>当使用反汇编模式进行调试时，直接从_Start()，用C写的这个函数处开始执行。此程序可以直接以命令行的形式进行运行。<br>![[Pasted image 20230827140800.png]]</p>
<h3 id="12-2-2-第一步：读取命令"><a href="#12-2-2-第一步：读取命令" class="headerlink" title="12.2.2 第一步：读取命令"></a>12.2.2 第一步：读取命令</h3><p>代码：<br>解析：不停的getcmd()来获得用户的输入，这其中直接使用read的系统调用</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> nread = <span class="built_in">syscall</span>(SYS_read,<span class="number">0</span>,buf,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>
<p>一直读到换行符才停止：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(*(buf++)==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>
<p>将命令读取到buf缓冲区里</p>
<h3 id="12-2-3-第二步：可能性-解释执行命令"><a href="#12-2-3-第二步：可能性-解释执行命令" class="headerlink" title="12.2.3 第二步：可能性|解释执行命令"></a>12.2.3 第二步：可能性|解释执行命令</h3><p>代码：<br>![[Pasted image 20230301181806.png]]<br>解析：<br>首先判断是不是一条’cd’命令，并且其当中不能有空格<br>使用系统调用，读取buf+3之后的数据</p>
<h3 id="12-2-4-第二步：可能性-新进程创建"><a href="#12-2-4-第二步：可能性-新进程创建" class="headerlink" title="12.2.4 第二步：可能性|新进程创建"></a>12.2.4 第二步：可能性|新进程创建</h3><p>解析：可能性|如果不是cd命令，此时创建一个新的进程，在新的进程里面把进程解析</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">syscall</span>(SYS_fork) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">runcmd</span>(<span class="built_in">parsecmd</span>(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="12-2-5-第三步：程序解释器"><a href="#12-2-5-第三步：程序解释器" class="headerlink" title="12.2.5 第三步：程序解释器"></a>12.2.5 第三步：程序解释器</h3><p>其行为就和表达式求值一模一样。<br>求值表达式：<br>eval评估根节点，然后递归的评估子节点，等到两边的值都返回之后得到最后的解。Shell的每一个语句都有其语义。<br>命令解释：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">( echo a ; echo b) | wc -l</span><br></pre></td></tr></table></figure></div>

<p>每执行一个命令，其实就是使用execve()创建一个新的进程，函数的参数就是传入的命令。首先递归的执行左边的部分，然后再递归的执行右边的部分。</p>
<ul>
<li>命令与管道<ul>
<li>管道和命令关系<ul>
<li>管道的左边和右边都可以任意复杂：   </li>
<li>可以是一个很长的式子：<code>(echo a;each b;echo c;echo d)|wc -l</code></li>
<li>把管道左边的输出作为右边的输入，这就是管道的形式语义。</li>
</ul>
</li>
<li>管道解析<ul>
<li>pipe()创建一个管道，管道返回两个描述符：</li>
<li>pipe[0]是读口，pipe[1]是写口</li>
<li>之后会使用fork创建两个新的进程，这两个新的进程完全复制的父进程的状态，因此此时这三个进程完全共享管道，并且共进共出。</li>
<li>之后将p[0]的文件描述符关闭，后背又将p[1]的文件描述符关掉</li>
<li>之后再进行Fork，子进程编号为1的进程指向管道的左边，Fork出来的子进程再进行上述出现的行为</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="12-2-5-1-将strace中信息保存至文件"><a href="#12-2-5-1-将strace中信息保存至文件" class="headerlink" title="12.2.5.1 将strace中信息保存至文件"></a>12.2.5.1 将strace中信息保存至文件</h4><p>对sh进行使用，然后保存其strace获得的系统调用信息，将其保存至文件当中：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">strace -f -o /tmp/strace.log ./sh</span><br></pre></td></tr></table></figure></div>
<p>打开strace.log文件之后，即可看到系统调用存储成文件后的内容：<br>首先读取指令，使用fork创建进程：<br>![[Pasted image 20230303170109.png]]<br>然后主进程打印内容，退出子进程：</p>
<h2 id="13-3-UNIX-Shell"><a href="#13-3-UNIX-Shell" class="headerlink" title="13.3 UNIX Shell"></a>13.3 UNIX Shell</h2><p>UNIX Shell就是编程语言，写命令行就是编程</p>
<p><strong>Shell与Job Control</strong><br>即使是1990年代的Shell，也可以实现现在的操作系统的Job控制功能，只不过是使用的命令行，而非图形化界面</p>
<h3 id="13-3-1-Shell作为OS封装的API"><a href="#13-3-1-Shell作为OS封装的API" class="headerlink" title="13.3.1 Shell作为OS封装的API"></a>13.3.1 Shell作为OS封装的API</h3><p>我们需要一个用户能够直接操作的程序，管理操作系统对象，Shell就是操作系统的外壳，帮助人类和OS进行交互</p>
<p><strong>1970年代的Shell</strong><br>1970年代的命令，在“自然语言”和“机器语言”以及计算机的算力之间达到平衡。<br>但其也有缺点，比如命令之间的优先级，以及不同的Shell对编程语言的解读是不一样的</p>
<p><strong>空格带来的麻烦</strong><br>文本数据当中，对于空格的不同理解以及行为导致的程序后果<br>PowerShell：使用对象流管道解决</p>
<h3 id="13-3-2-现代Shell展望"><a href="#13-3-2-现代Shell展望" class="headerlink" title="13.3.2 现代Shell展望"></a>13.3.2 现代Shell展望</h3><p>现代的Shell功能不变，都是人和机器之间的API，但是其形式可以发生变化</p>
<ul>
<li>界面自带StackOverflow？</li>
<li>结合神经网络？</li>
<li>智能补全？</li>
<li>POPL20</li>
</ul>
<h2 id="13-4-终端与任务控制"><a href="#13-4-终端与任务控制" class="headerlink" title="13.4 终端与任务控制"></a>13.4 终端与任务控制</h2><h3 id="13-4-1-终端机制"><a href="#13-4-1-终端机制" class="headerlink" title="13.4.1 终端机制"></a>13.4.1 终端机制</h3><p>问题：为什么有时候使用Ctrl + C可以退出程序，有时候不可以？为什么有些进程可以退出，当管道创建了很多个进程时，使用Ctrl + C 将退出哪个进程？如果时Fork了一个Shell，那使用Ctrl + C 是不是要退出Shell？tmux是怎么实现的？</p>
<p><strong>解决方案：终端</strong><br>Shell连接了人和程序，而人和机器之间交互的设备就是输入和输出设备，这个设备就是终端<br>终端是UNIX当中一类特别的设备，其也作为文件来存在，可以在文件系统中新建多个终端，同时以多个窗口来访问</p>
<p><strong>tmux原理</strong><br>可以使用strace来读取tmux的行为，将其信息保存在文件系统中；<br>不管当前是哪一个窗口，tmux都会把当前的输入捕捉下来，然后相应的将按键的信息转发给不同的终端</p>
<h3 id="13-4-2-信号机制"><a href="#13-4-2-信号机制" class="headerlink" title="13.4.2 信号机制"></a>13.4.2 信号机制</h3><p>信号是终端产生的（比如Ctrl + C是一个信号），给前台进程发一个信号，收到信号之后会有对于的信号处理程序</p>
<p><strong>信号处理程序：</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829192041.png"
                     
                ><br>Ctrl + C 给所有的前台的进程发信号，UNIX世界当中，登陆了Shell当中会先打开Session，然后进入进程组，这些进程组可以放在前台或者后台。前台组无论什么进程，创建进程后都是前台复制过来的，属于前台进程。此时按下Ctrl + C就会对前台的所有进程发送信号</p>
<h4 id="13-4-2-1-Job-Control机制"><a href="#13-4-2-1-Job-Control机制" class="headerlink" title="13.4.2.1 Job Control机制"></a>13.4.2.1 Job Control机制</h4><p>手册：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">man setpgid</span><br></pre></td></tr></table></figure></div>
<p>手册当中告诉，每个session就是一个单独的控制终端，在任何时候，只有一个进程组是前台的进程组，Ctrl + C会给前台的所有进程发送信号。如果有好几个进程组都是前台进程，则此时往前台发送数据可能会产生数据竞争。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 15：Fork的应用</title>
    <url>/2023/08/3d8a9bfbeeea.html</url>
    <content><![CDATA[<p>Fork：操作系统就是一个大的状态机，OS在一般的情况下，使用Syscall执行Fork时会复制一个新的状态。而此状态由于是对于原本被Fork对象的复制，因此会和原本状态完全一致，因此如果原线程上在本地打开了一个文件描述符，那新的线程也会打开它，即指向了同一个OS中的对象</p>
<span id="more"></span>
<blockquote>
<p>前言：从这节课开始，会逐渐进入到如何实现OS相关的内容，即往OS的内核来走</p>
</blockquote>
<h2 id="15-1-fork-行为的补充解释"><a href="#15-1-fork-行为的补充解释" class="headerlink" title="15.1 fork()行为的补充解释"></a>15.1 fork()行为的补充解释</h2><h3 id="15-1-1-操作系统的状态机"><a href="#15-1-1-操作系统的状态机" class="headerlink" title="15.1.1  操作系统的状态机"></a>15.1.1  操作系统的状态机</h3><p><strong>概念复习</strong><br>Fork：操作系统就是一个大的状态机，OS在一般的情况下，使用Syscall执行Fork时会复制一个新的状态。而此状态由于是对于原本被Fork对象的复制，因此会和原本状态完全一致，因此如果原线程上在本地打开了一个文件描述符，那新的线程也会打开它，即指向了同一个OS中的对象（行为类似于指针共享）<br>Execve：进程执行了Execve，状态机就会被重置，但是在重置之后，OS当中的对象还在，因此即使状态被重置，这个指向依然存在，比如其打开的文件描述符依然存在。</p>
<h3 id="15-1-2-文件描述符"><a href="#15-1-2-文件描述符" class="headerlink" title="15.1.2 文件描述符"></a>15.1.2 文件描述符</h3><p><strong>概念</strong><br><strong>文件描述符就是一个指向操作系统内对象的指针</strong>，只能通过OS运行的方式去访问这些对象。但是对于一个文本对象，write一个对象的时候，应该是具有一个文件内的偏移量，进而可以使得两个write写入的内容不是被覆盖，而是都可以被写入。</p>
<p>文件描述符可以通过Open来得到，比如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">open(<span class="string">&quot;a.txt&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>此时会获得一个文件描述符，并且指向这个 a.txt 对象<br>在使用Open打开文件描述符时，可以使用一个O_APPEND的方式写入。不管文件的数量多少，都会以file offset的方式在文件的末尾进行追加。</p>
<p><strong>文件描述符的复制</strong><br>代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;a.txt&quot;</span>,O_WROLY | O_CREAT);<span class="comment">//用creat打开，如果不存在就被创造</span></span><br><span class="line">assert(fd &gt; <span class="number">0</span>);</span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line">assert(pid&gt;<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	write(fd,<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	write(fd,<span class="string">&quot;World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>问题一：文件偏移量的管理<br>以上代码的结果，是Hello被World覆盖掉，还是两者都被输出？即当两个相同状态的进程进行write时，其两者用于相同的文件描述符的前提下，两者是共享偏移量还是其他行为？ </p>
</li>
<li><p>问题二：dup复制文件描述符<br><strong>什么是dup</strong><br>假设原本存在一个fd为3的文件描述符，指向了OS中的一个对象。当使用了dup之后，此时会再出现一个文件描述符，其fd为4，同样也指向了此OS中的一个对象。<br>但是如果带有文件偏移量，那此时究竟应该是共享offset，还是独立offset？</p>
</li>
</ul>
<h2 id="15-2-fork的实现"><a href="#15-2-fork的实现" class="headerlink" title="15.2 fork的实现"></a>15.2 fork的实现</h2><h3 id="15-2-1-fork设计的问题"><a href="#15-2-1-fork设计的问题" class="headerlink" title="15.2.1 fork设计的问题"></a>15.2.1 fork设计的问题</h3><p>创建副本这件事情的代价很大，进程可能有很大的地址空间，如果此时对一个非常大的地址空间fork一份，并且在这之后立马就execve，此时就会产生十分大的性能浪费，此时OS会怎么应对这种状况？</p>
<p><strong>OS中的进程地址空间设计</strong><br>每一个进程会有一个地址空间，并且在地址空间当中会进行分页（MMU），而进程其本身拥有的只是一个映射表。映射表提供了相关的信息，表示不同的内容会映射到分页之后的哪个页面，所以概念上进程拥有这些页面，其实实际上依然是由OS控制着所有这些内容。</p>
<h3 id="15-2-2-共享只读设计"><a href="#15-2-2-共享只读设计" class="headerlink" title="15.2.2 共享只读设计"></a>15.2.2 共享只读设计</h3><p>当一个进程拥有两个页面时，内容如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829192242.png"
                     
                ><br>当指向了一个fork之后，其状态如下;<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829192306.png"
                     
                ><br>此时这两个进程都同时指向了一个可写的页面，因此Old进程可以写，New进程也可以写。但是此时OS会偷偷的抹掉这个可写的权限，进而可能发生缺页中断（段错误）。但如果OS发现，这个缺页中断只是被偷偷抹掉的，此时OS会将此页引用计数减1，然后将其拷贝一份到另外的可写权限的空间，从而把读写的权限重新还给NEW进程。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829192322.png"
                     
                ><br><strong>优点：</strong><br>这种设计Copy on Write的设计，当遇到非常大的地址空间中需要映射的内容时，有时可以不需要为其创建新的内容，只有在使用时才产生这种Copy On Write。<br><strong>例子：libc</strong><br>整个OS里面，只有一份libc的副本，OS当中有很多的进程，此时这些不同的进程都是指向同一个libc。</p>
<p><strong>代码证明Copy On Write</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPROC 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MB 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE (MB * (1 &lt;&lt; 20))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xstr(s) str(s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> str(s) #s</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *data = <span class="built_in">malloc</span>(SIZE); <span class="comment">// 128MB shared memory</span></span><br><span class="line">  <span class="built_in">memset</span>(data, <span class="string">&#x27;_&#x27;</span>, SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NPROC - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// NPROC processes go here</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;.fill 1048576 * &quot;</span> xstr(MB) <span class="string">&quot;, 1, 0x90&quot;</span>)</span>; <span class="comment">// 128MB shared code</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, O_RDONLY); assert(fd &gt; <span class="number">0</span>);</span><br><span class="line">  read(fd, &amp;idx, <span class="keyword">sizeof</span>(idx));</span><br><span class="line">  close(fd);</span><br><span class="line">  idx %= <span class="number">1048576</span> * MB;</span><br><span class="line"></span><br><span class="line">  data[idx] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pid = %d, write data[%u]\n&quot;</span>, getpid(), idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// not terminate</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>执行了这个代码之后，在OS当中有1000个进程在进行，并且上述代码在SO中，每个都要求分配了128MB的内存。但是OS并没有Crash掉，实际只是用了1GB左右的内存。这就是Copy On Write的实现。</p>
<p><strong>关于进程内存占有量</strong><br>由此推导出一个结论：证明一个进程用的多少的内存就是一个伪命题。如果简单的将一个进程映射的内存之和相加作为其内存大小，mmap可以映射一大片的内存（比如20T内存），但是这些内存是按需使用的，其只是做了一个映射，然后使用时只会用多少分配多少，并且还有很多内存是共享的（Libc）。</p>
<h2 id="15-3-状态机的复制"><a href="#15-3-状态机的复制" class="headerlink" title="15.3 状态机的复制"></a>15.3 状态机的复制</h2><h3 id="15-3-1-状态机视角"><a href="#15-3-1-状态机视角" class="headerlink" title="15.3.1 状态机视角"></a>15.3.1 状态机视角</h3><p><strong>概念：平行宇宙与fork</strong><br>物理世界上不同的粒子状态，可以定义出不同时间下的状态。如果此时要进行时间穿越，此时行为就是将未来的部分状态带到过去，并且从此状态开始进行分叉，而这个分叉就是fork()。<br>OS运行开发者使用fork()实现平行宇宙。</p>
<h3 id="15-3-2-fork与并行化"><a href="#15-3-2-fork与并行化" class="headerlink" title="15.3.2 fork与并行化"></a>15.3.2 fork与并行化</h3><p><strong>例子1：码交换搜索问题</strong><br>和不同的部分进行交换，就会进入不同的状态。可以使用状态机的视角，将所有的状态进行探索。<br>![[Lecture 15：Fork的应用 2023-03-16 16.57.00.excalidraw]]</p>
<p><strong>例子2：基于fork的dfs</strong><br>原本的dfs会使用深度遍历进行探索，然后使用回溯法回到原本的状态，回溯的过程十分耗时。而如果基于fork，使用状态机的视角来进行迁移，则可以只会跳回到初始状态（通过使用exit()来实现）。<br>其启示是：可以使用fork实现dfs；使用fork来进入不同的状态，并且联合OS来帮助进行管理，此时进入新的状态后原本的平行宇宙也可以被消除掉，每探索完一个平行宇宙都将其删除掉。<br>并且，还可以创造多个平行宇宙，并行的得到所有状态，然后程序结束。</p>
<h3 id="15-3-3-fork与跳过初始化"><a href="#15-3-3-fork与跳过初始化" class="headerlink" title="15.3.3 fork与跳过初始化"></a>15.3.3 fork与跳过初始化</h3><p><strong>问题</strong><br>假设你的NEMU需要启动很多份elf头文件，而如果NEMU进行初始化要花很多的时间（比如花费大量时间来初始化一片128MB的内存），此时如果为每个elf来进行启动就会产生大量消耗，此时可以按照以下行为分析：<br>![[Lecture 15：Fork的应用 2023-03-16 17.29.53.excalidraw]]<br><strong>处理方法</strong><br>此时可以只执行一次nemu_init()的内容，之后只需要每进来一个需要启动的内容，就fork一份，然后找到没有处理的文件，将其进行处理，就可以完成操作。并且因为只进行一次init，因此可以加速程序执行第一个文件的速度。</p>
<p><strong>跳过初始化的实际应用</strong><br>应用：安卓应用的秒启动</p>
<ul>
<li>简介：每一个安卓的程序都会通过以上的跳过初始化的方式进行启动。</li>
<li>原理：安卓应用是一个Java程序，而Java是运行在JVM虚拟机上面，对于安卓而言是一个Android Runtime（自己实现的虚拟机）。而安卓和Java都会有一个十分大的标准库，如果每一个程序是采取冷启动，即从0开始执行整个Java程序，不可能几秒内完成加载，此时就是使用了跳过初始化的思想，所有的Java程序只进行初始化一次。</li>
<li>Zygote Process：会有一个所有Android程序的父进程，名称为Zygote Process。其会完成所有必要的安卓程序的必要的类的加载，此时如果开始了一个新的程序，只要在init之后的状态基础之上fork一份即可完成创建。</li>
<li>一次加载，全员使用<br>应用：Chrome浏览器</li>
<li>简介：Chrome可以成功的原因之一，就是其速度非常的快。</li>
<li>原理：Chrome当中，每一个网页就是一个进程，使用跳过初始化的思想来进行网页的快速加载</li>
</ul>
<p><strong>核心：只要是从一个状态出发，需要很多个副本的，都可以使用fork。</strong></p>
<h3 id="15-3-4-fork与备份"><a href="#15-3-4-fork与备份" class="headerlink" title="15.3.4 fork与备份"></a>15.3.4 fork与备份</h3><p><strong>简介：</strong><br>要是我们可以对有Bug的程序总是能在任何状态“试一试”，然后试错了还能回到过去，就好了。<br><strong>概念：</strong><br>当过去某个节点发生了一个Bug，我们能否回到过去，在产生一次这个Bug?特别是出现并发Bug，此类Bug或许十分难以重现，拥有此存档机制就可以去复现过去状态下的Bug。<br>在任何状态下，可以使用fork()开启另一条平行宇宙，然后在此基础上进行存档。然后如果顺着正常的路径进行执行，但是之后在这主分支之上发生了Crash，此时就可以拿回之前的存档，从之前的存档开始。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829192347.png"
                     
                ><br>然后拿回了之前的存档后，从此存档开始执行，并且需要更改一些环境。很多Bug都是由于环境导致的（比如许多的并发Bug）。<br>![[Lecture 15：Fork的应用 2023-03-17 21.27.15.excalidraw]]<br>这就是可以进行容错的机制。如果有轻量级的快照，就可以使用平行宇宙来复查一些Bug。甚至如果是想要还原并发这种Bug，甚至不需要复杂的Fork的快照，只需要有一个Setjmp寄存器的快照。</p>
<h2 id="15-4-对于Fork的讨论"><a href="#15-4-对于Fork的讨论" class="headerlink" title="15.4 对于Fork的讨论"></a>15.4 对于Fork的讨论</h2><h3 id="15-4-1-A-Fork-in-the-road"><a href="#15-4-1-A-Fork-in-the-road" class="headerlink" title="15.4.1 A Fork() in the road"></a>15.4.1 A Fork() in the road</h3><p><strong>简介：</strong><br>对于Unix Fork的批评。<br><strong>概述：</strong><br>fork使用的最舒服的时候，就是在一个简单的管道模型当中。但是随着OS发展，进程不止是有地址空间和文件描述符，但是之后进程会有信号（fork之后，发信号是两个都发，还是只发一个？），线程，进程间通信对象，ptrace等等。<br>fork的开发者对于这些问题进行了修复，但是结果就是导致现在的fork十分的复杂。比如出现线程之后。</p>
<p><strong>这些都是由进程拥有了一些更加复杂的对象所引发出的问题。</strong></p>
<h3 id="15-4-2-线程对于Fork的影响"><a href="#15-4-2-线程对于Fork的影响" class="headerlink" title="15.4.2 线程对于Fork的影响"></a>15.4.2 线程对于Fork的影响</h3><p><strong>线程概述</strong><br>在一个进程当中，会有一片地址空间，两个不同的线程共享这些地址空间，所有的页面都是共享的（因为页面是由OS持有的）。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829192415.png"
                     
                ><br><strong>问题</strong><br>此时如果fork了一份这个进程，这当中的这些线程会怎么样？</p>
<p><strong>分析</strong><br>首先，肯定是进程当中的某一个线程执行了fork，在执行了fork之后，是对应进程复制，另一个进程消失，还是两者都被复制？<br>正确答案是 只复制执行了fork的进程。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829192444.png"
                     
                ></p>
<h3 id="15-4-3-更安全的创建一个进程"><a href="#15-4-3-更安全的创建一个进程" class="headerlink" title="15.4.3 更安全的创建一个进程"></a>15.4.3 更安全的创建一个进程</h3><p><strong>创建进程：POSIX Spawn</strong><br>代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">posix_spawn</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">pid_t</span> *pid,</span></span><br><span class="line"><span class="params"><span class="type">char</span> *path,</span></span><br><span class="line"><span class="params"><span class="type">posix_spawnattr_t</span> *attrp,</span></span><br><span class="line"><span class="params"><span class="type">char</span>* argv[],</span></span><br><span class="line"><span class="params"><span class="type">char</span>* envp[]</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></div>
<p>其是一个在fork发明出来之后的API，比fork更加的简单。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Fork</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 16：什么是可执行文件</title>
    <url>/2023/08/92c8110645cf.html</url>
    <content><![CDATA[<p>目前已经把操作系统表层上的内容都创建好了，这部分之后会再次回归到最开始的地方。</p>
<ul>
<li>重新回到可执行文件：可执行文件是什么，其如何在OS上运行；<span id="more"></span></li>
</ul>
<h2 id="16-1-可执行文件"><a href="#16-1-可执行文件" class="headerlink" title="16.1 可执行文件"></a>16.1 可执行文件</h2><h3 id="16-1-1-手册的逻辑"><a href="#16-1-1-手册的逻辑" class="headerlink" title="16.1.1 手册的逻辑"></a>16.1.1 手册的逻辑</h3><p><strong>链接</strong><br>关于可执行文件的手册地址：<a class="link"   href="http://jyywiki.cn/pages/OS/manuals/sysv-abi.pdf" >http://jyywiki.cn/pages/OS/manuals/sysv-abi.pdf <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>读手册的逻辑</strong><br>如果想要了解某部分知识，需要去观看包含其的对应的手册。但是很多手册（Friendly Manual）都有大量的依赖知识，只有拥有了这些依赖知识才能读懂这个手册。因此不能直接读手册，而是先学习简单的模型，回到7、80年代的概念，然后在学习手册当中最核心的部分，随着积累越来越多在逐渐往外扩展。</p>
<h3 id="16-1-2-可执行文件：状态机的描述"><a href="#16-1-2-可执行文件：状态机的描述" class="headerlink" title="16.1.2 可执行文件：状态机的描述"></a>16.1.2 可执行文件：状态机的描述</h3><p><strong>简介</strong><br>可执行文件在OS当中是被execve调用的，而execve是把当前进程的状态机进行重置。所以由此可以进行一个推论：<br><strong>可执行文件，是一个状态机的初始状态的描述</strong>（或者说时描述一个状态机被重置之后的状态），并且还描述了状态机之后的数据迁移。<br>[[Lecture 11：操作系统上的进程#11.3 进程与execve()]]</p>
<p><strong>问题：如果自己要实现一个可执行文件，应该涵盖什么</strong><br>因为可执行文件就是用于描述状态机重置之后的初始状态，那状态机的状态无非就是：</p>
<ol>
<li><p>寄存器<br>查看方式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">info registers</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829192659.png"
                     
                ><br>这当中有些值是由在状态机的初始状态下直接将其赋为0，比如r8~r15寄存器，其不需要在二进制数据中进行指定；有些是需要指定的，比如rip寄存器的值；还有些是由OS来为其分配的，比如rsp寄存器；</p>
</li>
<li><p>内存（地址空间）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">info inferiors //获得进程号</span><br><span class="line">pmap 390489    //打印地址空间</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>所有这些地址空间中的数据，比如592k的可读可执行，首先会有两个问题：1、其地址在哪里；2、其初始值为多少；这些就是其初始值信息。<br>[[Lecture 12：进程的地址空间]]</p>
<p><strong>可执行文件的本质</strong><br>可执行文件就是一个数据结构，描述了状态机的 初始状态 + 迁移，然后再思考将什么信息放入到二进制文件里。</p>
<h3 id="16-1-3-操纵系统上的可执行文件"><a href="#16-1-3-操纵系统上的可执行文件" class="headerlink" title="16.1.3 操纵系统上的可执行文件"></a>16.1.3 操纵系统上的可执行文件</h3><p><strong>文件的可执行权限</strong><br>更改文件权限指令：<br>以下是添加一个可执行权限</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x a.out</span><br></pre></td></tr></table></figure></div>
<p>如果将一个可执行文件的可执行权限抹除掉，此时再对其进行执行将产生报错；而如果将一个源代码文件的可执行权限打开，强行将一个源代码文件改为可执行：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x a.c</span><br></pre></td></tr></table></figure></div>
<p>此时将产生一个Permission denied的报错。</p>
<p><strong>是谁决定了一个文件能不能执行？</strong><br>执行一个程序时会使用execve系统调用，在使用execve读取可执行文件时，OS才会去检查其可执行权限；<br>![[Pasted image 20230322163623.png]]<br>但是如果将a.out文件的可执行权限抹除掉，此时再使用strace观察进程的系统调用会变成如下情况：<br>![[Pasted image 20230322163934.png]]<br>此时操作系统返回了EACCES，给了一个错误信息；<br>但如果将一个a.c文件，将其权限改为可执行文件，此时再去观测去strace其报错会变成：Exec format error信息，表示OS无法识别此可执行文件。 </p>
<h3 id="16-1-4-常见的可执行文件"><a href="#16-1-4-常见的可执行文件" class="headerlink" title="16.1.4 常见的可执行文件"></a>16.1.4 常见的可执行文件</h3><p>核心：<strong>可执行文件就是一个操作系统内的普通对象；</strong></p>
<p><strong>She-bang</strong><br>可以在一个c语言的文件中写入以下内容：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">#感叹号/usr/bin/python3</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span><br></pre></td></tr></table></figure></div>
<p>此时这个a.c文件就变得可执行了，并且输出了Hello。</p>
<p>She-bang机制：可以在代码当中跟一个可执行文件，然后程序会去执行它。<br>当操作系统发现了一个“#！”后，execve会把#！后背的内容填写到execve的第一个参数，把file文件填写到第二个参数；<br>所以She-bang就是一个偷梁换柱的execve。</p>
<h2 id="16-2-解析可执行文件"><a href="#16-2-解析可执行文件" class="headerlink" title="16.2 解析可执行文件"></a>16.2 解析可执行文件</h2><h3 id="16-2-1-GNU-binutils-工具"><a href="#16-2-1-GNU-binutils-工具" class="headerlink" title="16.2.1 GNU binutils 工具"></a>16.2.1 GNU binutils 工具</h3><p>部分工具：<br>![[Pasted image 20230322190921.png]]<br>这些工具可以用在可执行文件上：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">readelf -h a.out</span><br></pre></td></tr></table></figure></div>

<p>可执行文件就是描述状态机初始状态的数据结构，而binutils就是解析这个数据结构的工具；比如objdump就是把代码的汇编语言解析出来，其就是对于数据结构的查看、生成、修改的工具。</p>
<h3 id="16-2-2-可执行文件的运行时状态"><a href="#16-2-2-可执行文件的运行时状态" class="headerlink" title="16.2.2 可执行文件的运行时状态"></a>16.2.2 可执行文件的运行时状态</h3><p>还可以使用调试器来获得可执行文件的运行时状态，info可以帮助debugger获得运行时状态。<br>GDB获得调用栈信息：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb)bt</span><br></pre></td></tr></table></figure></div>
<p>为什么GDB可以打印程序的back trace?GDB如何通过内存里面的信息打印出以上的信息？<br>因为二进制文件当中有一些额外信息，这些额外信息可以帮助你实现<code>addr2line</code>命令；</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">addr2line 0x401cfb a.out</span><br></pre></td></tr></table></figure></div>
<p>然后会打印目标位置对应的行号：</p>
<h3 id="16-2-3-调试信息"><a href="#16-2-3-调试信息" class="headerlink" title="16.2.3 调试信息"></a>16.2.3 调试信息</h3><p>在进行GCC编译的时候，如果加上了-S 选项，会加上一些额外的调试信息；</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -static source.c -g -S</span><br></pre></td></tr></table></figure></div>
<p>使用-g表示生成汇编代码，在这其中生成了很多更多的调试信息；</p>
<p><strong>DWARF通用调试信息</strong><br>编译器在编译时会生成很多额外的信息（DWARF调试信息），这些调试信息十分通用；其允许你对于任何一段内存定义一个函数f()，然后如果你的程序指针pc指向这里，每一段内存都有一个f()函数，调用这个f()就可以把这些内存当中存储的信息获得出来。</p>
<p><strong>优化后的调试信息问题</strong><br>但是因为编译器的优化，导致在进行分析调试信息的时候，经常会产生一些错误，即把二进制的状态转换成汇编层面的语义十分具有挑战性。</p>
<p><strong>程序BackTrace与GCC优化Bug</strong><br>在获得程序的backtrace时，需要获得每个被调用函数的地址。此时如果将函数在栈上通过寄存器的数值保存的rbp的数值来生成一个链表，可以通过访问此链表的方式来获得当前函数的每个地址信息。但是如果使用了gcc的-O2优化，则很多个函数会在优化后被合成一个函数，此时就无法获得其在C语言语言层面上的调用栈信息，进而无法获得其函数调用的backtrace。</p>
<p><strong>逆向工程</strong><br>如果想获得一个商业软件的可执行文件里面，恢复其尽可能多的信息，就需要进行你想工程。<br>工具：ida<br>书籍：《IDApro权威指南》</p>
<h2 id="16-3-链接与重定位"><a href="#16-3-链接与重定位" class="headerlink" title="16.3 链接与重定位"></a>16.3 链接与重定位</h2><h3 id="16-3-1-从C代码到二进制文件"><a href="#16-3-1-从C代码到二进制文件" class="headerlink" title="16.3.1 从C代码到二进制文件"></a>16.3.1 从C代码到二进制文件</h3><p>在使用gcc编译链接之后，一个代码当中对于未定义函数的使用，是如何通过链接，访问到其他代码当中的函数的？</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面是main函数，f()未定义</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//这里是f()的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在使用gcc将main()函数对应的代码变成汇编代码之后，程序的大部分内容都已经被确定，但是还剩下部分callq指令（函数调用）未被确定：<br>![[Pasted image 20230328192912.png]]<br>此时其还不知道此函数的地址，其会生成00来填充；</p>
<p><strong>汇编且还未链接的程序的设计语义</strong>：main.o就是一个数据结构，在这个数据结构当中包含了所有重要的代码，并且还包含了其<strong>未来需要满足的内容的约束</strong>。而在函数调用时，其就是相对偏移量的约束，S(目标函数位置) + A(-4) - P(P &#x3D; main + 0xb)。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assert(</span><br><span class="line">	(<span class="type">char</span> *)hello == </span><br><span class="line">	(<span class="type">char</span> *)main + </span><br><span class="line">	<span class="number">0xf</span> +</span><br><span class="line">	*(<span class="type">int32_t</span> *)((<span class="type">uintptr_t</span>)main + <span class="number">0xb</span>));</span><br></pre></td></tr></table></figure></div>

<h3 id="16-3-2-重新理解编译、链接过程"><a href="#16-3-2-重新理解编译、链接过程" class="headerlink" title="16.3.2 重新理解编译、链接过程"></a>16.3.2 重新理解编译、链接过程</h3><p><strong>编译器（gcc）</strong></p>
<ul>
<li>High-level semantics (C 状态机) → low-level semantics (汇编)</li>
</ul>
<p><strong>汇编器 (as)</strong></p>
<ul>
<li>Low-level semantics → Binary semantics (状态机容器)<ul>
<li>“一一对应” 地翻译成二进制代码<ul>
<li>sections, symbols, debug info</li>
</ul>
</li>
<li>不能决定的要留下 “之后怎么办” 的信息<ul>
<li>relocations</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>链接器 (ld)</strong></p>
<ul>
<li>合并所有容器，得到 “一个完整的状态机”<ul>
<li>ldscript (<code>-Wl,--verbose</code>); 和 C Runtime Objects (CRT) 链接</li>
<li>missing&#x2F;duplicate symbol 会出错</li>
</ul>
</li>
</ul>
<p><strong>图示：</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829192839.png"
                     
                ></p>
<p>而在这些过程当中，ELF只不过是一个描述以上过程的一个“容器数据结构”，包含了完成以上过程所需的必要信息：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829192904.png"
                     
                ><br>正确的理解ELF的方式是：当你自己想要实现一个ELF时，有哪些部分是必不可少的？</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">executable</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="type">uint32_t</span> entry; <span class="comment">//代码的进入点地址：代码、数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">segment</span> *<span class="title">segments</span>;</span> <span class="comment">//不同的段</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reloc</span> *<span class="title">relocs</span>;</span><span class="comment">//重定位</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">symbol</span> *<span class="title">symbols</span>;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="type">uint32_t</span> flags, size; <span class="comment">//每个段是可执行可读？还是可执行？可写？</span></span><br><span class="line">	<span class="type">char</span> data[<span class="number">0</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reloc</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="type">uint32_t</span> S, A, P;<span class="comment">//用于计算重定位后的地址</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">32</span>]; <span class="comment">//重定位地址的名字</span></span><br><span class="line">	&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symbol</span> &#123;</span> <span class="type">uint32_t</span> off; <span class="type">char</span> name[<span class="number">32</span>]; &#125;;</span><br></pre></td></tr></table></figure></div>
<p>然后在这么一个最简单的数据结构当中，会有很多缺陷，围绕这这些缺陷进行更多的设计，最终就形成了现在所看到的繁杂的ELF文件。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>可执行文件</tag>
        <tag>链接</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 17：动态链接与加载</title>
    <url>/2023/08/7c3f50531736.html</url>
    <content><![CDATA[<blockquote>
<p>前言：可执行文件就是一个描述状态机初始状态的数据结构；<br>问题：<br>    1、可执行文件如何被OS加载？<br>    2、什么是动态链接&#x2F;动态加载？</p>
</blockquote>
<span id="more"></span>
<h2 id="17-1-静态ELF文件加载器"><a href="#17-1-静态ELF文件加载器" class="headerlink" title="17.1 静态ELF文件加载器"></a>17.1 静态ELF文件加载器</h2><h3 id="17-1-1-ELF文件"><a href="#17-1-1-ELF文件" class="headerlink" title="17.1.1 ELF文件"></a>17.1.1 ELF文件</h3><p><strong>ELF文件定义</strong><br>在OS下面的“&#x2F;usr&#x2F;include&#x2F;elf.h”文件中，可以看到ELF文件定义描述；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829193028.png"
                     
                ><br><strong>获得程序的ELF</strong></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">readelf a.out</span><br></pre></td></tr></table></figure></div>
<p>使用此指令来获得可执行文件的elf文件信息，并将其翻译出来；<br>ELF文件描述了一个数据结构，这个数据结构描述了进程在execve之后被Loader使用时如何加载；</p>
<h3 id="17-1-2-ELF加载器"><a href="#17-1-2-ELF加载器" class="headerlink" title="17.1.2 ELF加载器"></a>17.1.2 ELF加载器</h3><p>Loader所作行为：解析数据结构 + 复制信息到内存 + 跳转<br><strong>Loader需加载内容</strong></p>
<ul>
<li>1、ELF文件里面的信息</li>
<li>2、设置一些运行时状态<ul>
<li>argv</li>
<li>envp<br>以上两部分内容共同构成进程的初始状态；</li>
</ul>
</li>
</ul>
<p><strong>Loader实现了解</strong><br>Loader只是个程序，其通过动态链接的方式编译；<br>在编译之后，可以往Loader传入一个参数：比如某个程序，此时Loader会开始将ELF文件搬到指定的位置上，并且可以是使用此Loader加载其他程序。<br>在Loader当中，使用mmap + ELF信息映射到内存当中； Loader解析ELF数据结构，然后把对应内容放到内存；<br>当所有的内容都使用mmap搬进内存之后，可以使用pmap观看其地址空间：<br>可以看到其地址空间当中有两份程序，一份是loader的内存，一份是minimal的内容；即当前ELF所有具体的内容都被加载；</p>
<h3 id="17-1-3-进程初始状态设置"><a href="#17-1-3-进程初始状态设置" class="headerlink" title="17.1.3 进程初始状态设置"></a>17.1.3 进程初始状态设置</h3><p>完成对于进程的栈以及其他空间的初始化设置；<br>实例化进程Stack：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829193055.png"
                     
                ><br>比如：当中指明了rsp寄存器指向Argument Count，并且8 + rsp执行后续的参数；<br>有了这个手册之后，之后的行为就是把这些内容实现成代码。</p>
<p><strong>初始化代码实现</strong></p>
<ol>
<li>先静态分配一片空间，将此空间设置为栈空间；<ol>
<li>![[Pasted image 20230329190038.png]]</li>
</ol>
</li>
<li>定义对应的push指令，可以将内容push到栈中；</li>
<li>对照着实例化进程文档，将内容push到栈上；<ol>
<li>![[Pasted image 20230329190137.png]]</li>
<li>argc、argv以及环境变量等，依次压入栈中；</li>
</ol>
</li>
<li>最后执行跳转<ol>
<li>![[Pasted image 20230329190308.png]]</li>
<li>将程序的入口地址给到指针，将rdx和rsp清零；</li>
</ol>
</li>
</ol>
<p><strong>OS、Loader与execve之间关系</strong><br>以上实现的第一个Loader是在OS上实现的，基于操作系统中的open、mmap、close，使用这些系统调用实现了一个execve，因此execve在某种程度上不是必须的，Linux可以基于ld静态链接，加上mmap、open等系统调用，就完成程序的加载。<br>由此可知：相当一部分系统调用可以实现成用户态的；</p>
<h3 id="17-1-4-Boot-Block-Loader"><a href="#17-1-4-Boot-Block-Loader" class="headerlink" title="17.1.4 Boot Block Loader"></a>17.1.4 Boot Block Loader</h3><p><strong>什么是Boot Block Loader</strong><br>由固件实现的Boot Block Loader，将OS通过固件，一点一点加载到磁盘上、内存里。并且除了这512字节的最开始的block，在这之后还有1024字节的main args，在这之后是OS的Kernel内核文件。</p>
<p><strong>加载OS内核</strong><br>哪怕ELF文件只有512字节的二进制文件，也可以为其写一个Loader；</p>
<ul>
<li>![[Pasted image 20230329191754.png]]<br>把Main函数的参数加载进来，并在之后把elf32复制，创建状态机的状态；<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">load_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  Elf32_Ehdr *elf32 = (<span class="type">void</span> *)<span class="number">0x8000</span>;</span><br><span class="line">  Elf64_Ehdr *elf64 = (<span class="type">void</span> *)<span class="number">0x8000</span>;</span><br><span class="line">  <span class="type">int</span> is_ap = boot_record()-&gt;is_ap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!is_ap) &#123;</span><br><span class="line">    <span class="comment">// load argument (string) to memory</span></span><br><span class="line">    copy_from_disk((<span class="type">void</span> *)MAINARG_ADDR, <span class="number">1024</span>, <span class="number">-1024</span>);</span><br><span class="line">    <span class="comment">// load elf header to memory</span></span><br><span class="line">    copy_from_disk(elf32, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (elf32-&gt;e_machine == EM_X86_64) &#123;</span><br><span class="line">      load_elf64(elf64);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      load_elf32(elf32);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// everything should be loaded</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (elf32-&gt;e_machine == EM_X86_64) </span><br><span class="line">  &#123;</span><br><span class="line">    ((<span class="type">void</span>(*)())(<span class="type">uint32_t</span>)elf64-&gt;e_entry)();<span class="comment">//设置程序进入点</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  &#123;</span><br><span class="line">    ((<span class="type">void</span>(*)())(<span class="type">uint32_t</span>)elf32-&gt;e_entry)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="17-2-Linux内核加载器"><a href="#17-2-Linux内核加载器" class="headerlink" title="17.2 Linux内核加载器"></a>17.2 Linux内核加载器</h2><p>使用make进行编译，然后即可以对其进行调试；之后可以使用GDB，和调试其他的可执行程序一样来调试这个Linux代码，只要将BreakPoint放在代码的EntryPoint上即可。<br>之后如果想进行进一步的调试，就得开始使用一些更加现代的工具以及IDE，比如VSCode来把Linux内核放入到VSCode当中；<br>可以将Linux生成的哪些链接信息给到VSCode，这样就可以在编辑界面当中来动态的获得一个内容的链接内容；</p>
<h2 id="17-3-动态链接与加载"><a href="#17-3-动态链接与加载" class="headerlink" title="17.3 动态链接与加载"></a>17.3 动态链接与加载</h2><h3 id="17-3-1-为什么需要动态链接"><a href="#17-3-1-为什么需要动态链接" class="headerlink" title="17.3.1 为什么需要动态链接"></a>17.3.1 为什么需要动态链接</h3><p><strong>静态链接问题</strong></p>
<ul>
<li>随着项目越来越大，库函数越来越大，文件系统会越来越膨胀，需要占有大量的磁盘空间；即不希望每个库函数都在可执行文件里面进行库函数的拷贝；</li>
<li>同时，大型项目有把应用程序拆开的需求；</li>
</ul>
<p><strong>动态链接</strong><br>只要库函数遵循一定的标准，那么就可以把这个库在运行动态的链接；编译一部分，不用重新链接；</p>
<p><strong>工业界实际的ELF问题</strong><br>ELF是一个数据结构，这个数据结构当中有专门的符号表，将一些概念上紧密相关的东西在数据结构中通过符号表（为了提升性能）强行拆散；</p>
<h3 id="17-3-2-自顶向下设计的动态链接实现"><a href="#17-3-2-自顶向下设计的动态链接实现" class="headerlink" title="17.3.2 自顶向下设计的动态链接实现"></a>17.3.2 自顶向下设计的动态链接实现</h3><p><strong>基本假设</strong><br>假设所有的加载器、编译器、链接器都完全收你控制，此时生成一个最小的用于动态链接的数据结构，然后再在此基础上针对ELF进行优化；</p>
<p><strong>最小的ELF</strong><br>当想要实现自己的库函数，当中有一个putchar的符号需要被动态加载，如何进行设计？<br>简化之后，动态链接最基本的行为：</p>
<ul>
<li>LOAD（“libc.dl”）&#x2F;&#x2F;加载动态库</li>
<li>IMPORT（putchar）&#x2F;&#x2F;加载外部符号</li>
<li>EXPORT（hello）&#x2F;&#x2F;为动态库导出符号</li>
<li>在代码中引用一个外部库的符号</li>
</ul>
<h4 id="17-3-2-1-最小加载器实现"><a href="#17-3-2-1-最小加载器实现" class="headerlink" title="17.3.2.1 最小加载器实现"></a>17.3.2.1 最小加载器实现</h4><p>JYY实现的最小动态链接加载器；<br>![[Pasted image 20230330174916.png]]<br>自己实现的最简单的二进制文件格式：<br>![[Pasted image 20230330175114.png]]</p>
<h4 id="17-3-3-2-动态链接Header定义"><a href="#17-3-3-2-动态链接Header定义" class="headerlink" title="17.3.3.2 动态链接Header定义"></a>17.3.3.2 动态链接Header定义</h4><p>使用此Header定义此二进制可执行文件的格式；<br>最简单的二进制动态链接文件：就是由一个头文件和一个符号表构成的；</p>
<p><strong>dl_Header代码：</strong><br>![[Pasted image 20230414182843.png]]<br><strong>dl_Header图示：</strong><br>![[Lecture 17：动态链接与加载 2023-04-14 18.22.19.excalidraw]]</p>
<p><strong>定义的四个宏</strong><br>![[Pasted image 20230414182950.png]]<br>第一个：IMPORT</p>
<ol>
<li>在Imoort当中使用DSYM函数</li>
<li>在DSYM函数中当中传入sym（比如说是putchar，目标链接函数名称）</li>
<li>当前sym当中传入间接寻址的地址rip，然后putchar指向symbol当中的offset。<br>第二个：EXPORT<br>向当中传入一个外部符号的调用，为了导出这个符号，在offset当中保存这个符号的相对于符号头部的偏移量；</li>
</ol>
<p><strong>程序预编译之后</strong><br>![[Pasted image 20230414184042.png]]<br>每一个symbol都被对齐到32字节，offset开始时为0，此时加载器发现了这个符号的offset的值为零，此时就会开始间接调转，查询符号表，将地址填入到这当中。</p>
<p>符号链接：当你想要跳转到一个你所不知道的地址上时，就现找一块数据（offset）填上零，然后做一个间接跳转，在加载器进行加载的时候，查符号表，将地址填进去；</p>
<p><strong>二进制视角文件</strong><br>![[Pasted image 20230414185023.png]]<br>第20行，前面八位的全零部分标志，以及libc.dl表示的需要链接的程序；<br>包括90，a0部分的全零内容，对应的多个struct symbol之后的全零字段；<br>然后c0,d0之后就是代码的部分；</p>
<h3 id="17-3-3-对动态链接定义的加载"><a href="#17-3-3-对动态链接定义的加载" class="headerlink" title="17.3.3 对动态链接定义的加载"></a>17.3.3 对动态链接定义的加载</h3><p><strong>对dl的加载代码：</strong><br>![[Pasted image 20230414185311.png]]<br>就是扫描符号表，将dl二进制文件中对应的符号找到其需要的地址；碰到LOAD就打印其名称，碰到EXTERN就打印其对应内容；</p>
<p><strong>objump实现</strong><br>![[Pasted image 20230414185450.png]]<br>两个For循环内的内容：</p>
<ul>
<li>第一层for循环：遍历符号表</li>
<li>第二层：遍历代码的每一个字节<ul>
<li>当代码的某一个字节刚好对应某一个符号的时候，执行一个反汇编，使用ndisasm反汇编器将代码输出出来；</li>
</ul>
</li>
</ul>
<p><strong>加载器主要部分：dlopen</strong><br>![[Pasted image 20230414190056.png]]<br>首先获得dl的hdr头文件，然后把path文件打开，解析文件头；<br>通过解析文件头知道了文件有多大后，使用mmap将其需要的内容直接映射到内存当中；<br>如果内存映射成功，在for循环内遍历符号表，如果符号表当中是+号则进行递归加载，如果是问号，则直接赋值offset内容；</p>
<h3 id="17-3-4-自己设计DL文件中的缺陷"><a href="#17-3-4-自己设计DL文件中的缺陷" class="headerlink" title="17.3.4 自己设计DL文件中的缺陷"></a>17.3.4 自己设计DL文件中的缺陷</h3><p><strong>代码分段</strong><br>自己编写的代码只能可读可写可执行，想要不同部分不同类型，就需要进行分段；<br><strong>指定加载器</strong><br>需要指定一个加载器</p>
<p>写一个编译器的时候，在编译器的视角里面，C代码当中出现的函数，不知道其是静态链接的还是动态链接；不知道是用call还是call DASM，而且不知道外部符号在哪里；并且call是不需要间接跳转的；<br>当链接时发现是一个动态链接符号的话，就需要靠plt去找内容，因此就发明了GOT和PLT；</p>
<p>全局偏移表：<br>![[Pasted image 20230414191207.png]]<br>在ELF文件之下：<br>![[Pasted image 20230414191222.png]]<br>所有的间接跳转，全部都在PLT里面；</p>
<p><strong>GOT</strong><br>我们的符号表就是GOT（Global Offset Table）</p>
<p><strong>对于静态、动态链接的统一</strong><br>无论静态动态，都统一使静态链接先；<br>然后增加一层间接层：Procedure Linkage Table（PLT），将所有未被解析的符号都统一翻译成call。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">putchar</span> PLT:</span><br><span class="line">	call DSYM（<span class="built_in">putchar</span>）</span><br><span class="line">main:</span><br><span class="line">	call <span class="built_in">putchar</span> PLT</span><br></pre></td></tr></table></figure></div>

<p>作业：读实例代码；</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>链接</tag>
        <tag>ELF</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 28：持久数据的可靠性</title>
    <url>/2023/08/2a905fcc408b.html</url>
    <content><![CDATA[<ul>
<li>前言：文件系统和OS的耦合度<ul>
<li>相比于进程以及虚拟化部分，文件系统和OS的耦合程度相对较低；</li>
<li>从 1-bit 数据 -&gt; 设备 -&gt; 驱动 -&gt; Block IO（Bread&#x2F;Bwrite） -&gt; Block Array 在块的数组上构建文件系统 -&gt; 目录结构</li>
<li>这当中已经经过了很多层的抽象，对于底层的实现细节抽象程度高；</li>
</ul>
</li>
<li>文件系统算法与持久化<ul>
<li>文件系统算法的基本假设是：内存可靠，以及接受断电数据丢失（这部分内容是文件系统的数据结构实现的假设）</li>
<li>但：磁盘上的数据是不接受丢失的。如何保证持久数据的可靠性；<span id="more"></span></li>
</ul>
</li>
</ul>
<h2 id="28-1-RAID"><a href="#28-1-RAID" class="headerlink" title="28.1 RAID"></a>28.1 RAID</h2><p>RAID：Redundant Array of lnexpensiveDisks；</p>
<h3 id="28-1-1-存储需求"><a href="#28-1-1-存储需求" class="headerlink" title="28.1.1 存储需求"></a>28.1.1 存储需求</h3><p><strong>持久存储的需求：性能</strong><br>因为有超大容量的计算中心，才能实现现在互联网上大量的数据。只要CPU处理的过来，就尽可能多的放硬盘；<br>因此在计算中心当中，有专门用于存储数据的服务器，这当中有上百块磁盘：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829204003.png"
                     
                ></p>
<p><strong>持久存储的需求：可靠性</strong></p>
<ul>
<li>基本前提<ul>
<li>任何物理存储的介质都有失效的可能性；</li>
<li>小概率事件：硬盘损坏（但 大量重复 &#x3D; 必然发生）</li>
</ul>
</li>
</ul>
<p><strong>两方面的需求：性能与可靠性</strong><br>当性能高时，大量的设备就会增加出错的可能性，进而减少可靠性；但依然需要可靠性，才能保证系统正常使用；</p>
<ul>
<li>解决方法：RAID<ul>
<li>存储设备的虚拟化</li>
<li>图灵奖论文：<a class="link"   href="https://dl.acm.org/doi/10.1145/971701.50214" >https://dl.acm.org/doi/10.1145/971701.50214 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>内容：证明了可靠性和性能可以兼得；</li>
</ul>
</li>
</ul>
<h3 id="28-1-2-RAID：存储设备的虚拟化"><a href="#28-1-2-RAID：存储设备的虚拟化" class="headerlink" title="28.1.2 RAID：存储设备的虚拟化"></a>28.1.2 RAID：存储设备的虚拟化</h3><p><strong>RAID内容</strong><br>对于磁盘内容反向的虚拟化；</p>
<ul>
<li>内容简介：<ul>
<li>不同的虚拟化<ul>
<li>进程：把一个CPU分时虚拟成多个虚拟CPU</li>
<li>虚存：把一份内存通过MMU虚拟成多个地址空间；</li>
<li>文件：把一个存储设备虚拟成多个虚拟磁盘；</li>
</ul>
</li>
<li>可以有很多个磁盘，每一个都不太可靠。可以把这些磁盘的整体当成是一个虚拟的磁盘。当有一个磁盘消失时，虚拟磁盘不会收到任何的影响；</li>
</ul>
</li>
</ul>
<p><strong>RAID基本假设</strong></p>
<ul>
<li>假设一：磁盘可能在某个时候就突然彻底无法访问；<ul>
<li>机械故障；</li>
<li>芯片故障；</li>
</ul>
</li>
<li>假设二：有很多个磁盘；</li>
</ul>
<h3 id="28-1-3-RAID实现：最简单的版本"><a href="#28-1-3-RAID实现：最简单的版本" class="headerlink" title="28.1.3 RAID实现：最简单的版本"></a>28.1.3 RAID实现：最简单的版本</h3><p>假设现在有v1和v2两个虚拟磁盘，然后还有A和B两个物理磁盘；<br>当需要保证可靠性时，只需要让v1的数据和v2的数据各自在AB上存储一份：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829212321.png"
                     
                ><br>因此，任何一块盘丢了之后都不会对系统产生致命影响，大幅提高了可靠性；<br>并且，当需要对磁盘进行读写时，速度可以更快，因为可以A和B一起读，各自读一半的数据，因此速度提高了一倍：<br><em>不过写入的速度还是50%</em><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829212645.png"
                     
                ></p>
<h3 id="28-1-4-RAID实现：设计空间"><a href="#28-1-4-RAID实现：设计空间" class="headerlink" title="28.1.4 RAID实现：设计空间"></a>28.1.4 RAID实现：设计空间</h3><ul>
<li><p>例子：把两个1t的物理磁盘（AB）虚拟化成一个2t的虚拟磁盘；</p>
<ul>
<li>此时如果相对盘进行读写时，比如读V1和V2，此时速度并没有翻倍。</li>
<li>因为B1、B2在看戏；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829213035.png"
                     
                ></li>
</ul>
</li>
<li><p>设计目的：同时利用带宽</p>
<ul>
<li>将内容随机映射，使得AB都有空间；</li>
<li>此时如果读V3V4，此时在虚拟磁盘上还是连续的，并且可以同时读写；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829213258.png"
                     
                ></li>
</ul>
</li>
</ul>
<p><strong>设计空间</strong><br>此时对于文件而言，就是以下过程</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(i)： 如何把Vi映射到f(i)块上，即设计空间</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829213624.png"
                     
                ></p>
<p><strong>RAID-10</strong><br>假设有4块盘，此时可以先用两块组成RAID1，在用两外两块组成RAID2；最终一起组成RAID0；<br>一起对应成4块物理磁盘ABCD；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829214052.png"
                     
                ><br>此时V1234分别放在了ABCD上，并且用于很高的带宽及其稳定度。其可以容忍任何一块磁盘出现事故；并且可以并行的方式进行读写；<br>并且：假设A和C都坏了，V1234都还正常存储；</p>
<ul>
<li>RAID-10：有时能容忍两块盘坏，有时候却不能。如果我们有很多块盘，能否减少浪费?</li>
</ul>
<h3 id="28-1-5-RAID实现：奇偶校验和"><a href="#28-1-5-RAID实现：奇偶校验和" class="headerlink" title="28.1.5 RAID实现：奇偶校验和"></a>28.1.5 RAID实现：奇偶校验和</h3><p>当前如果有4块盘，可以有3块专门用于存放数据，还有一块专门用于存放奇偶校验；<br>把ABC当作是RAID0，并且V234依然是连续的；<br>磁盘D专门用于存储校验和。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829214910.png"
                     
                ></p>
<p>当有100块盘时，可以用99块来存储数据，1块来存储奇偶校验和。</p>
<ul>
<li>问题<ul>
<li>这种方法读取速度很快，连续写入很快；</li>
<li>但是随机写入的速度十分的满；</li>
<li>随机写的性能成为了性能的瓶颈；</li>
</ul>
</li>
</ul>
<h3 id="28-1-6-RAID实现：每块盘都是奇偶盘"><a href="#28-1-6-RAID实现：每块盘都是奇偶盘" class="headerlink" title="28.1.6 RAID实现：每块盘都是奇偶盘"></a>28.1.6 RAID实现：每块盘都是奇偶盘</h3><p>可以在每一盘上面都放上奇偶盘；每一块盘都可以作为奇偶盘。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829215520.png"
                     
                ></p>
<p><strong>性能分析：盘越多，速度越快</strong><br>RAID把很多不可靠的磁盘，变成了又快有可靠的磁盘；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829215605.png"
                     
                ></p>
<p><strong>But：谷歌把所有不可靠的计算机，变得分布式的可靠</strong><br>因此云计算革掉了大型机计算的命。计算机进入大数据时代。</p>
<h2 id="28-2-崩溃一致性与崩溃恢复"><a href="#28-2-崩溃一致性与崩溃恢复" class="headerlink" title="28.2 崩溃一致性与崩溃恢复"></a>28.2 崩溃一致性与崩溃恢复</h2><p>在有了RAID之后，可以保证数据的存储的可靠性；但是对于一致性的实现还需要这部分内容；</p>
<ul>
<li><strong>即使磁盘现在是可靠的，但软件依然可能不可靠</strong><ul>
<li>比如OS突然蓝屏了，电脑Crash；操作系统内容Crash然后蓝屏；</li>
<li>系统随时可能会发生断电；<ul>
<li>但从此时有可能正在往文件系统里面写入数据，写入到磁盘上；</li>
</ul>
</li>
<li>但：文件系统是OS上的一个数据结构</li>
</ul>
</li>
</ul>
<h3 id="28-2-1-文件存储行为"><a href="#28-2-1-文件存储行为" class="headerlink" title="28.2.1 文件存储行为"></a>28.2.1 文件存储行为</h3><p><strong>一个文本文件的存储</strong><br>当现在有一个文本文件，且需要往里面写入一段数据时，此时行为就是：</p>
<ul>
<li>把文件 变成一堆 bwrite和bread 的指令，并且此时文件的元数据也需要更改；</li>
<li>并且此时会有一块新写入数据的Data区域；</li>
<li>文件系统的EOF也需要更改<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230831213400.png"
                     
                ></li>
<li>fat1 </li>
<li>fat2</li>
</ul>
</li>
</ul>
<p><strong>如果想要把一个文件持久化保存时，此时一个文件需要多个数据块（bwrite和bread）；</strong><br>问题：应该按照什么样的顺序将其存入进去呢？并且如果此时断电，该如何应对呢？<br>并且还可能出现数据不一致的状态；</p>
<ul>
<li>文件系统<ul>
<li>即使只是加上一个字节，也涉及多块磁盘的更改；</li>
</ul>
</li>
</ul>
<h3 id="28-2-2-崩溃一致性"><a href="#28-2-2-崩溃一致性" class="headerlink" title="28.2.2 崩溃一致性"></a>28.2.2 崩溃一致性</h3><p>Crash Consistency: Move the file system from one consistentstate (e.g: before themle got appended to) to anotheratomically (e.g: after the inode, bitmap, and new data blockhave been written to disk)<br>所有平时编程时假设不会发生的事情，OS都需要进行兜底；磁盘不仅不支持多块读些的功能，甚至还不支持顺序读写；</p>
<ul>
<li>当有多条存储指令到来时，有可能会发生乱序进行的情况；</li>
</ul>
<p><strong>bwrite和bread之外，OS提供的指令：bflush</strong><br>可以在两个有顺序要求的指令之间，插入一条bflush指令，即要求此命令的执行顺序不能越过此bflush指令；</p>
<ul>
<li>类似于并发里面的barrier</li>
</ul>
<p><strong>磁盘乱序的后果</strong><br>任何一个写入的子集都有乱序的可能：有可能在某一个move的操作时，就有可能发生问题；随时都有可能因为磁盘写入时的状态不一致，导致损坏产生；</p>
<h3 id="28-2-3-FSCK"><a href="#28-2-3-FSCK" class="headerlink" title="28.2.3 FSCK"></a>28.2.3 FSCK</h3><p>文件系统检查：File System Checking<br><strong>核心：根据磁盘上的已有信息，恢复出最有可能的数据结构</strong></p>
<ul>
<li>文件系统可能会有不一致的情况；</li>
<li>通过制定一定的规则，恢复磁盘上的数据结构；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230831235530.png"
                     
                ><br><em>针对crash，需要一个更可靠的方法</em><br>比如在文件崩溃断电后，此时重写挂载会进行磁盘一致性（状态）检查。但如果此时又发生一次断电，这些数据可能就永远消失了；</li>
</ul>
<p><strong>FSCK方法的局限性</strong><br>FSCK方法并不是解决崩溃不一致性的最终方法，根本性的方法是：用数据结构的方法；</p>
<h3 id="28-2-4-日志"><a href="#28-2-4-日志" class="headerlink" title="28.2.4 日志"></a>28.2.4 日志</h3><p><strong>不用数据结构记录，而是记录操作</strong><br>除了会有当前全部数据所构成的状态；包括当前数据里面所有的结构、数据、字段、数等等内容；<br>但同时，还可以构建另外一种状态，此状态<strong>存储了当前对于数据的操作序列</strong>；比如什么时候插入一个序列，什么时候删除一个数据等等。<br>只要“Append”only，就可以把状态恢复出来。（即把所有的历史操作记录下来）</p>
<p><strong>日志</strong><br>当数据结构发生变化时，先用append only记录日志。当日志落盘后，在更新实际数据的数据结构；<br>崩溃没关系，只要重放日志并清楚，就可以redo log：把需要的数据再读写一遍；</p>
<p><strong>如何实现：随意append任意大小的数据</strong><br>如何通过用bread，bwrite和bflush实现append()？<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230901000727.png"
                     
                ></p>
<ol>
<li>定位到 journal 的末尾 (bread)</li>
<li>bwrite TXBegin 和所有数据结构操作</li>
<li>bflush 等待数据落盘</li>
<li>bwrite TXEnd</li>
<li>bflush 等待数据落盘</li>
<li>将数据结构操作写入实际数据结构区域</li>
<li>等待数据落盘后，删除 (标记) 日志</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>文件系统</tag>
        <tag>日志系统</tag>
        <tag>RAID</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 29：Xv6文件系统实现</title>
    <url>/2023/09/a4bbdf6f0414.html</url>
    <content><![CDATA[<p><strong>什么是文件系统</strong><br>图书馆支持的所有操作，就是文件系统需要的所有操作；</p>
<ul>
<li>新建一个书架-&gt;新建文件夹</li>
<li>在书架的基础上：加上一本书</li>
<li>书签：文件描述符</li>
</ul>
<p><strong>FAT文件系统实现</strong><br>使用链表将一个个的文件Cluster连起来；在目录的最前面使用metadata来描述一些元信息：文件大小、目录结构等等；<br>这些链表如果是顺序存储情况下，在内存里面也将是连续的。但如果出现不是线性的存储，则其链表以及Cluster可能会分布在内存的各地；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230904200953.png"
                     
                ></p>
<ul>
<li>UNIX文件系统实现<ul>
<li>UNIX的文件系统，把以上的FAT当中用于连接cluster的链表全部存储在了内存当中的一个固定的地方，此时可以通过读取此固定的地方来知道如何对文件进行操作；<span id="more"></span></li>
</ul>
</li>
</ul>
<h2 id="29-1-mkfs：创建文件系统"><a href="#29-1-mkfs：创建文件系统" class="headerlink" title="29.1 mkfs：创建文件系统"></a>29.1 mkfs：创建文件系统</h2><p><strong>实现：只管分配，不管回收</strong><br>这个mkfs就是只管分配，不管回收的代码；</p>
<ul>
<li>rsect&#x2F;wsect (bread&#x2F;bwrite)</li>
<li>balloc&#x2F;bzero</li>
<li>ialloc</li>
<li>iappend</li>
<li>rinode&#x2F;winode<br>不管是FAT还是UNIX，最基础的内容都是rsect和wsect函数（由OS提供）；</li>
</ul>
<p><strong>如何阅读xv6的文件系统部分代码</strong><br>无论代码多么复杂，最后都会变成rsect和wsect这两个接口的调用；<br>因此只要可以把这两个接口的调用全部找出来，就可以更轻松的阅读这部分代码；</p>
<ul>
<li>用Python写的控制gdb的脚本<ul>
<li>trace(gdb.Breakpoint)：打一个break点；<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">TRACED = <span class="string">&#x27;bwrite balloc ialloc iappend rinode winode rsect wsect&#x27;</span>.split()</span><br><span class="line">IGNORE = <span class="string">&#x27;ip xp buf&#x27;</span>.split()</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">trace</span>(gdb.Breakpoint):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        f, bt = gdb.selected_frame(), []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> f <span class="keyword">and</span> f.is_valid():</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (name := f.name()) <span class="keyword">in</span> TRACED:</span><br><span class="line"></span><br><span class="line">                lvars = [<span class="string">f&#x27;<span class="subst">&#123;sym.name&#125;</span>=<span class="subst">&#123;sym.value(f)&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> sym <span class="keyword">in</span> f.block()</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> sym.is_argument <span class="keyword">and</span> sym.name <span class="keyword">not</span> <span class="keyword">in</span> IGNORE]</span><br><span class="line"></span><br><span class="line">                bt.append(<span class="string">f&#x27;\033[32m<span class="subst">&#123;name&#125;</span>\033[0m(<span class="subst">&#123;<span class="string">&quot;, &quot;</span>.join(lvars)&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            f = f.older()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;    &#x27;</span> * (<span class="built_in">len</span>(bt) - <span class="number">1</span>) + bt[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># won&#x27;t stop at this breakpoint</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">gdb.execute(<span class="string">&#x27;set prompt off&#x27;</span>)</span><br><span class="line">gdb.execute(<span class="string">&#x27;set pagination off&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> fn <span class="keyword">in</span> TRACED:</span><br><span class="line">    trace(fn)</span><br><span class="line">gdb.execute(<span class="string">&#x27;run fs.img README user/_ls&#x27;</span>)</span><br><span class="line">gdb.execute(<span class="string">&#x27;quit&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
使用此指令来执行以上代码：<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gdb -ex &#x27;source mkfs/trace.py&#x27; mkfs/mkfs</span><br></pre></td></tr></table></figure></div>
mkfs 就是在磁盘上创建了一个数据结构，这个数据结构就是往一个文件的后背写入一些数据，不用管怎么删除。将代码最终变成 bread 和 bwrite；</li>
</ul>
</li>
</ul>
<h3 id="29-1-1-mkfs-问题"><a href="#29-1-1-mkfs-问题" class="headerlink" title="29.1.1 mkfs 问题"></a>29.1.1 mkfs 问题</h3><p><strong>mkfs 问题</strong><br>使用 mkfs 的时候，其会使用大量的 bread 和 bwrite ，并且一个简单的目录创建也会使用大量的代码。为了优化性能，另一种设计是使用 buffer cache 的技术。</p>
<h2 id="29-2-buffer-cache"><a href="#29-2-buffer-cache" class="headerlink" title="29.2 buffer cache"></a>29.2 buffer cache</h2><h3 id="29-2-1-buffer-cache-基础概念"><a href="#29-2-1-buffer-cache-基础概念" class="headerlink" title="29.2.1 buffer cache 基础概念"></a>29.2.1 buffer cache 基础概念</h3><p><strong>什么是 buffer cache</strong><br>在计算机操作系统中，Buffer Cache（缓冲区高速缓存）是一种机制，用于加速对磁盘和其他块设备的访问。它通过在内存中维护一个缓冲区来实现。</p>
<p><strong>作用：</strong><br>Buffer Cache 在操作系统中扮演着重要的角色，具体包括以下作用：</p>
<ol>
<li><strong>加速磁盘访问</strong>：通过存储最近读取的数据块，Buffer Cache 减少了直接从磁盘读取数据的次数，提高了读取操作的速度。  </li>
<li><strong>减少磁盘访问次数</strong>：当应用程序读取磁盘数据时，操作系统首先检查缓冲区是否存在所需的数据块，如果缓冲区中已有数据，直接从内存获取避免了频繁的磁盘访问。 </li>
<li><strong>优化写入操作</strong>：Buffer Cache 也用于写入操作。当应用程序要写入数据到磁盘时，操作系统首先将数据写入缓冲区，并记录更新信息。通过延迟将数据刷新到磁盘，系统可以在内存中进行高效的数据操作。</li>
</ol>
<p><strong>如何优化 buffer cache ?</strong><br>使用一定的算法，预测哪一些部分的数据更经常的被使用，然后提前将其读入到 buffer cache 当中；</p>
<h3 id="29-2-2-调试系统调用"><a href="#29-2-2-调试系统调用" class="headerlink" title="29.2.2 调试系统调用"></a>29.2.2 调试系统调用</h3><p><strong>写操作实现</strong><br>一个写的操作，会被分成很多个更小的写的操作；</p>
<ul>
<li>1 GB 文件的写入<ul>
<li>拆分成若干个 4 kb 的文件；</li>
<li>每一个小的 4 kb 文件可能可以执行 all or nothing 操作；</li>
</ul>
</li>
<li>写入指令<ul>
<li>应用程序实际上使用的不是 bwrite ，应用程序使用的是 logwrite 方法；</li>
<li>因为 bwrite 指令在进行存储的时候不具有原子性；<ul>
<li>一个写操作会对 block 的多个数据记录项进行修改；</li>
<li>bitmap</li>
<li>block </li>
<li>superdata</li>
<li>这些操作必须全部都进行，不然就会出现数据不一致；</li>
</ul>
</li>
<li><strong>所有对于磁盘的写都会变成对于日志的写</strong>；</li>
<li>然后再进行整块的写入；</li>
</ul>
</li>
<li>写入的时机<ul>
<li>执行 <code>end_op</code> 的时候；</li>
<li>执行一个 <code>commit()</code> 方法；</li>
<li>核心：<strong>由 log 系统调用 bread 和 bwrite 方法</strong>；</li>
</ul>
</li>
</ul>
<h2 id="29-3-崩溃恢复"><a href="#29-3-崩溃恢复" class="headerlink" title="29.3 崩溃恢复"></a>29.3 崩溃恢复</h2><p><strong>问题：是否可以恢复已经崩溃的代码？</strong><br>Xv 6 是否真的在崩溃发生后，可以把内容恢复回来；</p>
<p><strong>故障注入</strong><br>Crash &#x3D; 断电；</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">crash</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> count = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">if</span> (--count &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">printf</span>(<span class="string">&quot;crash\n&quot;</span>);</span><br><span class="line">	  *((<span class="type">int</span> *)<span class="number">0x100000</span>) = <span class="number">0x5555</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以设置一个计数器为 count，每一次执行 bread 的时候此 count 都会减一；<br>当其小于零时，会执行 <code>*((int *)0x100000) = 0x5555;</code> 代码，然后虚拟机就可以关闭；</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>文件系统</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 30：现代存储系统</title>
    <url>/2023/09/2e32d53e0557.html</url>
    <content><![CDATA[<p>现代应用程序如何使用文件系统？</p>
<ul>
<li>如果是一个电商网站，它们背后是不是一个操作系统？互联网上的 APP 背后的文件；</li>
<li>现代的应用程序，如何利用文件系统；<span id="more"></span></li>
</ul>
<h2 id="30-1-文件系统的能力与局限性"><a href="#30-1-文件系统的能力与局限性" class="headerlink" title="30.1 文件系统的能力与局限性"></a>30.1 文件系统的能力与局限性</h2><h3 id="30-1-1-例：文件系统实现-Online-Judge"><a href="#30-1-1-例：文件系统实现-Online-Judge" class="headerlink" title="30.1.1 例：文件系统实现 Online Judge"></a>30.1.1 例：文件系统实现 Online Judge</h3><p>文件以目录的形式进行存储，直接存储在文件目录系统之下；</p>
<p><strong>例子：文件系统实现网站博客</strong><br>比如实现一个课程的主页，在课程主页上面会有大量的文章；这样的一个 Online Judge System，该如何实现？</p>
<ul>
<li>所有的 Online Judge 的数据，都是以文件系统的形式存储的；</li>
<li>对于 filerecv 文件当中，有些维护 Online Judge 的脚本；</li>
<li>所有的数据会存储到一下文件当中：<ul>
<li>filerecv &#x2F; os 2022 &#x2F; students. Csv 文件中，存储学生的 Online Judge 回传的数据；</li>
<li>使用单机进行评测所有信息；</li>
</ul>
</li>
</ul>
<p><strong>相关的处理代码</strong></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> wiki.UPLOAD_PATH.glob(</span><br><span class="line">    <span class="string">f&#x27;<span class="subst">&#123;course&#125;</span>/<span class="subst">&#123;module&#125;</span>/<span class="subst">&#123;stuid&#125;</span>/<span class="subst">&#123;file_pattern&#125;</span>&#x27;</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> f.name.endswith(<span class="string">&#x27;.result&#x27;</span>):</span><br><span class="line">        <span class="comment"># f 是一个提交</span></span><br></pre></td></tr></table></figure></div>

<h3 id="30-1-2-文件系统的优缺点"><a href="#30-1-2-文件系统的优缺点" class="headerlink" title="30.1.2 文件系统的优缺点"></a>30.1.2 文件系统的优缺点</h3><p><strong>优点</strong><br>其就是最直观的存储文件的地方，并且这些文件有大量的 UNIX 工具可以用于处理这些数据；</p>
<ul>
<li>需要 rejudge 所有的提交时，不需要提交所有的 result ，可以轻松的使用一行代码看到所有的 result；<ul>
<li><code>find OS2022/L1 -name &quot;*.result&quot; | xargs rm</code></li>
</ul>
</li>
<li>容易查看、调试、hacking；</li>
</ul>
<p><strong>缺点</strong><br>文件系统的缺点：</p>
<ul>
<li>低伸缩性<ul>
<li>上万个文件时，都还可以忍受其性能；</li>
<li>但是当几十万、几百万的提交时，此时对于任何一个文件的遍历都需要很久；</li>
</ul>
</li>
<li>低可靠性<ul>
<li>当网络突然断开时，可能会有 server error 出现；</li>
<li>如果文件少时，可以手动重开；但是对于一个互联网提供商而言，其系统的要求是要求更高的可靠性；并且甚至希望其可以自动重启；</li>
</ul>
</li>
</ul>
<h2 id="30-2-关系数据库"><a href="#30-2-关系数据库" class="headerlink" title="30.2 关系数据库"></a>30.2 关系数据库</h2><h3 id="30-2-1-数据库的产生"><a href="#30-2-1-数据库的产生" class="headerlink" title="30.2.1 数据库的产生"></a>30.2.1 数据库的产生</h3><p><strong>需求的共性与关系数据库</strong><br>所有这些电商网站、用户数据等等，都是人的信息对象在互联网中的投影；<br>因此可以使用一个行和表，来通过一个个的行列来表达数据。数据库发现可以不使用树状结构，所有的东西都可以是表；</p>
<ul>
<li>数据库系统实现了一种查询语言，可以对表中的属性进行查询；<br>以下代码具有等价性<br>Python 代码：<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> stu <span class="keyword">in</span> students:</span><br><span class="line">    <span class="keyword">for</span> sub <span class="keyword">in</span> submissions:</span><br><span class="line">        <span class="keyword">if</span> (stu.sid, sub.course, sub.module) ==</span><br><span class="line">           (sub.sid, <span class="string">&#x27;OS2022&#x27;</span>, <span class="string">&#x27;M1&#x27;</span>):</span><br><span class="line">            <span class="keyword">yield</span> stu, sub</span><br></pre></td></tr></table></figure></div>
SQL 代码：<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> students, submissions</span><br><span class="line"><span class="keyword">WHERE</span> submission.sid <span class="operator">=</span> students.sid <span class="keyword">AND</span></span><br><span class="line">      submissions.course <span class="operator">=</span> <span class="string">&#x27;OS2022&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">      submissions.module <span class="operator">=</span> <span class="string">&#x27;M1&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>特点：把对于数据的管理，从应用程序当中抽离出来</strong><br>好处：</p>
<ol>
<li>可以提供高性能的检索；（可以建立索引、使用多个 CPU 进行检索）</li>
<li>可以实现非常复杂的算法，实现算法的优化；</li>
</ol>
<p><strong>数据库事务</strong><br>因为把数据和具体的应用程序代码进行了分离，因此可以带来一个好处：<strong>原子性</strong>；<br>操作系统文件目录系统的代码是没有原子性的，但 SQL 语句可以带来原子性。它还可以把好几个查询合在一起，实现一个混合的写入、查询；</p>
<p><strong>SQL 与优化</strong><br>SQL 描述出你想要做什么，数据库引擎帮你想办法执行；</p>
<ul>
<li>优化：靠索引和查询优化；<ul>
<li>把 SQL 换成等价但是性能更优的形式；</li>
</ul>
</li>
</ul>
<h3 id="30-2-2-如何制作一个数据库"><a href="#30-2-2-如何制作一个数据库" class="headerlink" title="30.2.2 如何制作一个数据库"></a>30.2.2 如何制作一个数据库</h3><p><strong>基本概念</strong><br>制作一个数据库，某种意义上和实现一个文件系统很类似；</p>
<ul>
<li>数据库就是虚拟磁盘上的数据结构</li>
<li>把 SQL 查询翻译成 read，write，lseek，fsync 等调用；</li>
</ul>
<p>概念模型：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230908184422.png"
                     
                ></p>
<p><strong>实现路径</strong></p>
<ul>
<li><a class="link"   href="https://github.com/cmu-db/bustub" >Bustub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> from <a class="link"   href="https://15445.courses.cs.cmu.edu/fall2021/assignments.html" >CMU 15-445 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><ul>
<li>L0 - C++ Primer</li>
<li>L1 - Buffer Pool Manager</li>
<li>L2 - Hash Index</li>
<li>L3 - Query Execution</li>
<li>L 4 - Concurrency Control</li>
</ul>
</li>
</ul>
<p><strong>实现一个最简单的 DB</strong></p>
<ul>
<li>第一部分：在文件 file 的基础上，实现一个 std:: map 的数据结构；<ul>
<li>支持两种操作</li>
<li>put (k, v)</li>
<li>get (k)</li>
</ul>
</li>
<li>第二部分：日志系统（一种实现方式）<ul>
<li>所有的 put 和 get 都给写进到日志的 Log 当中；</li>
<li>把 read 的 buffer 实现在一个 log 写入当中；</li>
<li>读取如何？<ul>
<li>结果影响</li>
<li><ol>
<li>读放大；</li>
</ol>
</li>
<li><ol start="2">
<li>写放大；</li>
</ol>
</li>
<li><ol start="3">
<li>存储放大；</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>解决读放大<ul>
<li>不管三七二十一，先在内存中维护 log 的实时数据结构 (memtable)<ul>
<li>Get 可以先在内存</li>
</ul>
</li>
<li>Level 0: 直接把 memtable dump 到磁盘<ul>
<li>按照 key 排序，写到不同的文件里；</li>
<li>查找失败时，会到下一层继续查找；</li>
</ul>
</li>
<li>Level 1: 在 Level 0 满 (4 MB) 时，排序所有 key，与 Level 1 合并<ul>
<li>下一层大小是上一层 10 倍；</li>
</ul>
</li>
<li>Level 2: 在 Level 1 满时，把操作应用到 Level 2, …</li>
</ul>
</li>
</ul>
<h2 id="30-3-走向新时代"><a href="#30-3-走向新时代" class="headerlink" title="30.3 走向新时代"></a>30.3 走向新时代</h2><p><strong>存储系统如何应对海量、实时的数据</strong><br>从 1990 -&gt; 2015 ，以 Lod 级别的增长增加存储大小；<br>总有一天，会有一个数据中心可以存储下整个互联网的数据：数据磁盘的大小 ✖ 带宽大小的增长速录 &gt; 互联网需求增长速率；<br>1990s: 高速网络 + 数据中心将可以存储整个互联网 → Google Search<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230908184700.png"
                     
                ></p>
<p><strong>社交网络的增长</strong><br>随着社交网络的增长，世界上没有任何一个服务器可以抗下社交网络的所有的数据；</p>
<ul>
<li>问题：<em>如果要为 QQ 建立数据库，要如何设计？</em></li>
<li>对于社交网络而言，一般的数据库很快就无法应对了；<ul>
<li>可能会有一个帖子，突然会有上千万的人进行关注；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230908185127.png"
                     
                ><br>如何再在一个数据库的抽象之上，建立一个可以满足所有需求的 big storage？</li>
</ul>
</li>
</ul>
<p><strong>遇到的问题：CAP Theorem</strong><br>以行星规模的、应对数据的抽象；</p>
<ul>
<li><p>解决：<strong>数据中心当中的、超大规模的分布式的存储</strong></p>
</li>
<li><p>问题：延迟和数据一致性是不可兼得的；</p>
</li>
<li><p>数据库提供</p>
<ul>
<li>这当中最难的是：一致性和速度的关系；</li>
<li><ol>
<li>原子性</li>
</ol>
</li>
<li><ol start="2">
<li>一致性</li>
</ol>
</li>
<li><ol start="3">
<li>持久性</li>
</ol>
</li>
<li><ol start="4">
<li>隔离性（Isolation）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230908185615.png"
                     
                ></li>
</ol>
</li>
</ul>
</li>
<li><p>传统的数据库：</p>
<ul>
<li>任何的请求都必须同时发到两个数据库上；查就给你；</li>
<li>拥有可用性和一致性；</li>
<li>但很难解决跨地理中心的延迟；</li>
</ul>
</li>
</ul>
<h3 id="30-3-1-分布式系统的核心"><a href="#30-3-1-分布式系统的核心" class="headerlink" title="30.3.1 分布式系统的核心"></a>30.3.1 分布式系统的核心</h3><p><strong>分布式系统与锁</strong><br>如果要管理海量的数据时，此时就<strong>不能上锁</strong>；</p>
<ul>
<li>分布式系统的基本假设：任何一个设备都有可能出错、消失；<ul>
<li>刚给一个设备上锁，就消失了?</li>
</ul>
</li>
<li>如果要给分布在世界各地的 DC 上锁；</li>
</ul>
<p><strong>如何在分布式系统当中保持一致性</strong><br>每个设备都是状态机，用 msg 的方式同步不同的状态机；<br>并且当中可能节点也会出现消失；</p>
<ul>
<li><a class="link"   href="https://raft.github.io/" >In search of an understandable consensus algorithm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> (USENIX ATC’14, Best Paper Award 🏅)<ul>
<li>“Replicated State Machines”<ul>
<li>又是状态机！</li>
</ul>
</li>
<li><a class="link"   href="https://raft.github.io/raftscope/index.html" >RaftScope <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> Visualization Tool<ul>
<li>再次感受被并发编程支配的恐惧</li>
<li>不仅并发，而且线程可能随时消失！</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>文件系统</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 31：Android系统</title>
    <url>/2023/09/4e1472042b67.html</url>
    <content><![CDATA[<p>虽然现在学习 OS 的是主要是面对的命令行，但 OS 可以被推广出来，主要还是因为图形界面；</p>
<ul>
<li>有没有准备好，自己设计实现一个 OS ，并且用于图形界面？<br>内容大纲：</li>
</ul>
<span id="more"></span>
<h2 id="31-1-走向移动互联网时代"><a href="#31-1-走向移动互联网时代" class="headerlink" title="31.1 走向移动互联网时代"></a>31.1 走向移动互联网时代</h2><p><strong>移动设备的变迁</strong><br>从 8 bit 的声音，到现在的现代声音：体现了其计算性能的变化；</p>
<ul>
<li>计算力在变化；</li>
<li>屏幕的素质大幅度进步；</li>
<li>移动支付：使用绿码、蓝码进行移动支付；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230910172238.png"
                     
                ></li>
</ul>
<h2 id="31-2-Android-简介"><a href="#31-2-Android-简介" class="headerlink" title="31.2 Android 简介"></a>31.2 Android 简介</h2><h3 id="31-2-1-Android-基本情况"><a href="#31-2-1-Android-基本情况" class="headerlink" title="31.2.1 Android 基本情况"></a>31.2.1 Android 基本情况</h3><p><strong>Android</strong><br>安卓官方主页：<a class="link"   href="https://developer.android.google.cn/" >Android 官方主页 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ul>
<li>安卓的成功，和其编程模型有关；<ul>
<li>新的平台要能够成功，首先就需要：保证有大量的开发者；</li>
</ul>
</li>
<li>软件架构：Linux + Framework + JVM<ul>
<li>JVM：有其自己的指令集，一个虚拟机上小的指令集；<ul>
<li>所有的东西的存在栈上，不需要寄存器；</li>
<li>Java Virtual Machine：其 Java 很早期的版本就是一个解释器，解释器在执行这个代码；</li>
<li>因此其执行应用很卡；</li>
</ul>
</li>
<li>但宁可牺牲性能，也要把 Java 给推出来；<ul>
<li>Java 简单、程序员多，容易写对；</li>
</ul>
</li>
</ul>
</li>
<li>支持 Java 是一个非常高瞻远瞩的决定<ul>
<li>Qualcomm MSM7201<ul>
<li>ARMv6 指令集</li>
<li>528 MHz x 1CPU, 顺序八级流水线</li>
<li>TSMC 90 nm</li>
</ul>
</li>
</ul>
</li>
<li>现在主要支持 Kotlin 语言；</li>
</ul>
<h3 id="31-2-2-Android-架构"><a href="#31-2-2-Android-架构" class="headerlink" title="31.2.2 Android 架构"></a>31.2.2 Android 架构</h3><p><strong>Android Apps</strong><br>一个运行在 Java 虚拟机 (<a class="link"   href="http://aospxref.com/android-12.0.0_r3/xref/art/" >Android Runtime <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>) 上的应用程序；</p>
<ul>
<li>安卓本身就是在 Linux 之上提供了一层定制：Apps；</li>
<li>安卓是应用程序运行的平台；<ul>
<li>开发手机应用，两个很重要的功能：</li>
<li>网络</li>
<li>人机交互</li>
</ul>
</li>
</ul>
<p><strong>Kotlin 语言</strong><br>其本质上还是 Java 语言，它的代码也是被编译成 JVM 的字节码，而且语法会更阿吉舒服；</p>
<p><strong>架构关系</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230910173938.png"
                     
                ></p>
<p><strong>架构</strong><br>现在使用的很多软件：支付宝、微信等等，其都是网页；</p>
<ul>
<li>WebView Object allow you to display web content as part of your activity layout, but lack some of the feature of fully-devloped browsers;</li>
<li>官方文档 (RTFM)</li>
</ul>
<ul>
<li><a class="link"   href="https://developer.android.google.cn/kotlin" >Kotlin <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://developer.android.google.cn/reference/packages" >Platform <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><ul>
<li><a class="link"   href="https://developer.android.google.cn/reference/android/view/View" >android.view.View <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>: “the basic building block for user interface components”</li>
<li><a class="link"   href="https://developer.android.google.cn/reference/android/webkit/WebView" >android.webkit.WebView <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> - 嵌入应用的网页</li>
<li><a class="link"   href="https://developer.android.google.cn/reference/android/hardware/camera2/package-summary" >android.hardware.camera2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> - 相机</li>
<li><a class="link"   href="https://developer.android.google.cn/reference/android/database/sqlite/package-summary" >android.database.database <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> - 数据库<ul>
<li>安卓应用的所有数据都会存储在数据库当中；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="31-3-Android-App"><a href="#31-3-Android-App" class="headerlink" title="31.3 Android App"></a>31.3 Android App</h2><h3 id="31-3-1-四大组件"><a href="#31-3-1-四大组件" class="headerlink" title="31.3.1 四大组件"></a>31.3.1 四大组件</h3><p><strong>首先第一个设想：在这之上进行编程的程序员可能不太靠谱</strong></p>
<p><strong>Activity</strong></p>
<ul>
<li>应用程序的 UI 界面 (Event Driven)<ul>
<li>应用是一个事件循环；</li>
<li>只要去重写这些定义出来的事件，就可以自动被执行回调；</li>
<li>整个是一个事件周期；</li>
</ul>
</li>
<li>存在一个 Activity Stack (应用拉起)<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230910174910.png"
                     
                ></li>
</ul>
<p><strong>Service</strong></p>
<ul>
<li>无界面的后台服务</li>
<li>可以给其他的应用程序提供后台服务的支持；<ul>
<li>比如在京东里面进行微信支付，就需要调用微信的 APP 的代码进行；</li>
<li>在窗口栈上；</li>
</ul>
</li>
</ul>
<p><strong>Broadcast</strong></p>
<ul>
<li>接受系统消息，做出反应<ul>
<li>例如 “插上电源”、“Wifi 断开”</li>
</ul>
</li>
<li>安卓里面所有的应用权限都是被 OS 管理的<ul>
<li>只有被授权之后，才可以获得这个权限；</li>
<li>如何为所有的应用程序的需求服务好；</li>
</ul>
</li>
</ul>
<p><strong>ContentProvider</strong></p>
<ul>
<li>可以在应用间共享的数据存储 (insert, update, query, …)</li>
</ul>
<h3 id="31-3-2-应用程序的代码"><a href="#31-3-2-应用程序的代码" class="headerlink" title="31.3.2 应用程序的代码"></a>31.3.2 应用程序的代码</h3><p><strong>源代码与 APK</strong><br>应用程序的源代码会全部打包成一个 APK 文件；</p>
<ul>
<li>AndroidManifest 文件<ul>
<li>一个应用本身的信息；</li>
<li>应用的唯一名字；</li>
<li>应用的 icon；</li>
<li>应用的单独用户 ID（唯一ID）；</li>
</ul>
</li>
</ul>
<p><strong>程序与权限</strong><br>每个应用程序都是一个单独的用户，可以单独的对这些应用的权限进行设置；</p>
<ul>
<li>并且某段时间还会为每个应用程序，提供一个单独的虚拟 SD 卡；</li>
<li>安卓在 10 之后有虚拟 SD 卡，禁止不同的应用程序之间通过 SD 卡共享应用程序的数据；<ul>
<li>但国内厂商集中抵制，所以在国内没用上；</li>
</ul>
</li>
</ul>
<p><strong>资源文件</strong><br>绝大部分都是 values 开头；</p>
<ul>
<li>并且还可以支持不同国家的语言：values-uk&#x2F;cn&#x2F;usa 等等；</li>
<li>为不同的 icon 支持不同的 png 图片；</li>
<li>为盲人提供的文本 XML 描述；</li>
</ul>
<h2 id="31-4-Android-系统内核"><a href="#31-4-Android-系统内核" class="headerlink" title="31.4 Android 系统内核"></a>31.4 Android 系统内核</h2><h3 id="31-4-1-系统架构"><a href="#31-4-1-系统架构" class="headerlink" title="31.4.1 系统架构"></a>31.4.1 系统架构</h3><p><strong>在平台的 API 之下：一个操作系统的微内核</strong><br>操作系统需要管理很多个应用程序，并且可以让某个应用程序常驻、杀死，等等这些五花八门的应用，OS 如何管理他们？<br>操作系统内核架构：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230911172207.png"
                     
                ></p>
<p><strong>Platform API 和 Android Runtime（JVM）</strong><br>安卓的 JVM 代码质量非常的高；</p>
<ul>
<li>在安卓的 OS 之下，还提供了很多的 Services；<ul>
<li>其不仅是一堆 API，它还提供了一堆有用的服务；</li>
</ul>
</li>
<li>当需要强行终止一个应用程序时，谁完成了此行为；<ul>
<li>此行为不是一般的应用程序权限可做的事情；</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230911172002.png"
                     
                ></p>
<h3 id="31-4-2-Binder-IPC"><a href="#31-4-2-Binder-IPC" class="headerlink" title="31.4.2 Binder IPC"></a>31.4.2 Binder IPC</h3><p><strong>为什么会有 Binder IPC</strong><br>在 Linux 这种操作系统里，因为所有对象都是文件，所以当不同的程序之间需要进行通信时，直接对文件进行读取即可；<br>但在安卓这样的 OS 当中，就需要通过 Binder IPC 这样的机制来进行；</p>
<p><strong>一个很高效的 RPC</strong><br>把对象进行序列化，然后把对象交给另外一个进程执行，执行完之后返回回去；</p>
<ul>
<li>在性能优化和易用之间的权衡<ul>
<li>注册机制<ul>
<li>相比之下，管道&#x2F;套接字就太 “底层” 了，需要手工管理的东西太多</li>
</ul>
</li>
<li>基于共享内存实现<ul>
<li>Linux Kernel binder driver</li>
</ul>
</li>
<li>服务端线程池<ul>
<li>可以在服务端使用多个应用程序来进行服务；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>安卓提供了微内核</strong><br>对上层的应用而言，其只提供了 API 就是 RPC Call 进行远程过程调用；</p>
<ul>
<li>问题：如果服务器是多线程<ul>
<li>可能会出现某个 services 的服务上锁，线程上锁之后，不同线程之间的优先级混乱；</li>
</ul>
</li>
<li>微内核使得性能更差，更卡；但提供了更好的安全性；</li>
</ul>
<h3 id="31-4-3-例：如何杀死一个-Android-进程"><a href="#31-4-3-例：如何杀死一个-Android-进程" class="headerlink" title="31.4.3 例：如何杀死一个 Android 进程"></a>31.4.3 例：如何杀死一个 Android 进程</h3><p>如何杀死一个 Android 进程？</p>
<ul>
<li>RTFSC: <a class="link"   href="http://aospxref.com/android-12.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java#3688" >ActivityManagerService.java <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><ul>
<li>Android 每个 App 都有独立的 uid</li>
<li>遍历进程表，找到属于 uid 的进程</li>
<li>Process.KillProcessGroup<ul>
<li><a class="link"   href="http://aospxref.com/android-12.0.0_r3/xref/system/core/libprocessgroup/processgroup.cpp#411" >间隔 5ms，连续杀死 40 次 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，防止数据竞争</li>
<li>Operating System Transactions 的必要性</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>那么，我们是不是就可以利用数据竞争进程保活了呢？</strong></p>
<ul>
<li>成为孤儿进程从而不会立即收到 SIGKILL 信号</li>
<li>在被杀死后立即唤醒另一个进程: <a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/flock-demo.c" >flock-demo.c <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><ul>
<li><a class="link"   href="https://dl.acm.org/doi/10.1145/3302424.3303956" >A lightweight framework for fine-grained lifecycle control of Android applications <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> (EuroSys’19); “diehard apps”</li>
</ul>
</li>
</ul>
<h3 id="31-4-4-一个真正的操作系统"><a href="#31-4-4-一个真正的操作系统" class="headerlink" title="31.4.4 一个真正的操作系统"></a>31.4.4 一个真正的操作系统</h3><p><strong>adb (Android Debug Bridge)</strong></p>
<ul>
<li>用于调试安卓程序的调试桥<ul>
<li>可以使用 adb 去调试任何一个安卓APP；</li>
</ul>
</li>
</ul>
<ul>
<li>adb push&#x2F;pull&#x2F;install</li>
<li>adb shell<ul>
<li>screencap &#x2F;sdcard&#x2F;screen.png</li>
<li>sendevent</li>
</ul>
</li>
<li>adb forward</li>
<li>adb logcat&#x2F;jdwp</li>
</ul>
<p><strong>一系列衍生的工具</strong></p>
<ul>
<li>开发者选项</li>
<li>scrcpy</li>
<li>Monkey&#x2F;UI Automator</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>文件系统</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 14：C标准库的实现</title>
    <url>/2023/08/68a724658d83.html</url>
    <content><![CDATA[<p>操作系统内核对外面提供的API就是Syscall，而当中和用户交互的就是Shell。而在Shell的外面，OS提供了一个框架性程序，帮助开发者实现应用程序（因为没有人愿意在没有库函数的情况下，直接使用汇编、系统调用来制作应用程序）</p>
<blockquote>
<p>· 在系统调用之上构建可以普遍使用的标准库：libc</p>
</blockquote>
<span id="more"></span>
<h2 id="14-1-系统调用的封装"><a href="#14-1-系统调用的封装" class="headerlink" title="14.1 系统调用的封装"></a>14.1 系统调用的封装</h2><h3 id="14-1-1-熟悉又陌生的libc"><a href="#14-1-1-熟悉又陌生的libc" class="headerlink" title="14.1.1 熟悉又陌生的libc"></a>14.1.1 熟悉又陌生的libc</h3><p><strong>为什么需要libc</strong><br>虽然不借助任何的库函数也可以写程序，但是在自己写的时候还是要进行封装（一些固定的功能）。<br>裸奔式的编程是不可行的，即使是实现最简单的程序也有很多可以重用的部分。</p>
<h3 id="14-1-2-libc提供的类型系统"><a href="#14-1-2-libc提供的类型系统" class="headerlink" title="14.1.2 libc提供的类型系统"></a>14.1.2 libc提供的类型系统</h3><p><strong>第一种：类型系统</strong><br>问题：size of int 是多少大小？C语言编译器可以将其实现为八字节，也可以是四字节<br>解释：这种不同字节大小的类型，在进行跨平台交叉编译时，其移植性具有很大的障碍，因为其在不同平台上大小可能不同。<br>方法：libc标准库专门提供对应的标准基本类型</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<p>在使用的时候，直接使用标注上字节大小的int或bool:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> a;</span><br><span class="line">	<span class="type">uint64_t</span> x;</span><br><span class="line">	<span class="type">intptr_t</span> ptr;<span class="comment">//可以保证，把这个指针cast成一个int之后不会丢失任何的数据</span></span><br><span class="line">	<span class="comment">//intptr_t ptr = (intptr_t)main;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果是使用int替代intptr_t时，可能会丢失信息。</p>
<p>常见、在freestanding下也可以使用的定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">stddef.h -&gt; <span class="type">size_t</span></span><br><span class="line">stdint.h -&gt; <span class="type">int32_t</span>,<span class="type">uint64_t</span></span><br><span class="line">stdbool.h -&gt; <span class="type">bool</span>,<span class="literal">true</span>,<span class="literal">false</span></span><br><span class="line"><span class="type">float</span>.h</span><br><span class="line">limits.h</span><br><span class="line">stdarg.h</span><br></pre></td></tr></table></figure></div>
<p>系统syscall使用到的stdarg.h；<br>另一个问题：long type<br>long type32位机上是四字节，在其他机器上可能是八字节；</p>
<h3 id="14-1-3-libc对系统调用的封装"><a href="#14-1-3-libc对系统调用的封装" class="headerlink" title="14.1.3 libc对系统调用的封装"></a>14.1.3 libc对系统调用的封装</h3><p><strong>对execve()系统调用的封装</strong><br>execve()并不好用，平时使用的时候使用麻烦。<br>比如execve()的第一个路径必须为是一个合法的路径，可以是相对路径，但必须是合法的路径：<code>../../../../../../.././bin/echo</code><br>execve如果不给合法的路径，其会直接拒绝用户，但用户想要实现的是找到path当中的echo，而不是找完全准确的那个path。<br>平时写代码可能会用：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">execlp(<span class="string">&quot;echo&quot;</span>,<span class="string">&quot;echo&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;OS course&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//打印结果：hello OS course</span></span><br></pre></td></tr></table></figure></div>
<p>用静态的方式编译，然后查看其系统调用：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829192141.png"
                     
                ><br>execve会尝试每一个path当中的路径，然后直到成功找到那个程序，然后使用execve进程reset。这当中也介绍了更高情商的API：execlp<br><em>补充：在看手册的时候，手册当中经常会有很大的引用，比如在execve的手册当中，其当中可以看到SEE ALSO，顺着这些引用往下看就可以算是实现了一次文献调研</em><br>libc就是对在系统调用的基础上，面向人类易用性进行的封装。</p>
<h3 id="14-1-4-libc对string、数组的封装"><a href="#14-1-4-libc对string、数组的封装" class="headerlink" title="14.1.4 libc对string、数组的封装"></a>14.1.4 libc对string、数组的封装</h3><p><strong>main函数中的参数</strong><br>main函数会有三个参数。当中有一个数组：<code>char *argv[]*</code></p>
<p>memset实现：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span>* s <span class="type">int</span> c,<span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;n ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		((<span class="type">char</span>*)s)[i] = c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>memset对于数据竞争的态度：直接不管你，谁最后把数据写进去，内存单元就是哪个进程的，并且标准库只对“标准库内部数据”的线程安全性负责。<br>使用clang对其进行编译后的结果：</p>
<p><strong>补充：libc实现的复杂性</strong><br>对于libc的实现者而言，因为Libc会被很多人调用，因此其正确性必须得得到验证。并且作为Libc，其必须得跑得快，而且还得兼顾各种的机器，在不同机器上面跑的快不快……<br>在多个线程使用其时，会不会产生数据竞争，是不是还得考虑安全……新的机制来了，当前代码还得支持。</p>
<p><em>补：现在的C语言 &#x3D; 大号的汇编语言 + 大家还能接受的API的标准</em></p>
<h3 id="14-1-5-其他的例子"><a href="#14-1-5-其他的例子" class="headerlink" title="14.1.5 其他的例子"></a>14.1.5 其他的例子</h3><p>数学库的实现：过于复杂，比如浮点数的性质，比如在接近0的时候如何保证精度。而OS要对纯粹的计算进行封装。</p>
<hr>
<h2 id="14-2-文件描述符与进程封装"><a href="#14-2-文件描述符与进程封装" class="headerlink" title="14.2 文件描述符与进程封装"></a>14.2 文件描述符与进程封装</h2><p>操作系统中存在大量的对象，比如终端、对于Shell来说连接的终端。libc的职责之一，就是对于这些常见对象的封装</p>
<h3 id="14-2-1-什么是文件描述符"><a href="#14-2-1-什么是文件描述符" class="headerlink" title="14.2.1 什么是文件描述符"></a>14.2.1 什么是文件描述符</h3><p>文件描述符就是一个打开的文件，而Linux当中一切都是文件，因此可以使用文件描述符来打开一切对象。因此Libc必须要对文件描述符进行一定的封装。 </p>
<p>例：往文件系统里面写文件的一段代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">FILE* fp = fopen(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;Hello,OS world\n&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>使用gcc编译：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -g a.c &amp;&amp; ./a.out</span><br></pre></td></tr></table></figure></div>

<p>这是OS视角下，当前程序的行为。但也可以从用户的视角来看一下，这个代码发生的行为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">p *fp</span><br></pre></td></tr></table></figure></div>
<p>对文件描述符的指针解引用，得出的结果（部分）：<br>![[Pasted image 20230307171858.png]]<br>由此可以看到：FILE* 背后就是封装了一个文件描述符。同时一个FILE只能返回一个文件描述符，要么是读口要么是写口。<br>装填了值之后，fp解引用会变成这样：<br>![[Pasted image 20230307172411.png]]<br>可以清晰的看到libc为其设置的不同区域的大小以及对应的内容。</p>
<p>popen和pclose的设计具有缺陷（或者说相比于现代的语言，不易用）</p>
<h3 id="14-2-2-其他进程-操作系统功能"><a href="#14-2-2-其他进程-操作系统功能" class="headerlink" title="14.2.2 其他进程&#x2F;操作系统功能"></a>14.2.2 其他进程&#x2F;操作系统功能</h3><p><strong>错误信息处理</strong><br>所有的API都有可能失败，此时Shell可能会发出一个error message，比如“No Such file or directory”。并且不止是这一个错误发出了这个信息，还有很多的其他err message都是这个，是不是背后有一个共通的错误反应的内容？<br>因为这背后都使用了一样的libc当中的错误处理代码，一代一代的传承出来（除非有一个打破者，比如rust出现）</p>
<p><strong>环境变量</strong><br>可以自己实现env.c这样的命令，借助Linux提供的env.c机制，可以实现非常简单的env环境变量实现。<br>在C语言当中可以使用环境变量：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br></pre></td></tr></table></figure></div>
<p>而这些环境变量在执行之前就已经有值，这些值是谁设置的？如何查看这些内容？<br>可以使用gdb调试，从starti开始执行。<br>先编译一下env.c代码：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc env.c -g -static</span><br></pre></td></tr></table></figure></div>
<p>受用gdb使用时，最开始starti时没有值，再往下执行后，可以看到时__libc_start_main()给其赋值<br>gdb断点查看：<br>![[Pasted image 20230308165300.png]]</p>
<h2 id="14-3-地址空间的封装"><a href="#14-3-地址空间的封装" class="headerlink" title="14.3 地址空间的封装"></a>14.3 地址空间的封装</h2><h3 id="14-3-1-内存分配行为"><a href="#14-3-1-内存分配行为" class="headerlink" title="14.3.1 内存分配行为"></a>14.3.1 内存分配行为</h3><p><strong>简介</strong><br>libc的一个非常重要的功能之一就是内存管理，而这块主要就是malloc和free，任何的应用程序都需要大量的分配内存。</p>
<p><strong>行为分析</strong><br>在一个大区间中维护互不相交的区间的集合，大区间由mmap来实现，mmap基于当前进程的地址空间，从当中挖去一大块内存。<br>在一个左闭右开的区间，维护一个数据结构，这些被分配的内存互相不相交，在这片内存当中进行malloc和free，可以往一片空区分配内存，或者将已经分配的内存释放掉。因此malloc和free就是区间管理。</p>
<p><strong>内存分配的效率问题</strong><br>当想要在设计内存管理的时候，使用类似红黑树、B+树类似的算法思路想要去实现算法复杂度的log(n)时，就已经陷入误区。<br>在OS上，在多处理器的方案下，光是想要实现安全性就够困难了。</p>
<p><strong>任何脱离workflow的性能优化都是耍流氓</strong>，在考虑性能之前，需要先考虑需要什么样的性能。</p>
<h3 id="14-3-2-内存管理workflow分析"><a href="#14-3-2-内存管理workflow分析" class="headerlink" title="14.3.2 内存管理workflow分析"></a>14.3.2 内存管理workflow分析</h3><p><strong>指导思想</strong><br>内存被分配出来就是为了被使用的，O(n)大小的对象分配至少需要有相对应数量级的读写操作，不然就是性能Bug。<br>必须是在需要对应的对象，需要那么多的内存时才分配那部分内存。</p>
<p><strong>问题</strong></p>
<ul>
<li>越小的对象创建&#x2F;分配越频繁<ul>
<li>字符串、临时对象等</li>
<li>生存周期可长可短</li>
</ul>
</li>
<li>较为频繁的分配中等大小的对象<ul>
<li>较大的数组、复杂的对象</li>
<li>更长的生命周期</li>
</ul>
</li>
<li>低频率的大对象<ul>
<li>巨大的容器、分配器</li>
<li>很长的生存周期</li>
</ul>
</li>
<li>挑战：并行化的分配问题<ul>
<li>所有的分配都会在处理器上发生，而处理器是并发、相互高度用总线连接的</li>
</ul>
</li>
</ul>
<h3 id="14-3-3-内存问题的两种方案"><a href="#14-3-3-内存问题的两种方案" class="headerlink" title="14.3.3 内存问题的两种方案"></a>14.3.3 内存问题的两种方案</h3><p>设置两套系统：</p>
<ul>
<li>fast path<ul>
<li>性能好，并行度好，覆盖大部分情况</li>
<li>可以很快的解决问题，但是有小概率失败</li>
</ul>
</li>
<li>slow path<ul>
<li>性能没那么好，但是要求把事情做好</li>
</ul>
</li>
<li>人的fast系统和slow系统<ul>
<li>直觉式的反应系统和推力式的反应系统</li>
</ul>
</li>
</ul>
<p><strong>Malloc：Fast Path设计</strong><br>简介：使得所有的CPU都可以并行的申请内存<br>实现：想实现更快的分配，因此不能进行上锁，如果此时有两个线程，此时可以以page的方式，在page的基础上维护一个空闲链表，当一个page分配完了，再从全局的page当中分配一个page，往其上一把锁，然后把这个page返回给需要的地方。<br>当快速的在page上分配内存时是fast path，但是当内存不够，分配更多的page时，此时是slow path。通过这种设计实现slow path的访问变少，性能变好。<br>如果不想在page上使用链表维护时，还可以设置最小的分配单元位32b、64b、…4kb，此时有一个64kb的page，在此page上有个Header，除了这个Header之外，在这个Page上就是一堆16b的对象（或者其他格式），可以为每个分配的大小单独分配结构。</p>
<p><strong>小内存的分段设计</strong><br>基于一个个Segregation上进行分配，每个slab里面的对象大小都一致，每个线程都在本地拥有立即分配完成的权限。</p>
<p><strong>大内存的大锁设计</strong><br>需要分配大内存时，此时就是使用线段树，将一串区域切分成树，然后变成了一个算法问题。使用一把大锁保证其安全。</p>
<h2 id="14-4-总结"><a href="#14-4-总结" class="headerlink" title="14.4 总结"></a>14.4 总结</h2><h3 id="14-4-1-相关手册"><a href="#14-4-1-相关手册" class="headerlink" title="14.4.1 相关手册"></a>14.4.1 相关手册</h3><p><strong>Libc手册</strong><br>The GNU C Library</p>
<p>Libc的实现：Newlib</p>
<h3 id="14-4-2-从C走向世界"><a href="#14-4-2-从C走向世界" class="headerlink" title="14.4.2 从C走向世界"></a>14.4.2 从C走向世界</h3><p>基于C，可以实现C++的编译器<br>基于C++，可以实现C++标准库<br>基于C++，可以是西安OpenJDK<br>基于C++，可以实现JS，进而实现整个浏览器当中的世界</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Lecture 32：从逻辑门到计算机系统</title>
    <url>/2023/09/780f1bb42e82.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h2 id="32-1-数字系统：计算机系统的-“公理系统”"><a href="#32-1-数字系统：计算机系统的-“公理系统”" class="headerlink" title="32.1 数字系统：计算机系统的 “公理系统”"></a>32.1 数字系统：计算机系统的 “公理系统”</h2><p><strong>数字逻辑电路</strong><br>所有的数字系统都是一个状态机；可以用很多个逻辑门来实现一个计算机硬件系统；<br>数字系统 &#x3D; 状态机</p>
<ul>
<li>状态：触发器</li>
<li>迁移：组合逻辑<ul>
<li><a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/logisim.c" >logisim.c <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/seven-seg.py" >seven-seg.py <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>NEMU Full System Emulator</li>
</ul>
</li>
</ul>
<p><strong>数字逻辑电路与状态机</strong><br>本质都是对于状态机的描述，那么可以使用电路、框图，也可以使用一些描述性语言来进行；<br>数字系统的设计 &#x3D; 描述状态机</p>
<ul>
<li>HDL (Verilog)</li>
<li>HCL (Chisel)<ul>
<li>编译生成 Verilog</li>
</ul>
</li>
<li>HLS (High Level Synthesis)<ul>
<li>“从需求到代码”</li>
</ul>
</li>
</ul>
<h2 id="32-2-编程语言与算法"><a href="#32-2-编程语言与算法" class="headerlink" title="32.2 编程语言与算法"></a>32.2 编程语言与算法</h2><p><strong>编程语言</strong><br>使用编程语言进行编程时，其就是描述一个状态机；<br>C&#x2F;Java&#x2F;Python 程序 &#x3D; 状态机</p>
<ul>
<li>状态：栈、堆、全局变量</li>
<li>迁移：语句 (或语句一部分) 的执行<ul>
<li>“程序设计语言的形式语义”</li>
<li><a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/hanoi-nr.c" >hanoi-nr.c <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>使用一些编程语言与算法，就可以解决一些问题；</li>
</ul>
</li>
</ul>
<p><strong>编程 &#x3D; 描述状态机</strong></p>
<ul>
<li>将人类世界的需求映射到计算机世界中的数据和计算<ul>
<li>DFS 走迷宫 <a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/dfs-fork.c" >dfs-fork.c <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>Dijkstra 算法求最短路径……</li>
</ul>
</li>
<li>允许使用操作系统提供的 API<ul>
<li>例子：<code>write(fd, buf, size)</code> 持久化数据</li>
</ul>
</li>
</ul>
<h2 id="32-3-从编程语言到数字系统"><a href="#32-3-从编程语言到数字系统" class="headerlink" title="32.3 从编程语言到数字系统"></a>32.3 从编程语言到数字系统</h2><p><strong>如何使程序在数字系统上运行？</strong></p>
<ul>
<li>数字系统 &gt; 体系结构</li>
<li>编译器 &gt; 编程语言</li>
<li>数字系统 &gt; 体系结构 &gt; 操作系统 &gt; 编译器 &gt; 编程语言</li>
</ul>
<p><strong>如何从编程语言状态机的计算，到和物理设备的交互？</strong><br>和状态机之外的部分进行交互：操作系统；</p>
<ul>
<li>操作系统根本使命：管理很多资源、程序</li>
</ul>
<p>指令集体系结构</p>
<ul>
<li>在逻辑门之上建立的 “指令系统” (状态机)<ul>
<li><a class="link"   href="https://jyywiki.cn/pages/OS/manuals/riscv-spec.pdf" >The RISC-V Instruction Set Manual <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>既容易用电路实现，又足够支撑程序执行</li>
</ul>
</li>
</ul>
<p>编译器 (也是个程序)</p>
<ul>
<li>将 “高级” 状态机 (程序) 翻译成的 “低级” 状态机 (指令序列)<ul>
<li>翻译准则：external visible 的行为 (操作系统 API 调用) 等价</li>
</ul>
</li>
</ul>
<p>操作系统 (也是个程序)</p>
<ul>
<li>状态机 (运行中程序) 的管理者<ul>
<li>使程序可以共享一个硬件系统上的资源 (例如 I&#x2F;O 设备)</li>
</ul>
</li>
</ul>
<h3 id="32-3-1-操作系统上的程序"><a href="#32-3-1-操作系统上的程序" class="headerlink" title="32.3.1 操作系统上的程序"></a>32.3.1 操作系统上的程序</h3><p>状态机 + 一条特殊的 “操作系统调用” 指令</p>
<ul>
<li>syscall (2)</li>
<li><a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/minimal.S" >minimal.S <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p>程序的编译、链接和加载</p>
<ul>
<li><a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/dl/dl.h" >dl.h <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, <a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/dl/dlbox.c" >dlbox.c <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/dl/libc.S" >libc.S <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> - 提供 putchar 和 exit</li>
<li><a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/dl/libhello.S" >libhello.S <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> - 调用 putchar, 提供 hello</li>
<li><a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/dl/main.S" >main.S <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> - 调用 hello, 提供 main</li>
</ul>
<h2 id="32-4-什么是操作系统"><a href="#32-4-什么是操作系统" class="headerlink" title="32.4 什么是操作系统"></a>32.4 什么是操作系统</h2><p><strong>操作系统对象和 API</strong><br>三个主要部分：</p>
<ul>
<li>并发 Concurrency - <a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/thread.h" >thread.h <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/mem-ordering.c" >mem-ordering.c <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 打开潘多拉的盒子</li>
<li>虚拟化 Virtualization - <a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/sh-xv6.c" >sh-xv6.c <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>; <a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/fork-printf.c" >fork-printf.c <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>; <a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/dosbox-hack.c" >dosbox-hack.c <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>持久化 Persistence - <a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/fatree.c" >fatree.c <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>; <a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/fish-dir.sh" >fish-dir.sh <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p><strong>在这组系统调用的基础上，就可以实现一切想实现的东西；</strong><br>M1 - pstree</p>
<ul>
<li>打印进程树 (文件系统 API; procfs)<br>M2 - libco</li>
<li>进程内的状态机管理 (setjmp&#x2F;longjmp)<br>M3 - sperf</li>
<li>strace (pipe; fork; execve)<br>M4 - crepl</li>
<li>动态链接和加载 (fork; execve; dlopen)<br>M5 - freov</li>
<li>文件系统解析 (mmap)</li>
</ul>
<p><strong>调试程序的能力：理解程序发生的一切</strong><br>“操作系统” 课给了你程序的 “最底层” 的状态机视角</p>
<ul>
<li>也给了很多之前很难回答问题的答案<ul>
<li>如何创造一个 “最小” 的可执行文件？<ul>
<li><a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/minimal.S" >minimal.S <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><code>a.out</code> 是什么？</li>
<li><code>a.out</code> 执行的第一条指令在哪里？</li>
<li><code>printf</code> 是如何被调用的？</li>
<li><code>a.out</code> 执行了哪些系统调用？</li>
<li><code>a.out</code> 执行了多少条指令？<ul>
<li><a class="link"   href="https://jyywiki.cn/pages/OS/2022/demos/inst-count.py" >inst-count.py <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><code>perf stat -e instructions:u</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="32-4-1-操作系统是-C-程序"><a href="#32-4-1-操作系统是-C-程序" class="headerlink" title="32.4.1 操作系统是 C 程序"></a>32.4.1 操作系统是 C 程序</h3><p><strong>操作系统本身也是一个 C 程序的状态机</strong><br>刷一下手机，你的计算机系统经历了非常复杂的过程</p>
<ul>
<li>应用程序 (app) → 库函数 (Android Framework) → 系统调用 → 操作系统中的对象 → 操作系统实现 (C 程序) → 设备驱动程序 → 硬件抽象层 → 指令集 → CPU, RAM, I&#x2F;O设备 → 门电路</li>
</ul>
<ul>
<li>操作系统课给这个稍显复杂的过程一个清晰的轮廓<ul>
<li>“这一切是可以掌控的”</li>
<li>RTFM! RTFSC!</li>
</ul>
</li>
</ul>
<h2 id="32-5-走得更远"><a href="#32-5-走得更远" class="headerlink" title="32.5 走得更远"></a>32.5 走得更远</h2><p><strong>你不再惧怕任何 system</strong></p>
<ul>
<li>嵌入式系统</li>
<li>通用操作系统</li>
<li>分布式系统</li>
<li>……</li>
</ul>
<p><strong>不再惧怕任何 “需求” 的实现</strong></p>
<ul>
<li>找到合适的系统调用实现</li>
<li>做不到？可以自己加个系统调用</li>
<li>软件上实现不了？可以改 CPU 来支持！</li>
</ul>
<p><strong>新的理解</strong><br>“一切皆状态机”</p>
<ul>
<li>状态的副本 (fork) 可以用来做什么？<ul>
<li>Model checking, failure recovery, …</li>
</ul>
</li>
</ul>
<p>“死锁检测: lockdep 在每次 lock&#x2F;unlock 的时候插入一条 printf”</p>
<ul>
<li>这就是 dynamic analysis 的本质<ul>
<li>如何减少 printf 的数量、怎么巧妙地记录、怎样分析日志……</li>
<li>如何调控程序的执行？找到 bug 还是绕开 bug？</li>
</ul>
</li>
</ul>
<p>“文件系统是磁盘上的一个数据结构”</p>
<ul>
<li>通过 append-only 实现 journaling</li>
<li>LSM Tree 和分布式 key-value store<ul>
<li>Block chain 也是一个数据结构！</li>
</ul>
</li>
</ul>
<h3 id="32-5-1-新学习方向–并发：走向分布式系统"><a href="#32-5-1-新学习方向–并发：走向分布式系统" class="headerlink" title="32.5.1 新学习方向–并发：走向分布式系统"></a>32.5.1 新学习方向–并发：走向分布式系统</h3><p><strong>分布式系统问题</strong></p>
<ul>
<li>没有共享的内存</li>
<li>任何一台机器都有可能消失<br>如何在不可靠的系统上实现可靠的系统；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230912163948.png"
                     
                ></li>
</ul>
<p><strong>如何为网络上的多台计算机提供统一的应用程序接口</strong></p>
<ul>
<li>把多个分布的、随时可能离线的计算机组成一个存储系统</li>
<li>在存储的基础上完成计算</li>
</ul>
<h3 id="32-5-2-新学习方向–虚拟化：重新理解操作系统设计"><a href="#32-5-2-新学习方向–虚拟化：重新理解操作系统设计" class="headerlink" title="32.5.2 新学习方向–虚拟化：重新理解操作系统设计"></a>32.5.2 新学习方向–虚拟化：重新理解操作系统设计</h3><p>没有人规定操作系统里一定要有 “文件”、“进程” 这些对象；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230912164129.png"
                     
                ></p>
<ul>
<li>可以在用户态实现文件习惯（微内核就这样做的）<ul>
<li>把大部分代码隔离在用户态，隔离性更好；</li>
<li>代码发生崩溃时，更难干扰到其他部分；</li>
</ul>
</li>
</ul>
<h3 id="32-5-3-新学习方向–持久化：重新理解持久存储设计"><a href="#32-5-3-新学习方向–持久化：重新理解持久存储设计" class="headerlink" title="32.5.3 新学习方向–持久化：重新理解持久存储设计"></a>32.5.3 新学习方向–持久化：重新理解持久存储设计</h3><p><strong>文件系统没能解决的需求</strong></p>
<ul>
<li>大量的数据 (订单、用户、网络……) + 非简单目录遍历性质的查询</li>
</ul>
<p><strong>“数据库”：虚拟磁盘上的数据结构</strong></p>
<ul>
<li>就像我们在内存 (random access memory) 上构建各种数据结构<ul>
<li>Binary heap, binary search tree, hash table, …</li>
</ul>
</li>
<li>典型的数据库<ul>
<li>关系数据库 (二维表、关系代数)</li>
<li>key-value store (持久化的 <code>std::map</code>)</li>
<li>VCS (目录树的快照集合)</li>
</ul>
</li>
<li>SSD 和 NVM 带来的新浪潮</li>
</ul>
<h3 id="32-5-4-和操作系统相关的主题"><a href="#32-5-4-和操作系统相关的主题" class="headerlink" title="32.5.4 和操作系统相关的主题"></a>32.5.4 和操作系统相关的主题</h3><ul>
<li>Computer Architecture<ul>
<li>计算机硬件的设计、实现与评估</li>
</ul>
</li>
<li>Computer Systems<ul>
<li>系统软件 (软件) 的设计、实现与评估</li>
</ul>
</li>
<li>Network Systems<ul>
<li>网络与分布式系统的设计、实现与评估</li>
</ul>
</li>
<li>Programming Languages<ul>
<li>状态机 (计算过程) 的描述方法、分析和运行时支持</li>
</ul>
</li>
<li>Software Engineering<ul>
<li>程序&#x2F;系统的构造、理解和经验</li>
</ul>
</li>
<li>System&#x2F;Software Security<ul>
<li>系统软件的安 (safety) 全 (integrity)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】CLR寄宿与AppDomain（1）-- 基本概念</title>
    <url>/2023/09/a5b39cbba297.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h1 id="1-CLR-寄宿与-AppDomain-介绍"><a href="#1-CLR-寄宿与-AppDomain-介绍" class="headerlink" title="1 CLR 寄宿与 AppDomain 介绍"></a>1 CLR 寄宿与 AppDomain 介绍</h1><p><strong>寄宿（hosting）基本概念</strong><br>CLR寄宿（Common Language Runtime Hosting）是指将托管代码与CLR（Common Language Runtime）进行交互的过程。 在C#中，CLR作为执行环境负责加载、执行和管理托管代码。 CLR寄宿则允许在托管环境之外，通过与CLR通信来扩展和控制CLR的行为。</p>
<ul>
<li>寄宿使得任何应用程序都可以使用CLR的功能，并且它使得现有的应用程序能部分使用托管代码编写；</li>
<li>寄宿为应用程序提供了编程的接口，来进一步的自定义以及扩展；<ul>
<li>可扩展性意味着第三方代码可以在进程中进行；</li>
<li>即可以使用DLL来扩展；但DLL中的代码容易破坏应用程序的状态（数据结构与代码），并可能利用应用程序本身的上下文来窃取无法访问的资源；</li>
</ul>
</li>
</ul>
<p><strong>CLR寄宿的使用场景</strong><br>在C#中，CLR寄宿的使用场景主要包括以下几个方面：</p>
<ol>
<li>自定义宿主环境：通过CLR寄宿，可以创建自定义的托管代码宿主环境，以满足特定的需求。 这样的需求可能包括自定义的安全性机制、资源管理、日志记录等。  </li>
<li>扩展CLR行为：通过CLR寄宿，可以扩展CLR的行为。 例如，可以在托管代码执行前进行一些预处理或后处理操作，或者向CLR注入自定义的监听器或拦截器。</li>
<li>与非托管代码的交互：CLR寄宿还提供了一种机制，使托管代码能够与非托管代码进行交互。 这样，可以在C#中调用C或C++编写的原生库，并利用其功能或性能优势。</li>
</ol>
<p><strong>AppDomain基本概念</strong><br>AppDomain是CLR中的一个隔离容器，用于在一个进程内运行多个托管代码的环境。 每个AppDomain都有自己的虚拟内存空间和加载上下文，可以加载和卸载托管程序集，并提供一定程度的隔离性和安全性。</p>
<ul>
<li>AppDomain 允许第三方的、不受信任的代码在现有的进程中运行，而CLR保证数据结构、代码和安全上下文不被滥用或破坏；</li>
</ul>
<p><strong>AppDomain使用场景</strong><br>在C#中，AppDomain的使用场景主要包括以下几个方面：</p>
<ol>
<li>插件化架构：通过使用AppDomain，可以实现插件化架构，将不同功能的托管代码加载到独立的AppDomain中。 这样可以有效隔离插件之间的冲突，提高应用程序的可靠性和扩展性。</li>
<li>动态加载和卸载程序集：AppDomain允许在运行时动态加载和卸载程序集，从而实现动态扩展应用程序的功能。 这对于需要灵活加载和卸载托管代码的场景非常有用。</li>
<li>安全隔离：每个AppDomain都有自己的安全策略和权限设置，可以提供一定程度的安全隔离。 这对于需要运行不可信代码或实现多级安全权限管理的应用程序非常重要。</li>
</ol>
<h1 id="2-CLR-寄宿基础"><a href="#2-CLR-寄宿基础" class="headerlink" title="2 CLR 寄宿基础"></a>2 CLR 寄宿基础</h1><p><strong>CLR寄宿运行环境</strong><br>因为NETFramework在Windows平台的顶部运行，所以.NET Framework必须用Windows能理解的技术来构建，即所有托管模块和程序集文件都必须使用 Windows PE文件格式，而且要么是Windows EXE文件，要么是DLL文件；</p>
<ul>
<li>对CLR开发<ul>
<li><ol>
<li>Microsoft实际是把它实现成包含在一个DLL中的COM服务器；</li>
</ol>
</li>
<li><ol start="2">
<li>Microsoft为CLR定义了一个标准的COM接口，安装.NET框架的时候代表CLR的COM服务器在微软的Windows注册表中登记；</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>创建CLR COM服务器实例</strong><br>创建实例：对于非托管宿主，应该使用MetaHost.h中的CLRCreateInstance来创建其实例；</p>
<ul>
<li>CLRCreateInstance函数与MSCorEE.dll<ul>
<li>此函数在 MSCorEE.dll 文件（垫片）中实现； </li>
<li>CLRCreateInstance 函数可返回一个 ICLRMetaHost 接口。宿主应用程序可调用这个接口的 GetRuntime 函数，指定宿主要创建的CLR的版本；</li>
<li>垫片将所需版本的CLR加载到宿主的进程中；</li>
</ul>
</li>
</ul>
<p><strong>MSCorEE.dll</strong><br>此文件在 C:\Windows\System32 目录下，MSCorEE.dll可决定创建什么版本的CLR；</p>
<ul>
<li>一个机器可以有多个版本的CLR，但只能有一个MSCorEE.dll；</li>
</ul>
<p><strong>GetRuntime函数</strong><br>此函数可以返回指向ICLRRuntimeInfo接口的指针；此指针可以利用GetInterface方法获得ICLRRuntimeHost接口；</p>
<ul>
<li>宿主应用程序可调用接口定义的方法做以下事情：<ul>
<li>设置宿主管理器：告诉 CLR 宿主想参与涉及以下操作的决策：内存分配、线程调度&#x2F;同步以及程序集加载等；</li>
<li>获取CLR管理器：告诉CLR阻止使用某些类&#x2F;成员。另外，宿主能分辨哪些代码可以调试，哪些不可以；</li>
<li>初始化并启动CLR；</li>
<li>加载程序集并执行其中的代码；</li>
<li>停止CLR；</li>
</ul>
</li>
</ul>
<h1 id="3-AppDomain-基础"><a href="#3-AppDomain-基础" class="headerlink" title="3 AppDomain 基础"></a>3 AppDomain 基础</h1><p><strong>AppDomain基础概念介绍</strong><br>AppDomain 是为了提供隔离而设计的。</p>
<ul>
<li>CLR COM 服务器初始时会创建一个AppDomain；</li>
<li>AppDomain 是一组程序集的逻辑容器，CLR初始化时创建的第一个AppDomain称为“默认AppDomain”，这个默认的AppDomain只有在Windows进程终止时才会被销毁；</li>
<li>除了默认 AppDomain，正在使用非托管COM接口方法或托管类型方法的宿主还可要求CLR创建额外的 AppDomain；</li>
</ul>
<h2 id="3-1-AppDomain具体功能"><a href="#3-1-AppDomain具体功能" class="headerlink" title="3.1 AppDomain具体功能"></a>3.1 AppDomain具体功能</h2><p><strong>功能1：一个AppDomain的代码不能直接访问另一个AppDomain代码创建的对象</strong></p>
<ol>
<li>AppDomain中的代码创建了一个对象后，该对象便被该AppDomain拥有；</li>
<li>换言之：它的生存期不能超过创建它的代码所在的AppDomain；</li>
<li>一个AppDomain中的代码要访问另一个AppDomain 中的对象，只能使用“按引用封送”(marshal-by-reference)或者“按值封送”(marshal-by-value)的语义。这就强制建立了清晰的分隔和边界，因为一个AppDomain中的代码不能直接引用另一个AppDomain中的代码创建的对象。</li>
<li>隔离的机制使 AppDomain 能很容易地从进程中卸载，不会影响其他 AppDomain 正在运行的代码；</li>
</ol>
<p><strong>功能2：AppDomain可以卸载</strong><br>CLR不支持从AppDomain中卸载特定的程序集，但可以告诉CLR卸载一个AppDomain，从而卸载该AppDomain当前包含的所有程序集；</p>
<p><strong>功能3：AppDomain可以单独保护</strong><br>AppDomain 创建后会应用一个权限集，它决定了向这个 AppDomain 中运行的程序集授予的最大权限；<br>由于存在这些权限，所以当宿主加载一些代码后，可以保证这些代码不会破坏宿主本身使用的一些重要数据结构；</p>
<p><strong>功能4：AppDomain可以单独配置</strong><br>AppDomain 创建后会关联一组配置设置，这些设置主要影响CLR在AppDomain中加载程序集的方式；<br>涉及搜索路径、版本绑定重定向、卷影复制以及加载器优化；</p>
<h2 id="3-2-AppDomain与Windows进程"><a href="#3-2-AppDomain与Windows进程" class="headerlink" title="3.2 AppDomain与Windows进程"></a>3.2 AppDomain与Windows进程</h2><p><strong>Windows上的进程</strong><br>一个Windows进程由若干AppDomain和执行引擎构成；其中运行着一个CLR COM服务器，该CLR当前管着两个AppDomain；</p>
<ul>
<li>Loader堆<ul>
<li>运行的AppDomain数量没有硬性制，每个AppDomain都有自己的 Loader 堆，每个 Loader 堆都记录了自 AppDomain 创以来已访问过哪些类型；</li>
<li>Loader 堆中的每个类型对象者有一个方法表，方法表中的每个记录项都指向JIT编译的本机代码（前提此方法得至少执行过一次）</li>
</ul>
</li>
<li>程序集<ul>
<li>每个AppDomain都加载了一些程序集，包括MyApp.exe、TypeLib.dll等；</li>
<li>两个AppDomain都加载了System.dll程序集，但类型对象的内存不会被两个AppDomain共享；</li>
<li>并且，AppDomain中的代码调用一个类型定义的方法时，方法的IL代码将进行JIT编译，生成的本机代码和每个单独的AppMain关联，而不和所有的AppDomain共享；</li>
</ul>
</li>
<li>MSCorLib.dd与程序集共享<ul>
<li>该程序集包含了System.Object、System.Int32以及其他所有与 .NET Framework 密不可分的类型；</li>
<li>CLR初始化时，该程序集会自动加载，而且所有AppDomain都共享该程序集中的类型；</li>
<li>为了减少资源消耗，MSCorLib.dll程序集以一种<strong>AppDomain中立</strong>的方式加载；</li>
<li>针对以 AppDomain 中立的方式加载的程序集，CLR会为它们维护一个特殊的 Loader 堆，该Loader 堆中的所有类型对象以及为这些类型定义的方法JIT编译生成的所有本机代码，都会由进程中的所有AppDomain共享；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230904120337.png"
                     
                ></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>CSharp</tag>
        <tag>CLR</tag>
        <tag>AppDomain</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】CLR寄宿与AppDomain（2）-- 跨越AppDomain边界访问对象</title>
    <url>/2023/09/a1092601f220.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<ul>
<li>1 跨 AppDomain 基本概念<ul>
<li>1.1 App Domain 基本属性</li>
</ul>
</li>
<li>2 按引用传递进行跨 AppDomain 通信<ul>
<li>2.1 MarshalByRefType 类型与按引用传递</li>
<li>2.2 卸载 AppDomain 与静态成员</li>
</ul>
</li>
<li>3 按值传递进行跨 AppDomain 通信<span id="more"></span></li>
</ul>
<h1 id="1-跨-AppDomain-基本概念"><a href="#1-跨-AppDomain-基本概念" class="headerlink" title="1 跨 AppDomain 基本概念"></a>1 跨 AppDomain 基本概念</h1><p>一个 AppDomain 中的代码可以和另一个 AppDomain 中的类型和对象通信，但只能通过良好定义的机制进行。<br>以下代码演示了以下三种类型在构造时的不同行为：</p>
<ol>
<li>“按引用封送”(Marshal-by-Reference)类型；</li>
<li>“按值封送”(Marshalby-Value)类型；</li>
<li>完全不能封送的类型；<br>代码还演示了创建它们的 AppDomain 卸载时这些对象的不同行为。</li>
</ol>
<h2 id="1-1-AppDomain基本属性"><a href="#1-1-AppDomain基本属性" class="headerlink" title="1.1 AppDomain基本属性"></a>1.1 AppDomain基本属性</h2><p>Marshalling方法首先获得一个 AppDomain 对象引用，当前调用线程正在该 AppDomain 中执行；</p>
<p><strong>线程与AppDomain关系</strong></p>
<ul>
<li>在Windows中，线程总是在一个进程的上下文中创建，而且线程的整个生存期都在该进程的生存期内；</li>
<li><strong>线程和AppDomain没有一对一关系</strong>；<ul>
<li>AppDomain 是一项CLR的功能，Windows对AppDomain一无所知；</li>
<li>由于一个Windows进程可包含多个AppDomain，所以线程能执行一个AppDomain中的代码，再执行另一个AppDomain中的代码；</li>
<li>从CLR的角度看，线程一次只能执行一个 AppDomain 中的代码；</li>
</ul>
</li>
<li>线程可调用 System.Threading.Thread 的静态方法GetDomain，来向CLR询问它正在哪个AppDomain中执行；</li>
</ul>
<p><strong>友好名称</strong><br>AppDomain创建后可被赋予一个友好名称；</p>
<ul>
<li>它是用于标识AppDomain的一个String；</li>
<li>友好名称主要是为了方便调试，由于CLR要在我们的任何代码执行前创建默认 AppDomain，所以使用可执行文件的文件名作为默认的 AppDomain 友好名称；</li>
<li>Marshalling 方法使用System.AppDomain的只读FriendlyName属性来查询默认AppDomain的友好名称。</li>
</ul>
<h1 id="2-按引用传递进行跨-AppDomain-通信"><a href="#2-按引用传递进行跨-AppDomain-通信" class="headerlink" title="2 按引用传递进行跨 AppDomain 通信"></a>2 按引用传递进行跨 AppDomain 通信</h1><p><strong>创建新AppDomain</strong><br>通过调用<code>System.AppDomain</code>的静态方法<code>CreateDomain()</code>来指示同一个Window进程中，创建一个AppDomain；</p>
<p><strong>CreateDomain方法</strong><br>CreateDomain 方法内部会在进程中新建一个AppDomain，该AppDomain将被赋予指定的友好名称、安全性和配置设置；<br>新 AppDomain 有自己的 Loader 堆，这个堆目前是空的，因为还没有程序集加载到新AppDomain中；<br>创建AppDomain时，CLR不在这个AppDomain中创建任何线程。AppDomain中也不会运行代码，除非显式地让一个线程调用AppDomain中的代码。</p>
<ul>
<li>参数一<ul>
<li>代表新的AppDomain的友好名称的String；</li>
</ul>
</li>
<li>参数二<ul>
<li>用于设置新的AppDomain的权限集合；</li>
<li><code>System.Security.Policy.Evidence</code>用于计算权限集，传递null时表示继承自创建它的AppDomain；</li>
<li>构建权限集：<code>System.Security.PermissionSet</code>；</li>
</ul>
</li>
<li>参数三<ul>
<li>用于设置新的AppDomain的属性配置；</li>
<li>可以使用<code>AppDomainSetup</code>来进行特殊配置；</li>
</ul>
</li>
</ul>
<p><strong>在新AppDomain中创建类型实例</strong><br>在新AppDomain中创建类型实例主要分为两个步骤：</p>
<ol>
<li>将程序集加载到新的AppDomain中；</li>
<li>构造程序集中定义类型的实例（由CreateInstanceAndUnwrap方法实现）；</li>
</ol>
<ul>
<li>CreateInstanceAndUnwrap 方法<ul>
<li>参数一：标识了想在新AppDomain中加载的程序集；</li>
<li>参数二：标识了想构建其实例的那个类型的名称；</li>
<li>内部实现：<ul>
<li><ol>
<li>CreateInstanceAndUnwrap 方法导致调用线程从当前 AppDomain 切换新的 AppDomain，线程将指定的程序集加载到新的AppDomain当中</li>
</ol>
</li>
<li><ol start="2">
<li>扫描程序集的类型定义元数据表，查找参数二中传入的指定的类型；</li>
</ol>
</li>
<li><ol start="3">
<li>调用将找到的类型的无参构造函数；</li>
</ol>
</li>
<li><ol start="4">
<li>返回默认 AppDomain ，使用返回的对象引用；</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>按引用传递问题：CLR 不允许一个 AppDomain 中的变量引用另一个 AppDomain 中创建的对象</strong><br>CLR 不允许一个 AppDomain 中的变量引用另一个 AppDomain 中创建的对象。如果 CreateInstanceAndUnwrap 直接返回对象引用，隔离性就会被打破，而隔离是 AppDomain 的全部目的。<br>因此，CreateInstanceAndUnwrap 在返回对象引用前要执行一些额外的逻辑，并且使用 MarshalByRefType 类型进行实例的传递；</p>
<h2 id="2-1-MarshalByRefType-类型与按引用传递"><a href="#2-1-MarshalByRefType-类型与按引用传递" class="headerlink" title="2.1 MarshalByRefType 类型与按引用传递"></a>2.1 MarshalByRefType 类型与按引用传递</h2><p><strong><code>MarshalByRefType</code> 和 <code>AppDomain</code> 的关系</strong><br><code>AppDomain</code>是C#中用于隔离和管理应用程序运行环境的单元。每个<code>AppDomain</code>都有自己的内存空间和加载的程序集集合。当需要在不同的<code>AppDomain</code>之间进行对象通信时，可以使用<code>MarshalByRefType</code>类型。<br>通过将继承自 <code>MarshalByRefType</code> 的对象实例传递到不同的 <code>AppDomain</code> 中，可以在目标 <code>AppDomain</code> 中创建该对象的代理引用。通过这个代理引用，可以实现在不同的 <code>AppDomain</code> 中调用对象的方法，并在本地应用程序域中获取返回的结果。</p>
<p><strong>MarshalByRefType 类型介绍</strong><br>MarshalByRefType 类型从 System. MarshalByRefObject 派生，当使用 CreateInstanceAndUnwrap 方法发现其封装的对象是继承自 MarshalByRefType 类型时，CLR 就会跨 AppDomain 边界按照引用传递对象。</p>
<ul>
<li>从 MarshalByRefType 派生的类型可以定义实例字段，只不过这些实例字段不会成为代理类型的一部分，也不会包含在代理对象当中；</li>
<li>当写代码对派生自 MarshalByRefType 类型的实例进行读写时，JIT 编译器会自动生成代码，分别调用方法来使用代理对象。其利用反射的机制来获得数值；</li>
</ul>
<p><strong>引用传递过程分析</strong></p>
<ul>
<li>第一步：检查<ul>
<li>检查类型是否是继承自 System. MarshalByRefObject，如果继承自其，再进入以下内容；</li>
</ul>
</li>
<li>第二步：创建代理实例<ul>
<li>CLR 在目标 AppDomain 的 Loader 堆当中创建一个代理类型；</li>
<li>代理类型使用原属类型的元数据定义，有完全一样的实例成员 (属性、事件和方法)；</li>
<li>但实例字段不会成为代理类型的一部分，其确实定义了几个自己的实例字段，但这些字段和原始类型的不一致。相反，这些字段只是指出哪个 AppDomain “拥有”真实的对象，以及如何在拥有对象的 AppDomain 中找到真实的对象；</li>
</ul>
</li>
<li>第三步：返回代理<ul>
<li>第二步定义好代理类型后，接下来使用 CreateInstanceAndUnwrap 方法创建代理类型的实例，初始化它的字段来标识源 AppDomain 和目标 AppDomain 区别，将此代理返回给目标 AppDomain 。</li>
</ul>
</li>
<li>第四步：使用代理方法与字段<ul>
<li>此时可以使用代理实现来获得对象中的信息字段，将调用线程从默认的 AppDomain 切换为目标 AppDomain  ；</li>
</ul>
</li>
</ul>
<h2 id="2-2-卸载-AppDomain-与静态成员"><a href="#2-2-卸载-AppDomain-与静态成员" class="headerlink" title="2.2 卸载 AppDomain 与静态成员"></a>2.2 卸载 AppDomain 与静态成员</h2><p><strong>卸载 AppDomain</strong><br>应用程序调用 AppDomain 类的公共静态 Unload 方法，这会强制 CLR 卸载指定的 AppDomain ，并且包括加载到其中的所有程序集，并强制执行一次垃圾回收，以释放由卸载的 AppDomain 中的代码创建的所有对象。</p>
<ul>
<li>默认 AppDomain 的 mbrt 变量仍然引用一个有效的代理对象，但代理对象已不再引用一个有效的 AppDomain ，因为它已经卸载；</li>
</ul>
<p><strong>静态成员与引用访问</strong><br>静态成员的调用总是在 AppDomain 当中进行，调用静态成员时没有代理对象，所以不会发生 AppDomain 的切换；</p>
<ul>
<li>类型的静态成员在一个 AppDomain 中执行，实例成员却在另一个 AppDomain 中执行，这不是一种好的编程模型；</li>
</ul>
<p><strong>如何对引用对象进行垃圾回收：租约管理器</strong><br>由于第二个 AppDomain 中没有根，所以代理引用的原始对象可以被垃圾回收。这当然不理想，但另一方面，假如将原始对象不确定地留在内存中，代理可能不再引用它，而原始对象依然存活：这同样不理想。</p>
<ul>
<li>CLR 解决这个问题的办法是使用一个<strong>租约管理器</strong>；</li>
<li>对象的代理创建好之后，CLR 保持对象存活 5 分钟。5 分钟内没有通过租约管理器发出调用，对象就会失效，下次垃圾回收释放它的内存；</li>
<li>每发出一次对对象的调用，“租约管理器”都会续订对象的租期，保证它在接下来的 2 分钟内在内存中保持存活；</li>
</ul>
<h1 id="3-按值传递进行跨-AppDomain-通信"><a href="#3-按值传递进行跨-AppDomain-通信" class="headerlink" title="3 按值传递进行跨 AppDomain 通信"></a>3 按值传递进行跨 AppDomain 通信</h1><p><strong>使用 MarshalByValType 类型实例进行传递</strong><br>MarshalByValType 类型不从 System. MarshalByRefObject 类型继承，因此其不是通过引用的方式来进行实例的传递；</p>
<ul>
<li>按值传递的含义是：<strong>通过对象的序列化，将其以字节数组的方式在跨 AppDomain 之间进行传递</strong>；</li>
</ul>
<p><strong>MarshalByValType 类型介绍</strong></p>
<ul>
<li>MarshalByValType 标记了序列化的特性 <code>[Serializable]</code>，当源 AppDomain 想要向目标 AppDomain 发送一个对象时，其将对象的实例字段序列化成一个字节数组；</li>
<li>字节数组从源 AppDomain 复制到目标 AppDomain 当中，然后在目标的 AppDomain 当中反序列化此字节数组；</li>
<li>CLR 创建此类型的实例，并利用字节数组当中的数值初始化对象的字段。即 CLR 在目标 AppDomain 中精确复制了源对象；</li>
<li><code>MethdoWithReturn</code> 方法返回这个副本的引用，完成按值封送；<br>使用按值封送的对象，其在<strong>不同的 AppDomain 当中拥有独立的生存周期，它们的状态也可以独立的更改</strong>；</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>CSharp</tag>
        <tag>CLR</tag>
        <tag>AppDomain</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】CLR寄宿与AppDomain（3）-- 异常通知、监视与高级宿主控制</title>
    <url>/2023/09/9ca281de361c.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h2 id="1-监视-AppDomain"><a href="#1-监视-AppDomain" class="headerlink" title="1 监视 AppDomain"></a>1 监视 AppDomain</h2><p><strong>宿主应用监视 AppDomain 资源</strong><br>当需要分析一个 AppDomain 的 CPU、内存消耗是否超于应有的水准时，可以使用 AppDomain 提供的只读属性来获得这些内容；<br>需要注意的是，监视程序本身也会消耗额外的资源。所有当需要打开监视时，可以将对应的 AppDomain 的静态 MonitoringEnabled 属性设置为 true，从而显示打开监视。</p>
<p><strong>监视 AppDomain 属性</strong><br>打开监视后，有以下四个属性可以用于检测：</p>
<ul>
<li>MonitoringSurvivedProcessMemorySize<ul>
<li>这个 Int 64 静态属性返回由当前 CLR 实例控制的所有 AppDomain 使用的字节数；</li>
<li>这个数字只保证在上一次垃圾回收时是准确的；</li>
</ul>
</li>
<li>MonitoringTotalAllocatedMemorySize<ul>
<li>这个 Int 64 实例属性返特定 AppDomain 已分配的字节数；</li>
<li>这个数字只保证在上一次垃圾回收时是准确的；</li>
</ul>
</li>
<li>MonitoringSurvivedMemorySize<ul>
<li>这个 Int 64 实例属性返回特定 AppDomain 当前正在使用的字节数；</li>
<li>这个数字只保证在上一次垃圾回收时是准确的；</li>
</ul>
</li>
<li>MonitoringTotalProcessorTime<ul>
<li>这个 TimeSpan 实例属性返回特定 AppDomain 的 CPU 占用率；</li>
</ul>
</li>
</ul>
<h2 id="2-AppDomain-异常通知"><a href="#2-AppDomain-异常通知" class="headerlink" title="2 AppDomain 异常通知"></a>2 AppDomain 异常通知</h2><p><strong>CLR 回调 AppDomain 中的 catch</strong><br>每个 AppDomain 都可以关联一组回调方法；</p>
<ul>
<li>CLR 查找 AppDomain 中的 cateh 块，这些回调方法将得以调用；</li>
<li>可用这些方法执行日志记录操作；</li>
<li>宿主可利用这个机制监视 AppDomain 中抛出的异常；</li>
</ul>
<p><strong>AppDomain 中异常处理过程</strong></p>
<ul>
<li><ol>
<li>CLR 调用向抛出异常的 AppDomain 所登记的所有 FirstChanceException 回调方法；</li>
</ol>
</li>
<li><ol start="2">
<li>CLR 查找上在同一个 AppDomain 中的任何 catch 块；</li>
</ol>
<ul>
<li>3.1 有一个 catch 块能处理异常，则异常处理完成，程序继续正常执行；</li>
<li>3.2 如果 AppDomain 中没有一个 catch 块能处理异常，则 CLR 沿着栈向上来到调用 AppDomain，再次抛出同一个异常对象 ；</li>
<li><em>这时感觉就像是抛出了一个全新的异常 CLR 调用向当前 AppDomain 登记的所有 FirstChanceException 回调方法。</em></li>
</ul>
</li>
<li><ol start="4">
<li>这个过程会直持续，直到抵达线程栈顶部。届时如果异常还未被任何代码处理，CLR 只好终止整个进程。</li>
</ol>
</li>
</ul>
<h2 id="3-宿主程序如何使用-AppDomain"><a href="#3-宿主程序如何使用-AppDomain" class="headerlink" title="3 宿主程序如何使用 AppDomain"></a>3 宿主程序如何使用 AppDomain</h2><p>讲解具体的不同程序或应用场合，是如何使用以及寄宿 CLR 引擎，并在这之上管理 AppDomain。</p>
<h3 id="3-1-可执行应用程序"><a href="#3-1-可执行应用程序" class="headerlink" title="3.1 可执行应用程序"></a>3.1 可执行应用程序</h3><p><strong>托管 EXE 文件基本概念</strong></p>
<ul>
<li>以下应用程序都是自寄宿应用程序：<ul>
<li>控制台 UI 应用程序；</li>
<li>NTService 应用程序； </li>
<li>Windows 窗体应用程序；</li>
<li>Windows PresentationFoundation 应用程序</li>
</ul>
</li>
<li>什么是自寄宿 <ul>
<li>self-hosted</li>
<li>自寄宿，即自己容纳 CLR 的应用程序。它们都有托管 EXE 文件；</li>
</ul>
</li>
</ul>
<p><strong>EXE 应用程序的加载</strong></p>
<ul>
<li>第一步：加载垫片<ul>
<li>Windows 用托管 EXE 文件初始化进程，会加载垫片；</li>
<li>垫片检查应用程序的程序集中的 CLR 头信息；</li>
</ul>
</li>
<li>第二步：加载对应版本 CLR 至进程<ul>
<li>在第一步通过垫片获得了 CLR 头信息后，利用这些信息决定加载哪个版本的 CLR 到进程当中；</li>
</ul>
</li>
<li>第三步：判断 Main 函数位置<ul>
<li>CLR 初始化好后，检查程序的 CLR 头，获得程序入口方法 Main 的位置；</li>
</ul>
</li>
<li>第四步：调用 Main 函数<ul>
<li>获得函数的位置后，正式运行应用程序；</li>
</ul>
</li>
<li>运行过程：加载其他程序集中类型<ul>
<li>引用另一个程序集中的类型时，CLR 会定位所需的程序集，并将其加载到同一个 AppDomain 中；</li>
<li>应用程序的 Main 方法返回后，Windows 进程终止，并销毁默认 AppDomain 和其他所有 AppDomain；</li>
</ul>
</li>
</ul>
<h3 id="3-2-ASP-NET-和-XML-Web-应用程序"><a href="#3-2-ASP-NET-和-XML-Web-应用程序" class="headerlink" title="3.2 ASP .NET 和 XML Web 应用程序"></a>3.2 ASP .NET 和 XML Web 应用程序</h3><p><strong>客户端加载顺序</strong></p>
<ul>
<li>CLR 加载<ul>
<li>补充： ASP .NET 作为一个 ISAPI DLL 的实现，其在进行处理时是 DLL 发出 URL；</li>
<li>客户端在首次请求 DLL 处理的 URL 时，ASP .NET 会加载 CLR；</li>
</ul>
</li>
<li>AppDomain 创建<ul>
<li>后续进行请求 Web 程序，APS .NET 会判断这是不是第一次请求；<ul>
<li>如果是第一次请求，则 APS .NET 会要求 CLR 为该 Web 应用程序创建新的 AppDomain；</li>
</ul>
</li>
<li>Web 应用程序根据虚拟根目录来标识；<ul>
<li>ASP .NET 要求 CLR 将包含应用程序所公开类型的程序集加载到新 AppDomain 中，创建该型的实例；</li>
<li>调用其中的方法，响应客端的 Web 请求；</li>
<li>如果代码引用了更多的类型，CLR 将所需的程序集加载到 Web 应用程序的 AppDomain 中。</li>
</ul>
</li>
<li>如果客户端请求已开始运行的 Web 应用程序，ASPNET 就不再新建 AppDomain 了而是使用现有的 AppDomain； <ul>
<li>创建 Web 应用程序的类型的新实例，并开始调用方法；</li>
<li>这些方法已 JIT 编译成本机代码，所以后续客户端请求的性能会比较出众；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>请求不同 Web 应用程序时</strong><br>当客户端请求不同的 Web 应用程序时，ASP .NET 会告诉 CLR 创建新的 AppDomain，此新的 AppDomain 通常会和其他的 AppDomain 一样的工作进程中被创建；</p>
<ul>
<li>大量的 Web 应用程序都在同一个 Windows 进程中运行，可以大大提高系统的运行效率；</li>
<li>每个 Web 应用程序集加载到一个单独的 AppDomain 当中，隔离不同 Web 应用程序的代码和对象；</li>
</ul>
<h2 id="4-高级宿主控制"><a href="#4-高级宿主控制" class="headerlink" title="4 高级宿主控制"></a>4 高级宿主控制</h2><h3 id="4-1-使用托管代码覆盖-CLR-行为"><a href="#4-1-使用托管代码覆盖-CLR-行为" class="headerlink" title="4.1 使用托管代码覆盖 CLR 行为"></a>4.1 使用托管代码覆盖 CLR 行为</h3><p><strong>覆盖 CLR 默认行为：System. AppDomainManager 类</strong><br>System. AppDomainManager 类运行宿主使用托管代码来覆写 CLR 的默认行为；</p>
<ul>
<li>覆盖方法<ul>
<li><ol>
<li>定义自己的类，此类派生自 System. AppDomainManager 类，重写想要接受控制的虚方法；</li>
</ol>
</li>
<li><ol start="2">
<li>在需要的程序集中生成类，将此类安装到 GAC 上；</li>
</ol>
</li>
<li><ol start="3">
<li>告诉 CLR 使用你的 System. AppDomainManager 派生类；</li>
</ol>
<ul>
<li>创建一个 App Domain Setup 对象，初始化它的基本属性；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>System. AppDomainManager 可做行为</strong><br>AppDomainManager 派生类的作用是<strong>使宿主保持控制权</strong>，即使是在加载项试图创建自己的 AppDomain 时；</p>
<ul>
<li>进程中的代码试图创建新 AppDomain 时，那个 AppDomain 中的 AppDomainManager 派生对象可修改安全性和配置设置；</li>
<li>AppDomainManager 还可决定阻止一次 AppDomain 创建，或返回对现有 AppDomain 的引用；</li>
<li>新 AppDomain 创建好之后，CLR 会在其中创建新的 AppDomainManager 派生对象。这个对象也能修改配置设置、决定执行上下文如何在线程之间切换，并决定向程序集授予的权限。</li>
</ul>
<h3 id="4-2-得体-粗略的终止-AppDomain"><a href="#4-2-得体-粗略的终止-AppDomain" class="headerlink" title="4.2 得体&#x2F;粗略的终止 AppDomain"></a>4.2 得体&#x2F;粗略的终止 AppDomain</h3><p><strong>两种终止 AppDomain 行为</strong></p>
<ul>
<li>得体的终止<ul>
<li>得体的终止将会执行资源的清理代码；</li>
<li>finally 中的代码将会执行；</li>
<li>finalize 方法将会执行；</li>
<li>如果程序此时正在执行 finally 或者 finalize 中代码，则无法立即终止；反之粗鲁的终止可以；</li>
</ul>
</li>
<li>粗鲁的终止<ul>
<li>清理代码将不会执行；</li>
<li>finally 中的代码可能不会执行；</li>
<li>finalize 方法可能不会执行；</li>
</ul>
</li>
</ul>
<p><strong>升级策略</strong><br>宿主可设置所谓的升级策略，从而告诉 CLR 应该如何处理托管代码的错误；</p>
<ul>
<li>例如 SQLServer 就告诉 CLR 在执行托管代码时，假如遇到未处理的异常应该如何处 理；</li>
<li>线程遇到未经处理的异常时，CLR 首先尝试将该异常升级成一次得体的线程终止；</li>
<li>如果线程在指定时间内没有终止，CLR 就尝试将得体的终止升级成粗鲁的终止；</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>CLR</tag>
        <tag>AppDomain</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】CLR执行模型</title>
    <url>/2023/08/5aed3da140f6.html</url>
    <content><![CDATA[<p>将源代码编译成托管模块<br><strong>定义：公共语言运行时（Common Language Runtime，CLR）</strong><br>描绘：是一个可以由多种编程语言使用的”运行时”，其核心功能包括：</p>
<ol>
<li>内存管理</li>
<li>程序集加载</li>
<li>安全性</li>
<li>异常处理</li>
<li>线程同步<span id="more"></span></li>
</ol>
<h2 id="1-1-将源代码编译成托管模块"><a href="#1-1-将源代码编译成托管模块" class="headerlink" title="1.1 将源代码编译成托管模块"></a>1.1 将源代码编译成托管模块</h2><p><strong>定义：公共语言运行时（Common Language Runtime，CLR）</strong><br>描绘：是一个可以由多种编程语言使用的”运行时”，其核心功能包括：</p>
<ol>
<li>内存管理</li>
<li>程序集加载</li>
<li>安全性</li>
<li>异常处理</li>
<li>线程同步<br>这些功能可以由所有面向CLR的语言使用。基于CLR的托管语言和非托管C++语言，在系统层面后者可以进行更低级别的控制，可以完全按照自己的想法管理内存。而CLR不管开发者使用哪一种编程语言写源代码，只要其是面向CLR的。因此，CLR提供了其他技术所无法媲美的集成度，使得混合语言编程成为了开发者可以考虑的一个选项。<br>为了执行包含托管代码以及托管数据的模块，用户必须在自己的计算机上安装好CLR（目前作为.NET Framework的一部分被提供）</li>
</ol>
<p>补充：可将编译器是为语法检查其和“正确代码分析器”。</p>
<p><strong>定义：托管模块（managed module）</strong><br>描述：托管模块是标准的32位（PE32）或者64位（PE32+）的Microsoft Windows可移植体文件，基于CLR来运行。<br>托管模块四大部分：</p>
<ol>
<li>PE32 或 PE32+头：如果是依赖于本机CPU的代码，此项会包含和本机CPU相关的信息。</li>
<li>CLR头：包含使这个模块成为托管模块的信息，比如CLR版本，Main方法位置，MethodDef数据，模块元数据等</li>
<li>元数据：源代码的定义数据，源代码的引用数据</li>
<li>IL代码：编译器编译源代码时生成的代码，运行时CLR将IL编译成编辑CPU代码</li>
<li></li>
</ol>
<p><strong>定义：托管代码（managed code）</strong><br>描述：每个面向CLR的编译器生成的代码，都是IL代码（中间代码），IL代码又被称作托管代码。<br>IL代码比大部分CPU机器语言都更加高级，其可以访问和操作对象的类型，并且提供了指令来创建和初始化对象那个、调用对象上的虚方法以及直接操作数组元素。在此意义上，可以将IL理解成是一种<strong>面向对象的机器语言</strong>。<br>补充：使用高级语言只能使用CLR全部功能当中的一个子集，但IL汇编语言运行开发人员访问CLR全部功能。<br>逻辑关系：<br>![[Chapter 1：CLR执行模型 2023-03-07 19.16.22.excalidraw]]</p>
<h2 id="1-2-将托管模块合并成程序集"><a href="#1-2-将托管模块合并成程序集" class="headerlink" title="1.2 将托管模块合并成程序集"></a>1.2 将托管模块合并成程序集</h2><p><strong>定义：程序集（assembly）</strong><br>描述：CLR实际上并不和托管模块工作，而是和程序集工作。生成的程序集既可以时可执行文件，也可以是DLL，最终由CLR管理这些程序集中的代码的执行。<br>内容：</p>
<ol>
<li>程序集是一个或者多个模块&#x2F;资源文件的逻辑性分组；</li>
<li>程序集是重用、安全性以及版本控制的最小单元；</li>
<li>利用程序集，可以将一组文件作为一个单独的实体来对待；<br>优势：程序集把文件的逻辑表示和物理表示区分开，利用程序集可以在不同的地方部署文件，在使用到其时再进行下载，不使用其时可以无需下载，但是在对待程序集时确依然将其视为一个整体</li>
</ol>
<p>逻辑关系：<br>![[Chapter 1：CLR执行模型 2023-03-07 19.30.58.excalidraw]]</p>
<h2 id="1-3-加载公共语言运行时"><a href="#1-3-加载公共语言运行时" class="headerlink" title="1.3 加载公共语言运行时"></a>1.3 加载公共语言运行时</h2><p><strong>简介</strong><br>在CLR运行之前，需要设置其平台选项指定最后生成的程序集能够在指定的平台上运行。</p>
<p><strong>CLR运行前设置：设置不同CPU版本</strong><br>在CLR加载之前，C#编译器提供了一个&#x2F;platform的命令行选项，允许指定最后生成的程序集能够在指定的平台上运行。<br>取决于&#x2F;platform开关选项，C#编译器生成的程序集要么包含PE32，要么是PE32+，在可执行文件运行前，Windows会检查文件头，判断需要的是32位还是64位的地址空间。<br>之后，Windows检查EXE文件头，决定创建32位或者64位进程，并在进程地址空间加载MSCorEE.dll的x86、x64或者ARM版本。</p>
<p><strong>MSCorEE.dll</strong><br>进程在Windows当中检查文件头后，需要决定创建32位或者64位进程，之后会在进程的地址空间内加载MSCorEE.dll的对应CPU版本，其不同版本都在<code>%SystemRoot%\System32</code>或者<code>%SystemRoot%\SysWow64</code>目录中。之后进程的主线程调用MSCorEE当中的定义的一个方法，此方法初始化CLR，并加载EXE程序集，调用入口方法Main。</p>
<p><strong>加载CLR</strong></p>
<ol>
<li>可执行文件运行前，Windows会检查文件头，判断需要的是32位还是64位的地址空间。</li>
<li>Windows检查EXE文件头，决定创建32位或者64位进程，并在进程地址空间加载MSCorEE.dll的x86、x64或者ARM版本。</li>
<li>进程的主线程调用MSCorEE.dll中定义的一个方法，此方法初始化CLR，加载EXE程序集，调用其入口方法Main，然后托管应用程序启动并运行。</li>
</ol>
<p>![[Chapter 1：CLR执行模型 2023-03-07 20.10.16.excalidraw]]</p>
<h2 id="1-4-执行程序集的代码"><a href="#1-4-执行程序集的代码" class="headerlink" title="1.4 执行程序集的代码"></a>1.4 执行程序集的代码</h2><p>定义：即时编译器（Just in time，JIT）<br>描述：在执行程序集中IL代码的方法后，需要将IL代码转换成本机（native）指令，此时就由CLR当中的JIT编译器来实现。JIT编译器动态的将本机CPU代码存储到动态内存中，因此一旦应用程序停止，编译好的代码也会被丢弃，之后再次启动或者存在两个实例时需要在此编译。</p>
<p>定义：记录项<br>描述：CLR会分配一个内部的数据结构来管理对引用类型的访问。CLR将引用的类型当中的每个方法都设置一个记录项，这个记录项都含有一个地址，此地址指向该方法的具体实现。当JIT访问记录项，想编译对应函数时，即可顺着此记录项找到对应IL代码。</p>
<p><strong>执行过程</strong><br>在Main方法执行之前，CLR检测出Main代码引用的所有类型，导致CLR分配一个内部的数据结构来管理对引用类型的访问。CLR将引用的类型当中的每个方法都设置一个记录项， CLR将每个记录项设置为包含在CLR内部的一个未编档函数，此函数为JITCompiler。在调用对应方法时，JITCompiler被调用，查询元数据找到IL代码，并且将此IL代码编译成本机CPU指令。<br>本机CPU代码动态分配到内存块当中，然后JITCompiler回到CLR为类型创建的内部数据结构，找到被调用方法对应的那条记录，将其修改（原本为对JITCompiler的引用）为指向CPU代码的内存块。第二次验证时，会跳过JITCompiler函数，直接执行内存块当中的代码。因为第二次调用不需要编译，因此只有在首次调用时有一些性能损失。</p>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>CLR</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】托管堆与垃圾回收（1）-- 托管堆</title>
    <url>/2023/08/4b26dd1d757b.html</url>
    <content><![CDATA[<ul>
<li><ol>
<li>为什么要有托管堆</li>
</ol>
</li>
<li><ol start="2">
<li>什么是托管堆</li>
</ol>
</li>
<li><ol start="3">
<li>垃圾回收算法</li>
</ol>
<ul>
<li><ol>
<li>引用计数算法</li>
</ol>
</li>
<li><ol start="2">
<li>引用跟踪算法<span id="more"></span></li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="1-为什么要有托管堆"><a href="#1-为什么要有托管堆" class="headerlink" title="1 为什么要有托管堆"></a>1 为什么要有托管堆</h1><h2 id="1-1-面向对象与资源分配"><a href="#1-1-面向对象与资源分配" class="headerlink" title="1.1 面向对象与资源分配"></a>1.1 面向对象与资源分配</h2><p><strong>面向对象中的资源</strong><br>概念：在面向对象的环境中，任何一种类型都代表了计算机中可供程序使用的一种资源。如果要使用这种资源，就需要为这种资源分配一定的内存；</p>
<p><strong>资源分配步骤</strong></p>
<ul>
<li>第一步<ul>
<li>调用IL代码<code>newobj</code>，为代表资源的类型分配内存；</li>
<li>此步骤通常由new操作符来触发并完成；</li>
</ul>
</li>
<li>第二步<ul>
<li>根据类型的状态设置，初始化内存，设置资源的初始状态并使得此资源可用；</li>
<li>由类型的实例构造函数来设置初始状态；</li>
</ul>
</li>
<li>第三步<ul>
<li>访问类型的成员来使用此资源</li>
</ul>
</li>
<li>第四步<ul>
<li>摧毁资源的状态，以进行垃圾的清理</li>
</ul>
</li>
<li>第五步<ul>
<li>由GC回收期释放内存</li>
</ul>
</li>
</ul>
<h2 id="1-2-为什么需要托管堆来进行垃圾回收"><a href="#1-2-为什么需要托管堆来进行垃圾回收" class="headerlink" title="1.2 为什么需要托管堆来进行垃圾回收"></a>1.2 为什么需要托管堆来进行垃圾回收</h2><p><strong>C++中的例子</strong><br>在需要程序员手动管理内存的语言中（比如当C++不使用shareptr或其他基于对象的指针时），程序员经常会产生两种错误：</p>
<ol>
<li>忘记释放不再需要的内存，进而造成内存泄漏；</li>
<li>尝试使用已经释放的内存，造成安全漏洞；<br>由于这两种错误经常是在程序运行时才能发现，因此程序发生异常时调试困难。</li>
</ol>
<p><strong>解决方法：可验证的、类型安全的代码</strong><br>在资源分配阶段中的【第四步】，此步骤若不是由程序员来完成，而是交给程序的托管堆和垃圾回收器来自动进行时，此时程序就能进一步的保证安全；</p>
<ul>
<li>托管堆会自动完成垃圾的回收，并且当需要手动进行回收时，托管堆还提供了一个简化的模型；</li>
</ul>
<p><strong>补充：需要特殊清理的类型</strong><br>部分包装了本机资源的类型，比如对文件、Socket、数据库连接资源的类型，可能无法使用自动进行的垃圾回收，而是需要程序员使用GC的手动触发；</p>
<h1 id="2-什么是托管堆"><a href="#2-什么是托管堆" class="headerlink" title="2 什么是托管堆"></a>2 什么是托管堆</h1><h2 id="2-1-托管堆基本概念"><a href="#2-1-托管堆基本概念" class="headerlink" title="2.1 托管堆基本概念"></a>2.1 托管堆基本概念</h2><p><strong>托管堆</strong><br>在C#中，托管堆是一种用于存储和管理托管对象（即运行在CLR中的对象）的内存区域。它是CLR的一部分，为托管对象提供动态内存分配和释放的功能。托管堆是一种自动化内存管理机制，它通过垃圾回收器自动回收不再使用的对象，从而释放内存并确保内存的正确使用。</p>
<p><strong>NextObjPtr</strong><br>CLR会在程序的托管堆中管理一个指针NextObjPtr，此指针会一直指向下一个对象在队中分配的位置。在最开始时，此指针指向地址空间的基地址；</p>
<p><strong>内存自动扩张</strong><br>在一个区域的内存备非垃圾对象填满之后，CLR会自动分配更多的区域。此过程会一直进行，直到进程的地址空间被填满；</p>
<h2 id="2-2-CLR中的new行为"><a href="#2-2-CLR中的new行为" class="headerlink" title="2.2 CLR中的new行为"></a>2.2 CLR中的new行为</h2><p><strong>执行行为</strong><br>C#的new操作符将导致CLR执行以下步骤：</p>
<ul>
<li>第一步<ul>
<li>计算类型的字段(包括从基类型继承的字段)所需的字节数。</li>
</ul>
</li>
<li>第二步<ul>
<li>加上对象额外所需的两部分开销所需的字节数；</li>
<li>每个对象都有两个开销字段：<ul>
<li>类型对象指针</li>
<li>同步块索引</li>
</ul>
</li>
<li>对于32位应用程序，这两个字段各自需要 32位，所以每个对象要增加8字节。对于64位应用程序，这两个字段各自需要64位，所以每个对象要增加16字节；</li>
</ul>
</li>
<li>第三步<ul>
<li>检查阶段：<ul>
<li>CLR检查区域中是否有分配对象所需的字节数。如果托管堆有足够的可用空间，就在NextObiPtr 指针指向的地址处放入对象，为对象分配的字节会被清零；</li>
</ul>
</li>
<li>调用阶段<ul>
<li>调用类型的构造器，为类型构造器中的this参数传递当前NextObiPtr指向的对象，new操作符返回对象引用；</li>
<li>在返回这个引用之前，NextObjiPtr指针的值会加上对象占用的字节数来得到一个新值，即下个对象放入托管堆时的地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>分配之后的内存，在空间中形式如下简图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230828103459.png"
                      alt="新初始化的托管堆，其中构造了3个对象"
                ></p>
<h2 id="2-3-托管堆与空间局部化"><a href="#2-3-托管堆与空间局部化" class="headerlink" title="2.3 托管堆与空间局部化"></a>2.3 托管堆与空间局部化</h2><p><strong>空间局部化</strong><br>由于托管堆的分配是在指针之上加一个值，因此其分配的速度非常的快；差不多同时分配的对象彼此间有较强的联系，而且经常差不多在同一时间访问；</p>
<ul>
<li><strong>由于托管堆在内存中连续分配这些对象，所以会因为引用的“局部化”(locality)而获得性能上的提升</strong></li>
</ul>
<p><strong>具体的优点</strong></p>
<ul>
<li>优点一<ul>
<li>进程的工作集会非常小，应用程序只需使用很少的内存，从而提高了速度；</li>
</ul>
</li>
<li>优点二<ul>
<li>代码使用的对象可以全部驻留在 CPU 的缓存中。应用程序能以非常快的速度访问这些对象，因为CPU在执行大多数操作不会因Cache Miss而被迫访问较慢的 RAM；</li>
</ul>
</li>
</ul>
<h1 id="3-垃圾回收算法"><a href="#3-垃圾回收算法" class="headerlink" title="3 垃圾回收算法"></a>3 垃圾回收算法</h1><p>在应用程序调用new操作符创建对象时，可能会没有足够地址空间来分配该对象，此时CLR就需要执行垃圾回收。</p>
<h2 id="3-1-引用计数算法"><a href="#3-1-引用计数算法" class="headerlink" title="3.1 引用计数算法"></a>3.1 引用计数算法</h2><p><strong>什么是引用计数算法</strong><br>对于对象生存期的管理，有些系统使用的是引用计数算法；<em>比如微软的COM</em></p>
<p><strong>算法内容</strong><br>堆上的每个对象都维护着一个内存字段，用于统计程序中多少部分正在使用对象。随着每一部分到达代码中某个不再需要对象的地方，就递减对象的计数字段。当计数字段变成0，对象就可以从内存中删除；</p>
<p><strong>算法问题：循环引用</strong><br>在一些GUI应用程序中，窗口对象将容纳对子UI对象的引用，而子UI对象将容纳对父窗口对象的引用；<br>这种引用会阻止两个对象的计数器达到 0，所以两个对象永远不会删除，即使应用程序本身不再需要窗口。</p>
<ul>
<li>CLR不使用引用计数算法，而是使用<strong>引用跟踪算法</strong>；</li>
</ul>
<h2 id="3-2-引用跟踪算法"><a href="#3-2-引用跟踪算法" class="headerlink" title="3.2 引用跟踪算法"></a>3.2 引用跟踪算法</h2><p><strong>算法特点</strong><br>引用跟踪算法只关心引用类型的变量，不关心值类型变量。因为只有引用类型的变量才能引用堆上的对象，而值类型变量直接包含值类型实例本身。</p>
<p><strong>基础概念：根</strong><br>在CLR中，将所有引用类型的变量称为<strong>根</strong>；<br>引用类型变量可以在许多场合使用：</p>
<ul>
<li>类的静态字段</li>
<li>类的实例字段</li>
<li>方法参数</li>
<li>局部变量<br>这些内容都可以成为根。</li>
</ul>
<h3 id="3-2-1-算法实现"><a href="#3-2-1-算法实现" class="headerlink" title="3.2.1 算法实现"></a>3.2.1 算法实现</h3><p><strong>第一阶段：暂停阶段</strong><br>暂停进程中的所有线程。这防止线程在CLR检查期间访问对象并更改其状态；</p>
<p><strong>第二阶段：标记阶段</strong></p>
<ul>
<li>CLR 遍历堆中的所有对象，将同步块索引字段中的一位设为 0；<em>当此位设为 0 时，表示此对象应该被删除；为 1 时表示不用删除；</em></li>
<li>设置为 0 之后，表明所有对象都应删除。然后，CLR 检查所有活动根，查看它们引用了哪些对象。如果一个根包含null，CLR忽略这个根并继续检查下个根；</li>
<li>任何根如果引用了堆上的对象，CLR 都会标记那个对象，也就是将该对象的同步块索引中的位设为 1。一个对象被标记后，CLR 会检查那个对象中的根，标记它们引用的对象。如果发现对象已经标记，就不重新检查对象的字段。这就避免了因为循环引用而产生死循环。</li>
<li>全部检查完毕后，堆中的对象要么已标记，要么未标记。<ul>
<li>已标记的对象不能被垃圾回收，因为至少有一个根在引用它。这种对象是<strong>可达reachable</strong>的对象。因为应用程序代码可通过仍在引用它的变量抵达它；</li>
<li>未标记的对象是<strong>不可达unreachable</strong>的，因为应用程序中不存在使对象能被再次访问的根；</li>
</ul>
</li>
</ul>
<p>图示为回收之前的托管堆：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230828105510.png"
                      alt="回收之前的托管堆"
                ></p>
<p><strong>第三阶段：压缩阶段</strong><br>CLR对堆中已标记的对象进行“内存位置的转移，压缩所有幸存下来的对象，使它们占用连续的内存空间，如图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230828105609.png"
                      alt="垃圾回收之后的托管堆"
                ></p>
<ul>
<li>压缩的好处：<ul>
<li>所有幸存对象在内存中紧挨在一起，恢复了引用的“局部化”，减小了应用程序的工作集，从而提升了将来访问这些对象时的性能；</li>
<li>解决了原生堆的空间碎片化问题；</li>
</ul>
</li>
<li>内存偏移<ul>
<li>在内存中移动了对象之后有一个问题待解决：引用幸存对象的根现在引用的还是对象最初在内存中的位置，而非移动之后的位置；</li>
<li>CLR要从每个根减去所引用的对象在内存中偏移的字节数，保证每个根还是引用和之前一样的对象–只是对象在内存中变换了位置；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>垃圾回收</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】托管堆与垃圾回收（2）-- 基于代的垃圾回收算法</title>
    <url>/2023/08/2d466e9f916b.html</url>
    <content><![CDATA[<ul>
<li><ol>
<li>垃圾回收的基本假设</li>
</ol>
</li>
<li><ol start="2">
<li>垃圾回收算法</li>
</ol>
<ul>
<li>2.1 初始化堆与第0代对象</li>
<li>2.2 从第0代对象到第1代对象</li>
<li>2.3 从第1代对象到第2代对象</li>
</ul>
</li>
<li><ol start="3">
<li>垃圾回收触发条件</li>
</ol>
<ul>
<li>3.1 监视垃圾回收内存使用</li>
</ul>
</li>
<li><ol start="4">
<li>大对象</li>
</ol>
</li>
<li><ol start="5">
<li>垃圾回收模式</li>
</ol>
</li>
</ul>
<span id="more"></span>
<h1 id="1-垃圾回收的基本假设"><a href="#1-垃圾回收的基本假设" class="headerlink" title="1 垃圾回收的基本假设"></a>1 垃圾回收的基本假设</h1><p>由于CLR的GC是基于代的垃圾回收器算法，因此其对代码做出了以下几点假设：</p>
<ul>
<li><ol>
<li>对象越新，生存期越短；</li>
</ol>
</li>
<li><ol start="2">
<li>对象越老，生存期越长；</li>
</ol>
</li>
<li><ol start="3">
<li>回收堆的一部分，速度快于回收整个堆；<br>以上假设对于大部分的现代应用程序都成立，其影响了下面GC算法的实现。</li>
</ol>
</li>
</ul>
<h1 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2 垃圾回收算法"></a>2 垃圾回收算法</h1><h2 id="2-1-初始化堆与第0代对象"><a href="#2-1-初始化堆与第0代对象" class="headerlink" title="2.1 初始化堆与第0代对象"></a>2.1 初始化堆与第0代对象</h2><p><strong>实现过程</strong></p>
<ul>
<li>预算容量<ul>
<li>CLR初始化时，为第0代对象选择一个预算容量。</li>
</ul>
</li>
<li>启动垃圾回收<ul>
<li>如果分配一个新对象造成第0代超过预算，就必须立马就启动一次垃圾回收。</li>
<li>假设此时初始化时分配的对象刚好用完第0代的空间，那么分配下一个对象就必须启动垃圾回收。</li>
</ul>
</li>
<li>压缩对象<ul>
<li>垃圾回收器判断对象C和E是垃圾，所以会压缩对象D，使之与对象B相邻。</li>
</ul>
</li>
<li>进入第1代<ul>
<li>在垃圾回收中存活的对象A，B和D现在成为第1代对象。第1代对象已经经历了垃圾回收器的一次检查；</li>
<li>此时第0代不包含任何对象，当下一次再分配内存时，新对象会被继续分配到第0代之中；</li>
</ul>
</li>
</ul>
<p><strong>图片展示</strong><br>初始化堆：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829101037.png"
                     
                ></p>
<p>启动垃圾回收+压缩对象+进入第1代：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829101102.png"
                     
                ></p>
<h2 id="2-2-从第0代对象到第1代对象"><a href="#2-2-从第0代对象到第1代对象" class="headerlink" title="2.2 从第0代对象到第1代对象"></a>2.2 从第0代对象到第1代对象</h2><p><strong>实现过程</strong></p>
<ul>
<li>继续分配<ul>
<li>新分配的对象继续进入第0代；</li>
<li>部分对象（包含第1代与第0代）在程序运行时，逐渐变得不可达；</li>
</ul>
</li>
<li>启动垃圾回收<ul>
<li>新对象造成第0代超出预算；</li>
</ul>
</li>
<li>决定GC检查代<ul>
<li>垃圾回收器必须决定检查哪些代。开始一次垃圾回收时，垃圾回收器除了检查第0代时，还会检查第1代占用了多少内存。</li>
<li>在下图中，由于第1代占用的内存远少于预算，所以垃圾回收器只检查第0代中的对象；</li>
</ul>
</li>
</ul>
<p><strong>基本假设与基于代的GC</strong></p>
<ul>
<li>假设一：对象越新，生存期越短<ul>
<li>因为新的对象在第0代中，并且第0代包含更多垃圾的可能性很大，在GC时能回收更多的内存；</li>
<li>即<strong>对象越新，生存期越短</strong></li>
<li>并且由于忽略了第1代中的对象，所以加快了垃圾回收速度</li>
</ul>
</li>
<li>假设三：回收堆的一部分，速度快于回收整个堆<ul>
<li>忽略第1代中的对象能提升垃圾回收器的性能。对性能有更大提振作用的是：现在不必遍历托管堆中的每个对象；</li>
<li>如果根或对象引用了老一代的某个对象，垃圾回收器就可以忽略老对象内部的所有引用，能在更短的时间内构造好可达对象图；</li>
</ul>
</li>
</ul>
<p><strong>图片展示</strong><br>产生新对象，垃圾产生：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829101709.png"
                     
                ></p>
<p>垃圾回收，对象压缩：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230829101728.png"
                     
                ></p>
<h2 id="2-3-从第1代对象到第2代对象"><a href="#2-3-从第1代对象到第2代对象" class="headerlink" title="2.3 从第1代对象到第2代对象"></a>2.3 从第1代对象到第2代对象</h2><p><strong>实现过程</strong></p>
<ul>
<li>全部预算已满<ul>
<li>假定第1代的增长导致它的所有对象占用了全部预算。此时应用程序继续运行并分配对象，使第0代对象达到它的预算容量；</li>
<li>此时由于第0代已满，必须进行垃圾回收；</li>
<li>此次垃圾回收时发现第1代占用太多空间，导致全部预算用完（并且第1代当中已经有很多对象变得不可达）；</li>
<li>此次垃圾回收需要堆第0代以及第1代对象进行回收；</li>
</ul>
</li>
<li>产生第2代<ul>
<li>经过垃圾回收，产生第2代对象；第0代继续空余出来；</li>
<li><strong>只有在第1代超出预算时才会检查第1代中的对象</strong></li>
</ul>
</li>
</ul>
<p><strong>托管堆与代</strong></p>
<ul>
<li>3代托管堆<ul>
<li>托管堆只支持三代：第0代、第1代和第2代，没有第3代。</li>
</ul>
</li>
<li>代与预算<ul>
<li>CLR初始化时，会为每一代选择预算；</li>
</ul>
</li>
<li>CLR 的垃圾回收器是自调节的<ul>
<li>垃圾回收器会在执行垃圾回收的过程中了解应用程序的行为；<ul>
<li>假定应用程序构造了许多对象，但每个对象用的时间都很短。在这种情况下，对第0代的垃圾回收会回收大量内存；</li>
<li>事实上，第0代的所有对象都可能被回收；</li>
</ul>
</li>
<li><strong>当GC发现回收0代后存活下来的对象很少，就可能减少第0代的预算，反之增加预算</strong>。这种启发式的算法对第1代以及第2代通用适用；</li>
<li>每当垃圾回收进行后，会检查存活下来的对象多少，进而增大或减小这些代的预算；</li>
</ul>
</li>
</ul>
<h1 id="3-垃圾回收触发条件"><a href="#3-垃圾回收触发条件" class="headerlink" title="3 垃圾回收触发条件"></a>3 垃圾回收触发条件</h1><p><strong>垃圾回收可以有以下几种触发条件</strong></p>
<ol>
<li>CLR检测垃圾回收超出代的预算；</li>
<li>代码显示调用System.GC的静态方法Collect；</li>
<li>Windows报告低内存情况；</li>
<li>CLR卸载AppDomain；</li>
<li>CLR关闭；</li>
</ol>
<p><strong>强制垃圾回收</strong><br>System.GC类型允许应用程序对垃圾回收器进行一些直接控制。可以用Collect进行强制垃圾回收，但大部分情况下不推荐。</p>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Collect</span>(<span class="params">Int32 generation,GCCollectionMode mode,Boolean blocking</span>)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>generation<ul>
<li>表示回收第几代的垃圾</li>
</ul>
</li>
<li>GCCollectionMode<ul>
<li>Default：不传递任何符号名称；</li>
<li>Forced：强制回收指定的代(以及低于它的所有代)；</li>
<li>Optimized：只有在能释放大量内存或者能减少碎片化的前提下，才执行回收（强制执行Collect时，尽可能使用这种模式）；</li>
</ul>
</li>
</ul>
<h2 id="3-1-监视垃圾回收内存使用"><a href="#3-1-监视垃圾回收内存使用" class="headerlink" title="3.1 监视垃圾回收内存使用"></a>3.1 监视垃圾回收内存使用</h2><p><strong>监视用方法</strong></p>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">Int32 <span class="title">CollectionCount</span>(<span class="params">Int32 generation</span>)</span>;</span><br><span class="line"><span class="function">Int64 <span class="title">GetTotalMemory</span>(<span class="params">Boolean forceFullCollection</span>)</span>;</span><br></pre></td></tr></table></figure></div>
<h1 id="4-大对象"><a href="#4-大对象" class="headerlink" title="4 大对象"></a>4 大对象</h1><p><strong>什么是大对象</strong><br>在CLR当中，将对象分为大对象和小对象，大于85000字节的对象是大对象；</p>
<p><strong>大对象特点</strong></p>
<ul>
<li>大对象在进程地址空间其他地方分配；</li>
<li>目前的GC不压缩大对象；</li>
<li>大对象总是第2代的，不可能为第0、1代；</li>
</ul>
<h1 id="5-垃圾回收模式"><a href="#5-垃圾回收模式" class="headerlink" title="5 垃圾回收模式"></a>5 垃圾回收模式</h1><p><strong>两种基本的GC模式</strong></p>
<ul>
<li>工作站模式<ul>
<li>该模式针对客户端应用程序优化GC；</li>
<li><strong>CLR默认以工作站模式运行</strong></li>
<li>GC造成的延时很低，应用程序的线程挂起时间短，并且GC假定机器上运行的其他应用程序都不会消耗太多的CPU资源；</li>
</ul>
</li>
<li>服务器模式<ul>
<li>该模式针对服务器端应用程序优化GC；</li>
<li>被优化的主要是吞吐量和资源利用。GC假定机器上没有运行其他应用程序，并假定机器的所有CPU都可用来辅助完成GC；</li>
<li>该模式造成托管堆被拆分成几个区域，每个CPU一个；</li>
<li>开始垃圾回收时，垃圾回收器在每个CPU上都运行一个特殊线程，每个线程都和其他线程并发回收它自己的区域；</li>
<li>这个功能要求应用程序在多CPU计算机上运行使线程能真正地同时工作，从而获得性能的提升。</li>
</ul>
</li>
</ul>
<p><strong>切换工作模式</strong><br>GCLatencyMode定义四种模式：</p>
<ol>
<li>Batch：服务器GC模式的默认值，关闭并发GC；</li>
<li>Interactive：工作站GC模式的默认值，打开并发GC；</li>
<li>LowLatency：此模式时，GC将全力避免第2代垃圾的回收。更容易抛出内存溢出异常；</li>
<li>SustainedLowLatency；</li>
</ol>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>垃圾回收</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】程序集加载与反射（1） -- 程序集的加载</title>
    <url>/2023/09/89642755ef29.html</url>
    <content><![CDATA[<p>当在编译时、对一个类型一无所知的情况下，如何在运行时发现类型的信息，创建类型的实例？<br>创建动态可扩展的应用程序，宿主应用程序可以加载其他公司创建的加载项；</p>
<ul>
<li>宿主可以在一个 AppDomain 中运行加载项代码，这个 AppDomain 有其自己的安全性与配置设置。宿主可以通过卸载 AppDomain 来卸载加载项；<span id="more"></span></li>
</ul>
<h1 id="1-程序集加载"><a href="#1-程序集加载" class="headerlink" title="1 程序集加载"></a>1 程序集加载</h1><p><strong>程序集加载基本概念</strong><br>JIT 编译器在将方法的 IL 代码编译成本机代码时，会查看 IL 代码引用了哪些类型；</p>
<ul>
<li>运行时，JIT 编译器利用程序集中的 <code>TypeRef</code> 和 <code>AssemblyRef</code> 这两个元数据表来确定哪一个程序集定义了所引用的类型。</li>
<li>AssemblyRef 元数据表<ul>
<li>此数据表的记录项当中，包含了构成程序集的强名称各个部分；</li>
<li>JIT 编译器通过这些部分获得名称、版本、文化信息和公钥标记；</li>
<li>JIT 加载其时，将尝试将该公钥标识相匹配的程序集加载到 AppDomain ；</li>
</ul>
</li>
<li>在大多是的动态可扩展应用程序中，Assembly 的 <strong>Load 方法是将程序集加载到 AppDomain 的首选方法</strong>；<ul>
<li>使用此方法前，要求先对程序集标识的各个部分有所掌握；</li>
</ul>
</li>
</ul>
<p><strong>GAC 全局程序集缓存</strong><br>全局程序集缓存（Global Assembly Cache，GAC）是用于存储和管理.NET 程序集的特殊目录。GAC 用于保存具有全局唯一性的程序集，这些程序集可以供多个应用程序或系统共享和重用。</p>
<ul>
<li>GAC 是一个全局的文件夹，位于 Windows 操作系统的特定目录中（通常为 <code>C:\Windows\Assembly</code>）；</li>
<li>GAC中存储了具有全局唯一性的程序集，这些程序集可以供多个应用程序或系统共享使用；</li>
<li>GAC通过保证程序集的版本控制和访问权限，确保多个应用程序可以共存并使用不同的程序集版本；</li>
</ul>
<h2 id="1-1-Load-方法"><a href="#1-1-Load-方法" class="headerlink" title="1.1 Load 方法"></a>1.1 Load 方法</h2><p>在 CLR 内部，CLR 将使用 <code>System. Reflection. Assembly</code> 类当中的静态方法 <code>Load</code> 来尝试加载目标程序集。</p>
<p><strong>Load 方法的重载</strong></p>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Assembly</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> statuc Assembly <span class="title">Load</span>(<span class="params">AssemblyName assemblyRef</span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> statuc Assembly <span class="title">Load</span>(<span class="params">String assemblyString</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>Load 方法效果</strong><br>使用 Load 将导致 CLR 向程序集应用一个版本绑定重定向的策略，并在 GAC 中查找程序集；</p>
<ul>
<li>如果没找到，就接着去应用程序的基目录、私有路径子目录和 codebase 位置查找目标程序集；<ul>
<li>如果 Load 找到指定的程序集，会返回对代表已加载的那个程序集的一个 Assembly 对象的引用；</li>
<li>如果 Load 没有找到指定程序集，会抛出一个 <code>System.IO.FileNotFoundException</code> 异常；</li>
</ul>
</li>
<li>如果调用 Load 时传递的是弱命名程序集，Load 就不会向程序集应用版本绑定重定向策略，CLR 也不会去 GAC 查找程序集;</li>
</ul>
<p><strong>AppDomain 的成员 Load 方法</strong><br>AppDomain 中的 Load 方法是实例方法，其用于将程序集加载到指定的 AppDomain 当中；</p>
<ul>
<li>AppDomain 的 Load 方法将会返回对程序集的引用，所以程序集对象必须按值封送回发出调用的哪个 AppDomain ；</li>
</ul>
<h2 id="1-2-LoadFrom-方法"><a href="#1-2-LoadFrom-方法" class="headerlink" title="1.2 LoadFrom 方法"></a>1.2 LoadFrom 方法</h2><p>在 CSharp 中，<code>Assembly.Load</code> 和 <code>Assembly.LoadFrom</code> 都是用于加载程序集的方法；</p>
<p><strong>Load 与 LoadFrom 区别</strong></p>
<ol>
<li><strong>使用方式：</strong><ul>
<li><code>Assembly.Load</code> 方法：接受一个程序集的完整名称或部分名称作为参数，可以从已加载的程序集列表、全局程序集缓存（GAC）或当前应用程序的基本目录加载程序集。</li>
<li><code>Assembly.LoadFrom</code> 方法：接受一个文件的完整路径或相对路径作为参数，用于加载指定路径下的程序集。</li>
</ul>
</li>
<li><strong>加载行为：</strong><ul>
<li><code>Assembly.Load</code> 方法：尝试从已加载的程序集列表、全局程序集缓存（GAC）或当前应用程序的基本目录中查找并加载指定的程序集。它使用程序集的完整名称或部分名称进行查找。</li>
<li><code>Assembly.LoadFrom</code> 方法：加载指定路径下的程序集，并且会解析该程序集的依赖项，包括从相同路径加载依赖的程序集。</li>
</ul>
</li>
<li><strong>相对路径：</strong><ul>
<li><code>Assembly.Load</code> 方法：不直接支持相对路径，需要使用基本目录进行相对路径的解析。</li>
<li><code>Assembly.LoadFrom</code> 方法：支持使用相对路径来加载程序集，相对路径是相对于当前工作目录或指定的基本路径。<br>由以上区别可知，<code>Assembly.LoadFrom</code> 方法可以被看作是 <code>Assembly.Load</code> 方法的一种扩展，它提供了更灵活的加载方式，可以加载指定路径下的程序集，而不仅限于从已加载的程序集列表或全局程序集缓存中查找。</li>
</ul>
</li>
</ol>
<p><strong>LoadFrom 方法定义</strong></p>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Assembly</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Assembly <span class="title">LoadFrom</span>(<span class="params">String path</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>LoadFrom 执行过程</strong><br>LoadFrom 首先调用 <code>System.Reflection.AssemblyName</code> 类的静态 <code>GetAssemblyName</code> 方法；</p>
<ul>
<li><ol>
<li>该方法打开指定的文件，找到 AssemblyRef 元数据表的记录项，提取程序集标识信息；</li>
</ol>
</li>
<li><ol start="2">
<li>以一个 <code>System. Reflection. AssemblyName</code> 对象的形式返回这些信息 ；</li>
</ol>
</li>
<li><ol start="3">
<li>LoadFrom 方法在内部调用 Assembly 的 Load 方法，将 AssemblyName 对象传给它；</li>
</ol>
</li>
<li><ol start="4">
<li>CLR 应用版本绑定重定向策略，并在各个位置查找匹配的程序集；</li>
</ol>
</li>
<li><ol start="5">
<li>Load 找到匹配程序集，加载它，并返回代表已加载程序集的 Assembly 对象； LoadFrom 方法将返回这个值。</li>
</ol>
</li>
<li><ol start="6">
<li>如果 Load 没有找到匹配的程序集，LoadFrom 会加载通过 LoadFrom 的实参传递的路径中的程序集。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>CLR</tag>
        <tag>AppDomain</tag>
        <tag>程序集</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】托管堆与垃圾回收（3）-- 特殊资源对象</title>
    <url>/2023/08/5f4541f148f0.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<ul>
<li><ol>
<li>特殊资源对象</li>
</ol>
</li>
<li><ol start="2">
<li>Finalize特点</li>
</ol>
</li>
<li><ol start="3">
<li>SafeHandle类</li>
</ol>
<ul>
<li>3.1 SafeHandle类基本概念</li>
<li>3.2 SafeHandle特点<span id="more"></span></li>
</ul>
</li>
</ul>
<h1 id="1-特殊资源对象"><a href="#1-特殊资源对象" class="headerlink" title="1 特殊资源对象"></a>1 特殊资源对象</h1><p><strong>什么是特殊资源对象</strong><br>对于C#中的大部分对象而言，只要有内存的分配既可以正常工作。但是还有一部分对象其使用了其他特殊的资源，比如IO设备、线程、锁、Socket等等。<br><em>例如，System.IO.FileStream类型需要打开一个文件(本机资源)并保存文件的指针。然后类型的Read和Write方法用此指针操作文件。类似地，System.Threading.Mutex类型要打开一个Windows互斥体内核对象(本机资源)并保存其对象的指针，并在调用Mutex的方法时使用该对象。</em></p>
<p><strong>如何处理特殊资源对象：Finalize终结</strong><br>对于这些特殊资源对象，不可以直接对象内存进行回收，而是应该在回收之前先对其进行一些处理，保证其在回收之前执行一些代码。</p>
<ul>
<li>Finalize终结机制：<ul>
<li>CLR提供了称为终结的机制，允许对象在被判定为垃圾之后，但在对象内存被回收之前执行一些代码。</li>
<li>任何包装了本机资源(文件、网络连接、套接字、互斥体)的类型都支持终结。CLR 判定一个对象不可达时，对象将终结它自己，释放它包装的本机资源。</li>
</ul>
</li>
</ul>
<p><strong>Finalize方法</strong><br>在System.Object中定义了受保护的虚方法：Finalize<br>垃圾回收器判定对象是垃圾后，会调用对象的Finalize方法。C#要求在类名前面加上“～”符号来定义Finalize方法：</p>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SomeType</span></span><br><span class="line">&#123;</span><br><span class="line">	~SomeType()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//这里的代码会进入Finalize方法	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="2-Finalize-特点"><a href="#2-Finalize-特点" class="headerlink" title="2 Finalize 特点"></a>2 Finalize 特点</h1><p><strong>特点一：执行终结导致对象存活变长</strong></p>
<ul>
<li>被视为垃圾的对象在垃圾回收完毕之后才会调用 Finalize 方法，所以这些对象的内存不是马上被回收的；</li>
<li>可终结对象在回收时必须存活，造成它会提升一代，使对象活得比正常时间长，增大了内存耗用；更糟的是，可终结对象被提升时，其字段引用的所有对象也会被提升，因为它们也必须继续存活。</li>
<li>建议<ul>
<li>要尽量避免为引用类型的字段定义可终结对象；</li>
<li>尽量不要直接使用 Finalize 方法；</li>
</ul>
</li>
</ul>
<p><strong>特点二：无法控制Finalize执行的时间</strong></p>
<ul>
<li>CLR不保证多个Finalize方法的调用顺序。所以在Finalize方法中，<strong>不要访问定义了Finalize方法的其他类型的对象</strong>：那些对象可能已经终结了；</li>
<li>但可以安全地访问值类型的实例，或者访问没有定义 Finalize 方法的引用类型的对象；</li>
</ul>
<p><strong>特点三：CLR使用一个特殊、高优先级的线程调用Finalize方法</strong></p>
<ul>
<li>为了避免死锁，CLR使用专用线程来负责此方法的执行；</li>
<li>但也同时，如果一个Finalize方法阻塞，该线程也就无法再调用任何更多的Finalize方法；</li>
</ul>
<p><strong>结论：Finalize只是用于释放本机资源而设计的</strong></p>
<ul>
<li>建议：不要重写Obiect的Finalize方法；</li>
<li>正确做法是：使用Microsoft在FCL中提供的辅助类；<ul>
<li>这些辅助类重写了Finalize方法；</li>
<li>添加了一些特殊的CLR代码，可以从这些辅助类派生出自己的类；</li>
</ul>
</li>
</ul>
<h1 id="3-SafeHandle-类"><a href="#3-SafeHandle-类" class="headerlink" title="3 SafeHandle 类"></a>3 SafeHandle 类</h1><h2 id="3-1-SafeHandle类基本概念"><a href="#3-1-SafeHandle类基本概念" class="headerlink" title="3.1 SafeHandle类基本概念"></a>3.1 SafeHandle类基本概念</h2><p><strong>SafeHandle类的定义</strong><br>SafeHandle类是一个抽象基类，位于System.Runtime.InteropServices命名空间中；<br>它用于提供一个安全的封装器，用于管理本机资源的句柄（例如文件句柄、内核对象句柄等）；<br>SafeHandle类通过派生具体的子类，提供了一种可靠的方式来管理和释放这些句柄。</p>
<p><strong>SafeHandle类解决的问题</strong><br>SafeHandle类解决了在C#中使用本机资源句柄时的一些常见问题，例如：</p>
<ul>
<li>1.内存泄漏：在编写使用本机资源的代码时，如果不正确地释放句柄，可能会导致内存泄漏；</li>
<li>2.不确定的错误：使用不正确的句柄或重复释放句柄可能会导致不确定的行为和错误；</li>
<li>3.线程安全：在多线程环境下，对句柄的访问必须进行适当的同步，以确保不会导致竞态条件或其他线程相关的问题；<br>SafeHandle类通过提供一个可继承的模板，规范了如何正确使用和自动释放本机资源句柄，从而解决了上述问题。</li>
</ul>
<p><strong>SafeHandle和Finalize方法的关系</strong></p>
<ul>
<li>核心：SafeHandle类通过覆盖Finalize方法来增强对句柄的管理和释放；</li>
<li>内容：<ul>
<li>Finalize方法是C#中的垃圾回收器提供的一个特殊方法，用于在对象被垃圾回收之前执行清理操作。</li>
<li>SafeHandle类中的子类通常会重写Dispose方法和Finalize方法。Dispose方法用于显式地释放句柄和其他资源，而Finalize方法则是在垃圾回收器执行回收操作之前被自动调用。</li>
</ul>
</li>
</ul>
<h2 id="3-2-SafeHandle特点"><a href="#3-2-SafeHandle特点" class="headerlink" title="3.2 SafeHandle特点"></a>3.2 SafeHandle特点</h2><h3 id="3-2-1-派生自CriticalFinalizerObject类"><a href="#3-2-1-派生自CriticalFinalizerObject类" class="headerlink" title="3.2.1 派生自CriticalFinalizerObject类"></a>3.2.1 派生自CriticalFinalizerObject类</h3><p><strong>核心概念：SafeHandle继承自CriticalFinalizerObject类</strong></p>
<p><strong>功能一：首次构造时执行JIT编译</strong></p>
<ul>
<li>内容<ul>
<li>首次构造任何CriticalFinalizerObject的派生类型对象时，CLR立即对<strong>继承层次结构中的所有 Finalize 方法进行JIT编译</strong>；</li>
</ul>
</li>
<li>目的<ul>
<li>构造对象时就编译这些方法，可确保当对象被确定为垃圾之后，本机资源肯定会得以释放；</li>
<li>不对 Finalize 方法进行提前编译，那么也许能分配并使用本机资源，但无法保证释放；</li>
<li>因为<strong>内存紧张时，CLR可能找不到足够的内存来编译Finalize方法</strong>，这会阻止Finalize方法的执行，造成本机资源泄漏；</li>
<li>因为提前进行JIT编译，可以解决这个问题；</li>
</ul>
</li>
</ul>
<p><strong>功能二：</strong></p>
<ul>
<li>调用Finalize顺序<ul>
<li>CLR是在调用了非 CriticalFinalizerObject 派生类型的 Finalize 方法之后，才调用CriticalFinalizerObject派生类型的Finalize方法；</li>
<li>托管资源类因此可以在它们的Finalize方法中成功地访问CriticalFinalizerObject派生类型的对象；</li>
<li><em>例如FileStream类的Finalize方法可以放心地将数据从内存缓冲区 fush到磁盘，它知道此时磁盘文件还没有关闭；</em></li>
</ul>
</li>
</ul>
<h3 id="3-2-2-SafeHandle是抽象类"><a href="#3-2-2-SafeHandle是抽象类" class="headerlink" title="3.2.2 SafeHandle是抽象类"></a>3.2.2 SafeHandle是抽象类</h3><p>为了能够使用此类，必须有另一个类从该类派生，并重写以下内容：</p>
<ol>
<li>受保护的构造函数</li>
<li>抽象方法ReleaseHandle</li>
<li>抽象属性IsInvalid的get访问器</li>
</ol>
<p><strong>辅助类：SafeHandleZero0rMinusOnelsInvalid类</strong><br>此类继承自SafeHandle，也是一个抽象类，用于辅助进行类的派生；</p>
<ul>
<li>抽象类：<ul>
<li>必须有另一个类从该类派生，并重写它的受保护构造器和抽象方法ReleaseHandle；</li>
<li>NETFramework 提供了几个从SafeHandleZero0rMinusOneIsInvalid 派生的公共类，包括：<ul>
<li>SafeFileHandle</li>
<li>SafeRegistryHandle</li>
<li>SafeWaitHandle</li>
<li>SafeMemoryMappedViewHandle</li>
</ul>
</li>
</ul>
</li>
<li>其他继承自SafeHandleZero0rMinusOnelsInvalid的类<ul>
<li>SafeProcessHandle</li>
<li>SafeThreadHandle</li>
<li>SafeTokenHandleSafeLibraryHandle</li>
<li>SafeLocalAllocHandle</li>
</ul>
</li>
</ul>
<h3 id="3-2-3-SafeHandle作用"><a href="#3-2-3-SafeHandle作用" class="headerlink" title="3.2.3 SafeHandle作用"></a>3.2.3 SafeHandle作用</h3><ol>
<li>修正了潜在的资源泄露问题：SafeHandle收到CLR的特殊对待；</li>
<li>防止有人利用潜在的安全漏洞</li>
</ol>
<h2 id="3-3-SafeHandle使用"><a href="#3-3-SafeHandle使用" class="headerlink" title="3.3 SafeHandle使用"></a>3.3 SafeHandle使用</h2><p><strong>如何使用包装了本机资源的类型：以FileStream类为例</strong></p>
<ul>
<li>FileStream介绍<ul>
<li>System.Io.FileStream 可用于打开一个文件，从文件中读取字节，向文件写入字节，然后关闭文件；</li>
<li>FileStream类还提供子几个额外的属性：Length、Position、CanRead和方法Read、Write、Flush；</li>
</ul>
</li>
<li>问题<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230901152011.png"
                     
                ></li>
<li>问题描述：<ul>
<li>File的静态 Delete 方法可能会要求 Windows 删除一个仍然打开的文件，此时 Delete 方法会抛出System.IO.IOException 的异常；</li>
</ul>
</li>
<li>文件可能“误打误撞”地被删除<ul>
<li>如果另一线程不知怎么造成了一次垃圾回收，而且这次垃圾回收刚好在调用 Write 之后、调用Delete之前发生，那么FileStream的SafeFileHandle字段的 Finalize 方法就会被调用，这会关闭文件，随后 Delete操作也就可以正常运行；</li>
</ul>
</li>
</ul>
</li>
<li>解决方法<ul>
<li>可以使用Dispose方法来完成资源显示的释放；</li>
<li>在File.Delete()之前，先调用<code>fs.Dispose()</code>方法；</li>
</ul>
</li>
</ul>
<h3 id="3-3-1-Dispose方法与对象生存期控制"><a href="#3-3-1-Dispose方法与对象生存期控制" class="headerlink" title="3.3.1 Dispose方法与对象生存期控制"></a>3.3.1 Dispose方法与对象生存期控制</h3><p>当想要控制类所包裹的本机资源的生存期时，就必须实现IDispose接口：</p>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Dispose</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>什么是Dispose方法</strong></p>
<ul>
<li>Dispose方法描述<ul>
<li>在C#编程语言和CLR（公共语言运行时）中，Dispose方法是一种用于释放资源的标准机制。它主要用于管理和释放那些需要手动处理的非托管资源，例如文件、数据库连接、网络连接和操作系统句柄等。Dispose方法允许在使用完资源后立即释放它们，以避免资源的长时间占用和浪费。</li>
</ul>
</li>
<li>Dispose方法的作用<ul>
<li>Dispose方法的主要作用是在使用完资源后进行释放和清理。它可以用来执行以下任务：</li>
<li><ol>
<li>关闭文件、释放文件句柄，并确保文件被正确关闭。</li>
</ol>
</li>
<li><ol start="2">
<li>断开数据库连接，释放数据库资源，并确保连接被关闭。</li>
</ol>
</li>
<li><ol start="3">
<li>关闭网络连接，释放网络资源，并确保连接被断开。</li>
</ol>
</li>
<li><ol start="4">
<li>释放其他非托管资源，如图形设备接口（GDI）对象、操作系统句柄等。</li>
</ol>
</li>
<li>通过实现Dispose方法，我们可以明确地告知程序何时应该释放资源，而不仅仅依赖于垃圾回收机制。</li>
</ul>
</li>
</ul>
<p><strong>Dispose方法和SafeHandle的关系</strong><br>Dispose方法通常与SafeHandle类一起使用，以确保资源的正确释放；</p>
<ul>
<li>SafeHandle类为Dispose方法提供了一个机制：使得在对象的生命周期结束时，自动调用Dispose方法，即使存在异常或错误也能正确处理资源的释放。</li>
<li>通过结合使用Dispose方法和SafeHandle类，我们可以更可靠和安全地管理非托管资源，提高代码的健壮性和可维护性。</li>
</ul>
<p><strong>什么时候使用Dispose</strong><br>需要注意的是：并不是一定要调用Dispose才能保证本机资源得到清理。本机资源的清理最终总会发生，<strong>调用Dispose只是控制这个发生的时机</strong>；</p>
<ul>
<li>调用Dispose不会将托管对象从托管堆删除。只有在垃圾回收之后，托管堆中的内存才会得以回收；</li>
<li>这意味着：即使 Dispose 了托管对象过去用过的任何本机资源，也能在托管对象上调用方法；<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230901153633.png"
                     
                ></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
        <tag>CSharp</tag>
        <tag>垃圾回收</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】程序集加载与反射（2） -- 反射基础</title>
    <url>/2023/09/2370aa06518f.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h1 id="1-反射基础概念"><a href="#1-反射基础概念" class="headerlink" title="1 反射基础概念"></a>1 反射基础概念</h1><h2 id="1-1-反射与元数据"><a href="#1-1-反射与元数据" class="headerlink" title="1.1 反射与元数据"></a>1.1 反射与元数据</h2><p><strong>元数据与程序集</strong><br>当生成程序集或者一个模块时，编译器会创建一个：</p>
<ul>
<li><ol>
<li>类型的定义表</li>
</ol>
</li>
<li><ol start="2">
<li>字段定义表</li>
</ol>
</li>
<li><ol start="3">
<li>方法定义表</li>
</ol>
</li>
<li>其他<br>所以，元数据本质就是一堆表的存储；</li>
</ul>
<p><strong>反射的使用范围</strong><br>反射使用 <code>System.Reflection</code> 命名空间中的类型来达成，使用当中定义的类型来反射元数据表；</p>
<ul>
<li>反射可做范围<ul>
<li>查找并获得程序集中定义的类型；</li>
<li>类型的字段、方法、属性、事件；</li>
<li>类型的基类型；</li>
<li>等等…</li>
</ul>
</li>
</ul>
<h2 id="1-2-反射使用场合"><a href="#1-2-反射使用场合" class="headerlink" title="1.2 反射使用场合"></a>1.2 反射使用场合</h2><p><strong>事实上，只有很少数的应用程序才需要使用反射类型</strong>；</p>
<ul>
<li>反射使用场合：如果类库需要<strong>理解类型的定义</strong>才能提供丰富的功能，就适合使用反射；<ul>
<li>例子：VS 的 UI 设计器，鼠标显示 UI 控件的属性；</li>
<li>例子：Unity 的监视试图，展示类型的数据；</li>
</ul>
</li>
<li>可以利用反射来决定要向开发者显示的属性；</li>
<li>在运行时，当应用程序需要从特定程序集中加载特定类型以执行特定任务时，也要使用反射；</li>
</ul>
<h1 id="2-反射的性能"><a href="#2-反射的性能" class="headerlink" title="2 反射的性能"></a>2 反射的性能</h1><h2 id="2-1-反射的两个缺点"><a href="#2-1-反射的两个缺点" class="headerlink" title="2.1 反射的两个缺点"></a>2.1 反射的两个缺点</h2><p><strong>缺点一：反射造成编译时无法保证类型安全性</strong><br>反射造成编译时无法保证类型安全性。由于反射严重依赖字符串，所以会丧失编译时的类型安全性；</p>
<ul>
<li>例如，执行 <code>Type.GetType (&quot;int&quot;);</code> 要求通过反射在程序集中查找名为 <code>int</code> 的类型，代码会通过编译，但在运行时会返回 null；</li>
<li>因为 CLR 只知 <code>System.Int32</code> 不知 <code>int</code> 类型；</li>
</ul>
<p><strong>缺点二：反射的性能差</strong><br>使用反射时，类型及其成员的名称在编译时未知，要用字符串名称标识每个类型及其成员，然后在运行时发现它们；</p>
<ul>
<li>使用 <code>System.Reflection</code> 命名空间中的类型，扫描程序集的元数据时，反射机制会不停地执行字符串搜索；</li>
<li>通常字符串搜索执行的是不区分大小写的比较，这会进一步影响速度；<br>使用反射调用成员时也会影响性能；<br>反射调用方法时需要将实参打包成数组，在内部，反射将这些实参解包到线程栈上；</li>
<li>并且实参在方法调用前还需要检查其是否有正确的数据类型；</li>
<li>还需要检查调用者的权限是否符合；</li>
</ul>
<p><strong>可避免使用反射的两种方法</strong></p>
<ul>
<li>方法一：让类型从编译时已知的基类型派生；<ul>
<li>在运行时构造派生类型的实例，将对它的引用放到基类型的变量中（利用转型），再调用基类型定义的虚方法；</li>
</ul>
</li>
<li>方法二：让类型实现编译时已知的接口;<ul>
<li>在运行时构造类型的实例，将对它的引用放到接口类型的变量中 (利用转型)，再调用接口定义的方法；</li>
</ul>
</li>
</ul>
<h1 id="3-反射与程序集中的类型"><a href="#3-反射与程序集中的类型" class="headerlink" title="3 反射与程序集中的类型"></a>3 反射与程序集中的类型</h1><h2 id="3-1-发现程序集中定义的类型"><a href="#3-1-发现程序集中定义的类型" class="headerlink" title="3.1 发现程序集中定义的类型"></a>3.1 发现程序集中定义的类型</h2><p>反射经常用于判断程序集定义了哪些类型；<br><strong>Assembly 中的 ExportedTypes 属性</strong><br>可以使用 Assembly 中的 ExportedTypes 属性来导出程序集中的类型；</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Assembly a = Assembly.Load(assemID);</span><br><span class="line"><span class="keyword">foreach</span>(Type t <span class="keyword">in</span> a.ExportedTypes)</span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(t.FullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>使用此属性，可以导出其程序集中所有的公开定义类型；</p>
<h2 id="3-2-类型对象的准确含义"><a href="#3-2-类型对象的准确含义" class="headerlink" title="3.2 类型对象的准确含义"></a>3.2 类型对象的准确含义</h2><h3 id="3-2-1-System-Type-类型"><a href="#3-2-1-System-Type-类型" class="headerlink" title="3.2.1 System.Type 类型"></a>3.2.1 System.Type 类型</h3><p><strong>System.Type 类型</strong><br><code>System.Type </code> 是执行类型和对象操作的起点，代表了一个类型的引用，而不是类型的定义；<br><code>System.Type</code> 类型是 C# 中的一个重要的内置类，它提供了有关对象类型的元数据和信息；<br><code>Type</code> 类型用于表示在运行时获取和操作类型相关信息的能力，它可以描述和操作类、接口、事件、属性、委托等各种类型的信息；</p>
<p><strong>System.Type 定义和描述</strong><br><code>System.Type</code> 类型定义了以下重要成员：</p>
<ul>
<li><code>Type</code> 类型有一个静态的 <code>GetType</code> 方法，可以通过传递一个对象实例来获取其对应的 <code>Type</code> 对象。</li>
<li><code>Type</code> 类型提供了许多用于获取类型信息的实例方法和属性，例如 <code>GetMethods</code>、<code>GetProperties</code>、<code>GetFields</code> 等，用于获取类型的方法、属性和字段等成员信息。</li>
<li><code>Type</code> 类型还提供了许多其他有用的方法，如 <code>IsArray</code>、<code>IsClass</code>、<code>IsEnum</code> 等，用于检查类型的特定特征。</li>
<li><code>Type</code> 类型还提供了获取基类、实现的接口、属性和字段的信息的方法。</li>
</ul>
<p><strong>System.Type 与反射的关系</strong></p>
<p><code>System.Type</code> 类型与反射密切相关；</p>
<ul>
<li>反射是提供了在运行时动态地获取、检测和操作类型和成员的能力；</li>
<li><code>Type</code> 类型提供了用于执行反射操作的重要方法和属性，通过 <code>Type</code> 对象，可以获取并操作类型的成员、调用方法、访问字段和属性等；</li>
</ul>
<h3 id="3-2-2-获得类型的-Type-对象"><a href="#3-2-2-获得类型的-Type-对象" class="headerlink" title="3.2.2 获得类型的 Type 对象"></a>3.2.2 获得类型的 Type 对象</h3><p><strong>类型相等性判断</strong><br>因为在 <code>System.Object</code> 当中定义了 <code>GetType</code> 方法，所以在调用此方法的时候 CLR 可以判断对象的类型，并返回此类型的 Type 引用；</p>
<ul>
<li>可以使用 <code>GetType </code> 进行类型的精确相等判断；<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Object o1;</span><br><span class="line">Object o2;</span><br><span class="line"><span class="built_in">bool</span> result = (o1.GetType() == o2.GetType()); </span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>获得 Type 对象的几种方式</strong></p>
<ul>
<li>方法一：System. Object 类型提供的 GetType 方法；<ul>
<li>System. Type 类型提供了静态 GetType 方法的几个重载版本，所有版本都接受一个 String 参数字符串；</li>
<li>必须指定类型的全名，包括它的命名空间；</li>
<li>如果传递的只是一个类型名称，方法将检查调用程序集，看它是否定义了指定名称的类型。如果是，就返回对恰当 Type 对象的引用；</li>
</ul>
</li>
<li>方法二：System. Type 类型提供了静态 ReflectionOnlyGetType 方法；<ul>
<li>该方法与上一条提到的 GetType 方法在行为上相似，只是<strong>类型会以“仅反射”的方式加载，不能执行</strong>；</li>
</ul>
</li>
<li>方法三：System. Typelnfo 类型提供了实例成员 DeclaredNestedTypes 和 GetDeclaredNested；</li>
</ul>
<p><strong>typeof操作符</strong><br>通过使用 <code>typeof</code> 操作符，可以根据编译时已知的类型名称来快速的获得 Type 对象；<br>使用 typeof 的代码示例：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"><span class="built_in">object</span> o</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(o.GetType == <span class="keyword">typeof</span>(FileInfo) &#123; <span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>以上就是利用其来进行判断；</p>
<h3 id="3-2-3-TypeInfo-类型对象"><a href="#3-2-3-TypeInfo-类型对象" class="headerlink" title="3.2.3 TypeInfo 类型对象"></a>3.2.3 TypeInfo 类型对象</h3><p><strong>TypeInfo 类介绍</strong><br><code>TypeInfo</code> 类型是 <code>System.Reflection</code> 命名空间下的一个类，用于表示类型的元数据信息。 <code>TypeInfo</code> 是 <code>Type</code> 类型的扩展，提供了更多关于类型的详细信息的操作和访问。</p>
<ul>
<li><code>TypeInfo</code> 类型相对于 <code>Type</code> 类型提供了更多的类型信息；</li>
<li>相比于 Type 代表的是类型引用，TypeInfo 代表的是类型定义；</li>
</ul>
<p><strong>获得 TypeInfo 对象</strong></p>
<ul>
<li>可调用 System. Reflection. IntrospectionExtensions 的 GetTypeInfo 扩展方法将 Type 对象转换成 TypeInfo 对象的引用； </li>
<li>但还可调用 TypeInfo 的 AsType 方法将 Typelnfo 对象转换为 Type 对象；</li>
<li>获得 TypeInfo 对象的成本高<ul>
<li>获取 TypeInfo 对象会强迫 CLR 确保已加载类型的定义程序集，从而对类型进行解析。这个操作可能代价高昂；</li>
<li>如果只需要类型引用 (Type 对象)，就应避免这个操作；</li>
<li>但一旦获得了 TypeInfo 对象，就可查询类型的许多属性进一步了解它；<ul>
<li>大多数属性，比如 IsPublic，IsSealed，IsAbstract，IsClass 和 IsValueType 等，都指明了与类型关联的标志；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-3-构造类型的实例"><a href="#3-3-构造类型的实例" class="headerlink" title="3.3 构造类型的实例"></a>3.3 构造类型的实例</h2><p><strong>方法一：System. Activator 的 CreateInstance 方法</strong><br>Activator 类提供了静态 CreateInstance 方法的几个重载版本；</p>
<ul>
<li>传入参数<ul>
<li>调用方法时既可传递个 Type 对象引用，也可传递标识了类型的 String；</li>
</ul>
</li>
<li>方法效果<ul>
<li>直接获取类型对象的几个版本较为简单：为类型的构造器传递一组实参，方法返回对新对象的引用；</li>
<li>用字符串来指定类型的几个版本则稍微复杂一些：<ul>
<li>首先必须指定另一个字符串来标识定义了类型的程序集；</li>
<li>其次如果正确配置了远程访问 (remoting)选项，这些方法还允许构造远程对象；</li>
<li>第三，这些版本返回的不是对新对象的引用，而是一个 System. Runtime. Remoting. ObjectHandle 对象<ul>
<li>从 System, MarshalByRefObject 派生</li>
<li>ObjectHandle 类型允许将一个 AppDomain  中创建的对象传至其他 AppDomain，期间不强迫对象具体化 (materialize)；</li>
</ul>
</li>
<li>准备好具体化这个对象时，调用 ObjectHandle 的 Unwrap 方法。<ul>
<li>在一个 AppDomain 中调用该方法时，它将定义了要具体化的类型的程序集加载到这个 AppDomain 中。</li>
<li>如果对象按引用封送，会创建代理类型和对象。如果对象按值封送，对象的副本会被反序列化。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>方法二：System. Activator 的 CreatelnstanceFrom 方法</strong><br>Activator 类还提供了一组静态 CreateInstanceFrom 方法的几个重载版本； </p>
<ul>
<li>此方法与 CreateInstance 的行为相似，只是必须通过字符串参数来指定类型及其程序集；</li>
<li>程序集用 Assembly 的 LoadFrom 方法加载到调用 AppDomain 中；<ul>
<li>由于都不接受 Type 参数，所以返回的都是一个 ObjectHandle 对象引用，必须调用 ObjectHandle 的 Unwrap 方法进行具体化。</li>
</ul>
</li>
</ul>
<p><strong>方法三：System. AppDomain 方法</strong><br>AppDomain 类型提供了 4 个用于构造类型实例的实例方法；</p>
<ul>
<li>Createlnstance；</li>
<li>CreatelnstanceAndUnwrap；</li>
<li>CreatelnstanceFrom；</li>
<li>CreateInstanceFromAndUnwrap；<br>这些方法的行为和 Activator 类的方法相似，区别在于它们都是实例方法，允许指定在哪个 AppDomain 中构造对象。</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>CLR</tag>
        <tag>程序集</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】程序集加载与反射（3） -- 反射加载类型成员</title>
    <url>/2023/09/c03dd0ca507b.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h2 id="1-设计支持加载项的应用程序"><a href="#1-设计支持加载项的应用程序" class="headerlink" title="1 设计支持加载项的应用程序"></a>1 设计支持加载项的应用程序</h2><p>当需要设计一个可以支持不同的加载项的应用程序时，需要知道以下三部分的关系：</p>
<ul>
<li>宿主 SDK 程序集；</li>
<li>加载项程序集；</li>
<li>宿主应用程序程序集<br>它们三者之间关系：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230914125545.png"
                     
                ><br><strong>宿主 SDK 程序集</strong><br>宿主 SDK(Host SDK)程序集它定义了一个接口，接口的方法作为宿主应用程序与加载项之间的通信机制使用；</li>
<li>为接口方法定义参数和返回类型时，请尝试使用 MSCorLibdll 中定义的其他接口或类型；</li>
<li>要传递并返回自己的数据类型，也在“宿主 SDK”程序集中定义。一旦搞定接口定义，就可为这个程序集赋予强名称，然后把它打包并部署到合作伙伴和用户那里；</li>
<li>发布后要避免对该程序集中的类型做出任何重大的改变；<ul>
<li>例如，不要以任何方式更改接口；</li>
<li>但如果定义了任何数据类型，在类型中添加新成员是完全允许的；</li>
<li>对程序集进行任何修改之后，可能需要使用一个发布者策略文件来部署它；</li>
</ul>
</li>
</ul>
<p><strong>加载项程序集</strong><br>加载项程序集当中也会有自己定义的类型，这些程序集将会引用宿主应用程序集中的类型；</p>
<ul>
<li>加载项开发人员可以按照自己的需求逐步推出程序集新版本，宿主应用程序可以正常使用加载项当中的类型；</li>
</ul>
<p><strong>宿主应用程序程序集</strong><br>在宿主应用程序程序集中，包含应用程序的类型；</p>
<ul>
<li>这个程序集要引用宿主 SDK 程序集，并使用其中定义的类型；</li>
<li>可自由修改“宿主应用程序”程序集的代码。由于加载项开发人员不会引用这个“宿主应用程序”程序集，所以随时都能推出“宿主应用程序”程序集的新版本，这不会对加载项开发人员产生任何影响。</li>
</ul>
<h1 id="2-基于反射获得类型成员"><a href="#2-基于反射获得类型成员" class="headerlink" title="2 基于反射获得类型成员"></a>2 基于反射获得类型成员</h1><h2 id="2-1-发现类型的成员"><a href="#2-1-发现类型的成员" class="headerlink" title="2.1 发现类型的成员"></a>2.1 发现类型的成员</h2><p><strong>可反射类型成员</strong><br>所有以下内容都可以定义成类型的成员，进而被反射调用；</p>
<ul>
<li>字段</li>
<li>构造函数</li>
<li>方法</li>
<li>属性</li>
<li>事件</li>
<li>嵌套类型</li>
</ul>
<p><strong>获得类型成员的类：System. Reflection. MemberInfo</strong><br>在 FCL 当中的 MemberInfo 类，封装了所有类型成员都通用的一组属性，以下是具体的类继承图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230914172748.png"
                     
                ><br>由以上图片可知：</p>
<ul>
<li>TypeInfo</li>
<li>FieldInfo</li>
<li>……</li>
<li>等等这些具体用于访问类型成员的类，都是继承自 MemberInfo；</li>
</ul>
<p><strong>反射系统结构关系</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230914175225.png"
                     
                ><br>基于 AppDomain 可以加载所有程序集，在程序集中可以发现构造的模块；<br>基于模块或者程序集，可以发现它当中所定义的所有类型；在类型中可以发现它的字段、属性、方法、事件等等；</p>
<h3 id="2-1-1-MemberInfo-类介绍"><a href="#2-1-1-MemberInfo-类介绍" class="headerlink" title="2.1.1 MemberInfo 类介绍"></a>2.1.1 MemberInfo 类介绍</h3><p><strong>定义与介绍</strong><br><code>MemberInfo</code> 类是在 C# 中用于描述类成员（如字段、属性、方法等）的类。它是 .NET 反射（Reflection）机制中的一部分，用于提供关于类型成员的信息和元数据；<br><code>MemberInfo</code> 类是一个抽象基类，因此无法直接实例化。它定义了表示类成员的共同属性和方法，并提供了许多有用的功能来获取和操作类成员的信息。一些常见的 <code>MemberInfo</code> 子类包括 <code>FieldInfo</code>、<code>PropertyInfo</code>、<code>MethodInfo</code> 等，它们分别用于描述字段、属性和方法。</p>
<p><strong>MemberInfo 类与反射的关系</strong></p>
<ul>
<li>反射是一种能够在运行时动态地检查和操作程序集、类型和成员的能力。通过使用反射，可以以编程方式获取和操纵应用程序集中的类型、成员和其他元素，而无需在编译时了解其具体结构；</li>
<li><code>MemberInfo</code> 类作为反射中的一个重要组成部分，通过提供一组统一的方法和属性，使程序能够动态地获取和操作类型成员的信息。通过 <code>MemberInfo</code>，可以获取类成员的名称、数据类型、修饰符、特性等，从而实现动态操作和扩展。</li>
</ul>
<p><strong>MemberInfo 所有派生类型通用的属性和方法</strong><br>以下是 MemberInfo 的通用属性与方法：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230914173316.png"
                     
                ></p>
<ul>
<li>因为 TypeInfo 类从 MemberInfo 类继承，因此以上属性 TypeInfo 类当中也有；</li>
<li>但 TypeInfo 还提供了更具体地返回字段、方法、属性、事件等的 Type 的方法；</li>
</ul>
<h2 id="2-2-调用类型的成员"><a href="#2-2-调用类型的成员" class="headerlink" title="2.2 调用类型的成员"></a>2.2 调用类型的成员</h2><p>在发现了的类型的定义之后，就可以来调用它们；</p>
<ul>
<li>调用：<code>Invoke</code>；<ul>
<li>当涉及到调用的时候，需要首先确定需要调用的类型；</li>
<li>根据不同的类型，为其使用不同的方法；</li>
</ul>
</li>
</ul>
<p><strong>调用成员以及方法表</strong></p>
<ul>
<li>FieldInfo 类<ul>
<li>通过 <code>GetValue</code> 和 <code>SetValue</code> 方法来获得并设置字段；</li>
</ul>
</li>
<li>PropertyInfo 类<ul>
<li>PropertyInfo 类型代表与属性有关的元数据信息；</li>
<li>PropertyInfo 提供了 CanRead、CanWrite 和 PropertyType 只读属性，它们指出属性是否可读和可写，以及属性的数据类型是什么；</li>
<li>PropertyInfo 提供了只读 GetMethod 和 SetMethod 属性, 它们返回代表属性 get 和 set 访问器方法的 MethodInfo 对象；</li>
<li>PropertyInfo 的 GetValue 和 SetValue 方法只是为了提供方便，直接获得值。在内部，它们会自己调用合适的 MethodInfo 对象来获得值；</li>
</ul>
</li>
<li>EventInfo 类<ul>
<li>EventInfo 类型代表与事件有关的元数据信息；</li>
<li>EventInfo 类型提供了只读 EventHandlerType 属性，返回事件的基础委托的 Type；</li>
<li>EventInfo 类型还提供了只读 AddMethod 和 RemoveMethod 属性，返回为事件增删委托的方法的 MethodInfo 对象；</li>
<li>增删委托可调用这些 MethodInfo 对象，也可调用 EventInfo 类型提供的更好用的 AddEventHandler 和 RemoveEventHandler 方法；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230914180011.png"
                     
                ></li>
</ul>
</li>
</ul>
<h1 id="3-句柄"><a href="#3-句柄" class="headerlink" title="3 句柄"></a>3 句柄</h1><p><strong>基于 Type 与 MemberInfo 派生对象存储类型信息的问题</strong><br>当需要查找特定的对象并调用此对象时，许多应用程序都会绑定一组 Type 对象或者 MemberInfo 对象，将这些对象存储在集合当中；</p>
<ul>
<li>问题：存储 Type 对象或者 MemberInfo 对象所需要的内存消耗大；</li>
<li>解决办法：<ul>
<li>CLR 在内部使用更精简的方式存储这些信息：句柄</li>
</ul>
</li>
</ul>
<p><strong>什么是句柄</strong><br>如果需要保存&#x2F;缓存大量 Type 和 MemberInfo 派生对象，开发人员可以使用运行时句柄代替对象，以减小工作集所占据的内存；</p>
<ul>
<li>三种运行时句柄类型<ul>
<li>三种运行时句柄类型都在 System 命名空间中；</li>
<li><ol>
<li>RuntimeTypeHandle；</li>
</ol>
</li>
<li><ol start="2">
<li>RuntimeFieldHandle；</li>
</ol>
</li>
<li><ol start="3">
<li>RuntimeMethodHandle；</li>
</ol>
</li>
</ul>
</li>
<li>类型内容<ul>
<li>这三种句柄类型都是值类型，都只包含一个字段，也就是一个 IntPtr；</li>
<li>因此句柄的实例十分的精简、省内存；</li>
</ul>
</li>
<li>IntPtr 字段<ul>
<li>句柄就是一个 IntPtr 的字段，其引用了 AppDomain 的 Loader 堆中的一个类型、字段或方法；</li>
<li>需要以一种简单、高效的方式，将重量级的 Type 或 MemberInfo 对象和句柄实例进行互相转换；</li>
</ul>
</li>
</ul>
<p><strong>句柄与类型对象相互转换方法</strong></p>
<ul>
<li>大类型对象 -&gt; 句柄<ul>
<li>Type -&gt; RuntimeTypeHandle<ul>
<li>使用 Type 的静态方法 <code>GetTypeHandle</code>，参数传入 Type 对象；</li>
</ul>
</li>
<li>FieldInfo  -&gt; RuntimeFieldHandle <ul>
<li>查询 FieldInfo 的实例只读属性 <code>FieldHandle</code>；</li>
</ul>
</li>
<li>MethodInfo -&gt; RuntimeMethodHandle <ul>
<li>查询 MethodInfo 的实例只读属性<code>MethodHandle</code>；</li>
</ul>
</li>
</ul>
</li>
<li>句柄 -&gt; 大类型对象<ul>
<li>RuntimeTypeHandle -&gt; Type <ul>
<li>使用 Type 的静态方法 <code>GetTypeFromHandle</code>，参数传入 RuntimeTypeHandle 对象；</li>
</ul>
</li>
<li>RuntimeFieldHandle -&gt; FieldInfo <ul>
<li>使用 FieldInfo 的静态方法 <code>GetFieldFormHandle</code>；</li>
</ul>
</li>
<li>RuntimeMethodHandle -&gt; MethodInfo <ul>
<li>调用 MethodInfo 的静态方法 <code>GetMethodFromHandle</code>；</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>CLR</tag>
        <tag>AppDomain</tag>
        <tag>程序集</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】运行时序列化（1） -- 序列化入门</title>
    <url>/2023/09/858375cab65b.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h1 id="1-序列化基础概念"><a href="#1-序列化基础概念" class="headerlink" title="1 序列化基础概念"></a>1 序列化基础概念</h1><p><strong>序列化定义</strong></p>
<ul>
<li>序列化：序列化是将对象或对象图转换成字节流的过程；</li>
<li>反序列化：反序列化是将字节流转换回对象图的过程；</li>
</ul>
<p><strong>为什么使用序列化</strong></p>
<ul>
<li>应用一：应用程序的状态可轻松保存到磁盘文件或数据库中，并在应用程序下次运行时恢复；<ul>
<li>ASP .NET 就是利用序列化和反序列化来保存和还原会话状态的；</li>
</ul>
</li>
<li>应用二：一组对象可轻松复制到系统的剪贴板，再粘贴回同一个或另一个应用程序<ul>
<li>Windows 窗体和 WindowsPresentation Foundation (WPF)就利用了这个功能；</li>
</ul>
</li>
<li>应用三：一组对象在进行序列化后，可轻松的通过网络发送给另一台机器上；<ul>
<li>除了可以使用在网络上之外，还可以使用在跨 AppDomain 进行类型实例传输上；</li>
</ul>
</li>
<li>应用四：对那些已经序列化成字节流的对象，可以更方便的使用一些处理方式进行加密和压缩；</li>
</ul>
<p><strong>.NET 提供了出色的序列化和反序列化支持，供开发者直接使用</strong></p>
<h1 id="2-序列化使用入门"><a href="#2-序列化使用入门" class="headerlink" title="2 序列化使用入门"></a>2 序列化使用入门</h1><p><strong>序列化简单示例代码</strong></p>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MemoryStream <span class="title">SerializeToMemory</span>(<span class="params"><span class="built_in">object</span> TargetSerializedObject</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	MemoryStream stream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">	BinaryFormatter formatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">	formatter.Serialize(stream,TargetSerializedObject);</span><br><span class="line">	<span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="2-1-序列化基本使用"><a href="#2-1-序列化基本使用" class="headerlink" title="2.1 序列化基本使用"></a>2.1 序列化基本使用</h2><p><strong>序列化使用</strong></p>
<ul>
<li>第一步：创建存储流<ul>
<li><code>MemoryStream stream = new MemoryStream();</code></li>
</ul>
</li>
<li>第二步：创建格式化器<ul>
<li><code>BinaryFormatter formatter = new BinaryFormatter();</code></li>
</ul>
</li>
<li>第三步：调用 Serialize 方法<ul>
<li>当需要序列化对象时，只需要调用格式化器的 <code>Serialize</code> 方法，并向其传递两个参数；</li>
<li>参数一：对流对象的引用；<ul>
<li>表示了序列化后的对象，应该存放在哪里；</li>
<li>可以是所有从 <code>System.IO.Stream</code> 基础的任意类型的对象；</li>
<li>即 <code>MemoryStream</code>、<code>FileStream</code>、<code>NetWorkStream</code> 等；</li>
</ul>
</li>
<li>参数二：目标序列化对象的引用；<ul>
<li>这个对象可以是任何东西，包括字典、int、异常等；</li>
<li>传入的引用对象还可以引用其他对象，这些被引用的对象也会被序列化到流当中；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>序列化内部工作机制</strong></p>
<ul>
<li>以 <code>BinaryFormatter</code> 格式化参考器为例；</li>
<li>步骤一：获得类型元数据<ul>
<li>格式化器参考对每个对象的类型进行描述的元数据，从而了解如何序列化完整的对象图；</li>
</ul>
</li>
<li>步骤二：使用反射了解引用对象<ul>
<li>进行序列化的 Serialize 方法，<strong>利用反射来查看每个对象的类型中都有哪些实例字段</strong>；</li>
<li>在这些字段中，任何一个引用了其他对象，格式化器的 Serialize 方法就知道那些对象也要进行序列化； </li>
<li>格式化器确保对象图中的每个对象都只序列化一次，如果对象图中的两个对象相互引用，格式化器会检测到这一点，每个对象都只序列化一次；</li>
</ul>
</li>
</ul>
<h2 id="2-2-反序列化基本使用"><a href="#2-2-反序列化基本使用" class="headerlink" title="2.2 反序列化基本使用"></a>2.2 反序列化基本使用</h2><p><strong>反序列化使用</strong><br>DeserializeFromStream 方法将流反序列化为对象图；</p>
<ul>
<li>该方法比用于序列化对象图的方法还要简单；</li>
<li>在代码中构造了一个 BinaryFormatter，然后调用它的 Deserialize 方法；</li>
<li>这个方法获取流作为参数，返回对反序列化好的对象图中的根对象的一个引用。</li>
</ul>
<p><strong>反序列化原理</strong><br>格式化器的 Deserialize 方法检查流的内容：</p>
<ul>
<li>第一步：确保程序集在 AppDomain 中<ul>
<li>反序列化对象时，格式化器首先获取程序集标识信息；</li>
<li>通过调用 <code>System.Reflection.Assembly</code> 的 Load 方法确保程序集已加载到正在执行的 AppDomain 中；</li>
</ul>
</li>
<li>第二步：匹配程序集中类型<ul>
<li>程序集加载好之后，格式化器在程序集中查找与要反序列化的对象匹配的类型；</li>
<li>找不到匹配类型，就抛出异常，不再对更多的对象进行反序列化；</li>
<li>找到匹配的类型，就创建类型的实例，并用流中包含的值对其字段进行初始化；</li>
<li>如果类型中的字段与流中读取的字段名不完全匹配，就抛出 SerializationException 异常，不再对更多的对象进行反序列化；</li>
</ul>
</li>
<li>第三步：构造实例，初始化状态<ul>
<li>然后构造流中所有对象的实例；</li>
<li>初始化所有这些对象中的字段，使它们具有与当初序列化时相同的值；</li>
<li>要将 Deserialize 方法返回的对象引用转型为应用程序期待的类型；</li>
</ul>
</li>
</ul>
<h2 id="2-3-使用注意事项"><a href="#2-3-使用注意事项" class="headerlink" title="2.3 使用注意事项"></a>2.3 使用注意事项</h2><p><strong>第一点：保证序列化与发序列化使用相同的格式化器</strong><br>由开发者来保证，代码为序列化和反序列化使用相同的格式化器；</p>
<ul>
<li>例如，不要写代码用 SoapFormatter 序列化一个对象图, 再用 BinaryFormatter 反序列化； </li>
<li>Deserialize 如果解译不了流的内容，会抛出 <code>System.Runtime.Serialization.SerializationException</code> 异常；</li>
</ul>
<p><strong>第二点：可以将多个对象序列化到一个流中，但要注意序列化与反序列化的顺序</strong></p>
<div class="highlight-container" data-rel="Csharp"><figure class="iseeu highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]<span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]<span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">&#123; <span class="comment">// ... &#125;</span></span><br></pre></td></tr></table></figure></div>
<p>在此有多个对象：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Customer&gt; s_customers= <span class="keyword">new</span> List&lt;Customer&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Order&gt; s_pendingOrders= <span class="keyword">new</span> List&lt;Order&gt;();</span><br></pre></td></tr></table></figure></div>
<p>序列化和反序列化时，都要按照顺序进行序列化：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">BinaryFormatter formatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化</span></span><br><span class="line">formatter.Serialize(stream,s_customers);</span><br><span class="line">formatter.Serialize(stream,s_pendingOrders);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line">s_customers = (List&lt;Customer&gt;) formatter.Deserialize(stream);</span><br><span class="line">s_pendingOrders = (List&lt;Order&gt;) formatter.Deserialize(stream);</span><br></pre></td></tr></table></figure></div>

<p><strong>第三点：序列化对象时，类型的全名和类型定义程序集的全名会被写入流</strong><br>BinaryFormatter 默认输出程序集的完整标识，其中包括程序集的文件名、版本号、语言文化以及公钥信息；</p>
<ul>
<li>反序列化对象时，格式化器首先获取程序集标识信息，并通过调用 <code>System.Reflection.Assembly</code> 的 Load 方法确保程序集已加载到正在执行的 AppDomain 中；</li>
</ul>
<h1 id="3-使类型可实例化"><a href="#3-使类型可实例化" class="headerlink" title="3 使类型可实例化"></a>3 使类型可实例化</h1><p><strong>Serializable 定制属性</strong><br>类型的实例默认是不可以实例化的，需要人为的为类型加上 <code>[Serializable]</code> 属性，才可以进行实例化；<br>此定制属性位于 <code>System</code> 命名空间下的 <code>System.SerializableAttribute</code> 中；</p>
<ul>
<li>格式化器会确认每个对象的类型都是可序列化的；</li>
<li>任何对象不可序列化，格式化器的 <code>Serialize</code> 方法都会抛出 SerializationException 异常；</li>
</ul>
<p><strong>使用 MemoryStream 存储 Serializable 的结果</strong><br>在序列化对象的对象图时，可能会出现：当前要序列化的对象，其当中定义的引用类型成员，有的可以序列化，有的不可以；但在序列化方法执行前，并不会先对整个对象图进行判断，是否可以完成序列化；</p>
<ul>
<li>问题：可能会出现序列化到中途时，部分实例被序列化，然后部分实例无法实例化，产生报错；</li>
<li>解决方法：使用 <code>MemoryStream</code> 来存储；</li>
<li>原因：<ul>
<li>使用 <code>MemoryStream</code> 能得体地从这种情况中恢复原本数据；</li>
<li>可以使用 <code>MemoryStream </code> 先将对象序列化到一个内存流中。然后，如果所有对象都成功序列化，就可以将 MemoryStream 中的字节复制到你真正希望的目标流中；</li>
</ul>
</li>
</ul>
<p><strong>SerializableAttribute 使用范围</strong></p>
<ol>
<li>这个定制特性只能应用于引用类型 (class)、值类型 (struct)、枚举类型 (enum)和委托类型 (delegate)；</li>
<li>枚举和委托类型总是可序列化的，不必显式应用 SerializableAttribute 特性； </li>
<li>SerializableAttribute 特性不会被派生类型继承：<ol>
<li>父类可以序列化时，子类如果不设置 <code>[Serializable]</code> 时，子类依然不可以实例化；</li>
<li>父类不可以序列化时，子类无论如何都不可以实例化。如果基类型不允许它的实例序列化，它的字段就不能序列化，因为基对象实际是派生对象的一部分；</li>
</ol>
</li>
<li>一般建议将定义的大部分类型都设置成可序列化，除了那些要包含敏感或安全数据的类型实例；</li>
</ol>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>CLR</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】运行时序列化（2） -- 序列化定制与原理</title>
    <url>/2023/09/496acc666700.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h1 id="1-控制序列化-反序列化"><a href="#1-控制序列化-反序列化" class="headerlink" title="1 控制序列化&#x2F;反序列化"></a>1 控制序列化&#x2F;反序列化</h1><p><strong>控制序列化原因</strong><br>将 <code>SerializableAttribute</code> 定制特性应用于类型，所有实例字段都会被序列化。但类型可能定义了一些不应序列化的实例字段；</p>
<ul>
<li><ol>
<li>字段含有反序列化后变得无效的信息；</li>
</ol>
<ul>
<li>比如对象包含 Windows 内核对象的句柄，那么在反序列化到另一个进程或另一台机器之后，这里句柄的实例字段就会失去意义；</li>
</ul>
</li>
<li><ol start="2">
<li>字段含有很容易计算的信息；</li>
</ol>
<ul>
<li>有些字段的数据可以很轻松的计算出来，可以选出那些无须序列化的字段，减少需要传输的数据，增强应用程序的性能；</li>
</ul>
</li>
</ul>
<p><strong>System.NonSerializedAttribute 特性</strong><br>可以使用 <code>System.NonSerializedAttribute</code> 定制特性指出类型中不应序列化的字段；</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">NonSerialized</span>]</span><br><span class="line">	<span class="keyword">public</span> Double Height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上述代码当中的 Person 对象可以被数理化，但只会实例化当中的 age 成员；</p>
<ul>
<li>NonSerializedAttribute 特性问题：部分实例的状态，在反序列化后读取时（比如 Height）会失去其原本的数值，变为 0 或者 null；</li>
</ul>
<p><strong>标注序列化时执行方法的特性</strong></p>
<ul>
<li>方法名可以为任意名称，方法应声明为 <code>private</code>，方法应返回 <code>void</code>；</li>
<li><code>System.Runtime.Serialization.OnDeserializedAttribute</code><ul>
<li>此属性当中包含 <code>OnDeserialized</code> 方法；</li>
<li>每次反序列化类型的实例，格式化器都会检查类型中是否应用了该特性的 <code>OnDeserialized</code> 方法；<ul>
<li>如果是，就调用该方法。调用这个方法时，所有可序列化的字段的状态都被正确设置；</li>
<li>在该方法中，可能需要访问这些字段来执行一些额外的工作，从而确保对象的完全反序列化；</li>
</ul>
</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230919105629.png"
                     
                ></li>
</ul>
</li>
<li><code>System.Runtime.Serialization.OnSerializingAttribute</code><ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230919105615.png"
                     
                ></li>
</ul>
</li>
<li><code>System.Runtime.Serialization.OnSerializedAttribute</code> <ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230919105601.png"
                     
                ></li>
</ul>
</li>
<li><code>System.Runtime.Serialization.OnDeserializingAttribute</code> <ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230919105507.png"
                     
                ></li>
</ul>
</li>
</ul>
<h1 id="2-序列化类型实例原理"><a href="#2-序列化类型实例原理" class="headerlink" title="2 序列化类型实例原理"></a>2 序列化类型实例原理</h1><p><strong>序列化原理</strong><br>在这以 <code>System.Runtime.Serialization</code> 的命名空间的 <code>FormatterServices</code> 为例；</p>
<ul>
<li>第一步<ul>
<li>格式化器调用 FormatterServices 的 <code>GetSerializableMembers</code> 方法；</li>
<li>方法利用反射获取类型的 public 和 private 实例字段，将其返回由 <code>MemberInfo</code> 对象构成的数组，每个元素都对应一个可序列化的实例字段；</li>
<li>方法定义：<code>public static MemberInfo[] GetSerializableMembers (Type type, StreamingContext context);</code></li>
</ul>
</li>
<li>第二步<ul>
<li>对象被序列化， <code>MemberInfo</code> 对象构成的数组传给 FormatterServices 的静态方法 <code>GetObjectData</code>，此方法返回一个 Object 对象数组，每个元素都标识了被序列化的那个对象中的一个字段的值，即 Object 数组中的元素 0 是 MemberInfo 数组中的元素 0 所标识的那个成员的值；</li>
<li>方法定义：<code>public static Object[] GetObjectData(Object obj，MemberInfol] members);</code></li>
</ul>
</li>
<li>第三步<ul>
<li>格式化器将程序集标识和类型的完整名称写入流中；</li>
</ul>
</li>
<li>第四步<ul>
<li>格式化器遍历两个数组中的元素，将每个成员的名称和值写入流中；</li>
</ul>
</li>
</ul>
<p><strong>反序列化原理</strong></p>
<ul>
<li>第一步<ul>
<li>确保程序集加载至对应 AppDomain；</li>
<li>格式化器从流中读取程序集标识和完整类型名称，如果程序集当前没有加载到 AppDomain 中，就加载它,，并且格式化器将程序集标识信息和类型全名传给 FormatterServices 的静态方法 <code>GetTypeFromAssembly</code>；</li>
<li>方法定义： <code>public static Type GetTypeFromAssembly (Assembly assem,String name);</code><ul>
<li>其中返回的 System. Type 对象代表要反序列化的那个对象的类型；</li>
</ul>
</li>
</ul>
</li>
<li>第二步<ul>
<li>为新对象分配内存，对象的所有字节都被初始化为成 null 或0；</li>
<li>调用 FormatterServices 的静态方法 GetUninitializedObject；</li>
<li><code>public static Object GetUninitializedObject(Type type);</code></li>
</ul>
</li>
<li>第三步<ul>
<li>构造并初始化一个 MemberInfo 数组；</li>
<li>调用 FormatterServices 的 GetSerializableMembers 方法，这个方法返回序列化好、现在需要反序列化的一组字段；</li>
</ul>
</li>
<li>第四步<ul>
<li>格式化器根据流中包含的数据创建并初始化一个 Object 数组；</li>
</ul>
</li>
<li>第五步<ul>
<li>将新分配对象、MemberInfo 数组以及并行 Obiect 数组的引用传给 FormatterServices 的静态方法 <code>PopulateObjectMembers</code> ；</li>
<li>此方法遍历数组，将每个字段初始化成对应的值，完成最终的反序列化；</li>
</ul>
</li>
</ul>
<h1 id="3-控制序列化与反序列化数据"><a href="#3-控制序列化与反序列化数据" class="headerlink" title="3 控制序列化与反序列化数据"></a>3 控制序列化与反序列化数据</h1><h2 id="3-1-ISerializable-接口简介"><a href="#3-1-ISerializable-接口简介" class="headerlink" title="3.1 ISerializable 接口简介"></a>3.1 ISerializable 接口简介</h2><p><strong>为什么要进一步控制序列化</strong><br>虽然可以通过使用 OnSerializingOnSerialized，OnDeserializing，OnDeserialized，NonSerialized 和 OptionalField 等特性的方式对序列化进行控制，但还是有以下两点原因导致需要更进一步的控制：</p>
<ul>
<li><ol>
<li>特性无法满足更加复杂的情况时；</li>
</ol>
</li>
<li><ol start="2">
<li>反射性能消耗大，对于时间有较高要求时；<br>当出现以上两种情况时，可以通过继承并实现以下接口的方式来进行：<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISerializable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetObiectData</span>(<span class="params">SerializationInfo infoStreamingContext context</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<strong>什么是 ISerializable 接口</strong><br>ISerializable 接口是用于自定义对象的序列化和反序列化的接口。该接口允许开发人员控制对象在序列化和反序列化过程中的行为，当一个类实现了 ISerializable 接口，它必须实现一个名为 GetObjectData 的方法，用于将对象的数据存储到 <code>SerializationInfo</code> 对象中，以便在序列化时进行保存；</li>
</ol>
</li>
<li>可以自定义一个构造函数，从 <code>SerializationInfo</code> 中获取反序列化时所需的数据来重新构造对象；</li>
<li>当实现了 ISerializable 接口后，当格式化器序列化此类型的对象图时，对于实现了 ISerializable 接口的类型，其所有的定制特性将会被忽略；</li>
</ul>
<p><strong>ISerializable 接口使用注意事项</strong></p>
<ul>
<li>关系一：父子类都需要实现它<ul>
<li>一旦一个类型实现了它，所有派生自此类型的类也必须实现它；</li>
<li>而且派生类型必须保证调用基类的 GetObjectData 方法，以及特殊的构造器</li>
</ul>
</li>
<li>关系二：实现后不可删除<ul>
<li>一旦类型实现了该接口，便永远不能删除它，否则会失去与派生类型的兼容性；</li>
</ul>
</li>
<li>推荐做法：<strong>使用 ISerializable 的类型最好为密封类</strong>；</li>
</ul>
<h2 id="3-2-ISerializable-接口使用：序列化"><a href="#3-2-ISerializable-接口使用：序列化" class="headerlink" title="3.2 ISerializable 接口使用：序列化"></a>3.2 ISerializable 接口使用：序列化</h2><p><strong>SerializationInfo 对象与类型实例化</strong><br>什么是 SerializationInfo </p>
<ul>
<li><code>SerializationInfo</code> 是一个类，它是用于在对象序列化和反序列化过程中存储和检索数据的机制；</li>
<li>简而言之：继承自 ISerializable 类型的实例，其序列化和反序列化的数据将会存储在 SerializationInfo 对象当中；<ul>
<li>ISerializable 接口定义了一个方法 <code>GetObjectData</code>，该方法接受一个 <code>SerializationInfo</code> 对象作为参数，用于序列化对象的数据；</li>
<li>通过该方法，对象的状态被存储在 SerializationInfo 对象中；</li>
</ul>
</li>
</ul>
<p>继承自 ISerializable 对象的实例化</p>
<ul>
<li>构造 SerializationInfo 对象时，格式化器要传递两个参数：Type 和 <code>Serialization</code>；</li>
<li>Type 参数：<ul>
<li>标识要序列化的对象，唯一性地标识一个类型需要的两个部分的信息：</li>
<li><ol>
<li>类型的字符串名称</li>
</ol>
</li>
<li><ol start="2">
<li>程序集标识 ：包括程序集名、版本、语言文化和公钥；</li>
</ol>
</li>
</ul>
</li>
<li>SerializationInfo 参数<ul>
<li>传递了包含类型的全名，通过在内部查询 Type 的 FulIName 属性，这个字符串会存储到一个私有字段中；</li>
</ul>
</li>
</ul>
<p><strong>调用 GetObjectData 方法</strong><br>在类型完成了实例化，SerializationInfo 类被初始化好后，格式化器自动调用 <code>GetObjectData</code> 方法，往其中传入 <code>SerializationInfo</code> 对象的引用；</p>
<ul>
<li>GetObjectData 作用<ul>
<li><code>GetObiectData</code> 调用 <code>SerializationInfo</code> 类型提供的 <code>AddValue</code> 方法的众多重载版本之一，来指定要序列化的信息；</li>
<li>针对要添加的每个数据，都要调用一次 <code>AddValue</code>；</li>
</ul>
</li>
<li>例子：<code>DictionaryL&lt;TKey,TValue&gt;</code> 的 <code>GetObjectData</code> 实现<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230920143256.png"
                     
                ></li>
</ul>
</li>
<li>GetObjectData 运作机理<ul>
<li>在内部，使用 <code>AddValue</code> 方法来将成员中的数据，存储在 <code>SerializationInfo</code> 类型的成员当中；</li>
<li>当需要反序列化时，在利用 <code>SerializationInfo</code> 中存储的数据，复原出程序的状态；</li>
</ul>
</li>
<li>GetObjectData 使用注意事项<ul>
<li>不要在其他实例的位置，调用这个 GetObjectData 方法；</li>
<li>GetObjectData 方法应该由对象在实例化时自动调用，不然格式化器在反序列化时，不知道何时创建新的对象；</li>
</ul>
</li>
</ul>
<p><strong>AddValue 方法</strong><br>每个 <code>AddValue</code> 方法都可以获取一个 String 名称和一些数据；</p>
<ul>
<li>数据一般是简单的值类型，比如 Boolean， Char， Byte，SByte, Int 16, UInt 16，Int 32， UInt 32，Int 64，UInt 64，SingleDouble，Decimal；</li>
<li>还可以在调用 <code>AddValue</code> 时向它传递对一个 Object 的引用；</li>
<li><code>GetObjectData</code> 在利用完 <code>AddValue</code> 添加好所有必要的序列化信息之后，会返回至格式化器；</li>
</ul>
<h2 id="3-3-ISerializable-接口使用：反序列化"><a href="#3-3-ISerializable-接口使用：反序列化" class="headerlink" title="3.3 ISerializable 接口使用：反序列化"></a>3.3 ISerializable 接口使用：反序列化</h2><p><strong>ISerializable 反序列化原理</strong></p>
<ul>
<li>第一步：为新对象分配内存并初始化<ul>
<li>格式化器从流中提取一个对象时，通过调用 <code>System. Runtime. Serialize. FormatterServices</code> 类型的静态 <code>GetUninitializedObject</code> 方法为新对象分配内存，并且这个对象的所有字段都设为 0 或 null；</li>
</ul>
</li>
<li>第二步：检查接口，调用特殊构造器<ul>
<li>格式化器会检查类型是否实现了 ISerializable 接口；</li>
<li>如果存在这个接口，格式化器就尝试调用一个特殊构造器，它的参数和 GetObiectData 方法的完全一致；</li>
<li>补充：关于特殊构造器<ul>
<li>无论特殊构造器声明为什么，格式化器都能调用它；</li>
<li>如果你的类是密封类，强烈建议将这个特殊构造器声明为 private；</li>
<li>如果不是密封类，则可以将此特殊构造器声明为 protected；</li>
</ul>
</li>
</ul>
</li>
<li>第三步：获得 SerializationInfo 对象引用，调用 Get 方法恢复字段值<ul>
<li>构造器获取一个 <code>SerializationInfo</code> 对象引用，在这个 SerializationInfo 对象中，包含了对象序列化时添加的所有值；</li>
<li>特殊构造器可调用 GetBoolean，GetChar，GetByte，GetSByte，GetInt 16，GetUInt 16，Getlnt 32，GetUlnt 32，Getlnt 64，GetUInt 64，GetSingle，GetDouble，GetDecimal，GetDateTime，GetString 和 GetValue 等任何一个方法；</li>
<li>使用上述方法，向它传递与序列化一个值所用的名称对应的字符串，返回的值再用于初始化新对象的各个字段；</li>
<li>返回的值为传给 <code>AddValue</code> 的数值的类型对应的 Get 方法；<ul>
<li>比如 AddValue 时传递的是一个 <code>Int32</code> 值，那么在反序列化对象时，应该为同一个值调用 <code>Getlnt32</code> 的方法；</li>
</ul>
</li>
<li><strong>恢复字段值时，SerializationInfo 自动选择哪一个 FormatterConverter 来进行数值恢复与转换</strong>；</li>
</ul>
</li>
<li>第四步：由格式化器选择 IFormatterConverter 的类型<ul>
<li>Microsoft 的 <code>BinaryFormatter</code> 和 <code>SoapFormatter</code> 类型总是构造 <code>System. RuntimeSerialization. FormatterConverter</code> 类型的实例；</li>
</ul>
</li>
</ul>
<p><strong>什么是 FormatterConverter</strong><br>FormatterConverter 是位于 System.Runtime.Serialization 命名空间中的类，FormatterConverter 类实现了 IFormatterConverter 接口，该接口定义了类型转换的方法，提供了类型转换的功能，用于在<strong>序列化和反序列化过程中将值从一种类型转换为另一种类型</strong>；</p>
<ul>
<li>重要的方法<ul>
<li>Convert 方法：用于将值从一种类型转换为另一种类型；</li>
<li>ToBoolean、 ToByte、 ToChar、 ToDateTime 等方法：提供了将值从字符串转换为基本数据类型的方法；</li>
<li>GetTypeFromSerializedName 方法：用于根据给定的类型别名反序列化时获取实际类型。在进行反序列化时，序列化的数据可能仅提供了类型的别名而不是实际类型。使用该方法可以根据别名获取实际类型，以便正确地还原对象；</li>
</ul>
</li>
</ul>
<ul>
<li>与反序列化的关系<ul>
<li><h2 id="反序列化过程中，FormatterConverter-类的-Convert-方法被用于类型转换；-FormatterConverter-类型调用-System-Convert-类的各种静态方法，在不同的核心类型之间对值进行转换；"><a href="#反序列化过程中，FormatterConverter-类的-Convert-方法被用于类型转换；-FormatterConverter-类型调用-System-Convert-类的各种静态方法，在不同的核心类型之间对值进行转换；" class="headerlink" title="反序列化过程中，FormatterConverter 类的 Convert 方法被用于类型转换；  - FormatterConverter 类型调用 System. Convert 类的各种静态方法，在不同的核心类型之间对值进行转换；"></a>反序列化过程中，FormatterConverter 类的 Convert 方法被用于类型转换；<br>  - FormatterConverter 类型调用 <code>System. Convert</code> 类的各种静态方法，在不同的核心类型之间对值进行转换；</h2></li>
<li>当从序列化的数据中恢复对象时，可能需要将值转换为正确的类型；<ul>
<li>例如，将字符串转换为整数、将浮点数转换为日期等；</li>
</ul>
</li>
<li>FormatterConverter 类提供了这些类型转换的功能，以确保反序列化过程中的准确性；</li>
<li>只有在反序列化对象时调用一个 Get 方法，但<strong>发现它的类型和流中的值的类型不符时</strong>才会使用 FormatterConverter 对象；</li>
</ul>
</li>
</ul>
<h1 id="4-实现-ISerializable-但基类型没有实现"><a href="#4-实现-ISerializable-但基类型没有实现" class="headerlink" title="4 实现 ISerializable 但基类型没有实现"></a>4 实现 ISerializable 但基类型没有实现</h1><p><strong>问题描述</strong><br>当需要对派生类实现 ISerializable 接口，但是其父类没有实现 ISerializable 时，此时就需要手动的序列化基类的字段，让派生类可以被正确的序列化与反序列化；</p>
<p><strong>实现方法</strong></p>
<ul>
<li><ol>
<li>获得基类的值后，将这些值放入到 SerializationInfo 的集合中；</li>
</ol>
</li>
<li><ol start="2">
<li>在类型的特殊构造函数中，从集合中取出这些值，并以某种方式设置基类的字段。</li>
</ol>
<ul>
<li>如果基类的字段时 public 或者 protected 时，可以直接被序列化实现；</li>
</ul>
</li>
</ul>
<p><strong>实现代码片段</strong><br>利用方法获得基类的 Type 引用，并适应此引用得到其成员的 MemberInfo 数组；</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line">Type baseType = thie.GetType().BaseType;</span><br><span class="line">MemberInfo[] mi = FormatterServices.GetSerializableMembers(baseType,context);</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>CLR</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSharp系列】运行时序列化（3） -- 流上下文、序列化代理与序列化不同类型</title>
    <url>/2023/09/a9f66119866b.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h1 id="1-流上下文"><a href="#1-流上下文" class="headerlink" title="1 流上下文"></a>1 流上下文</h1><p><strong>为什么有流上下文</strong><br>一组序列化好的对象可以有许多目的地： </p>
<ul>
<li>同一个进程；</li>
<li>同一台机器上的不同进程；</li>
<li>不同机器上的不同进程；</li>
<li>等等<br>在一些比较少见的情况下，一个对象可能想知道它要在什么地方反序列化，从而以不同的方式生成它的状态。但也会出现序列化到其他地方时，此序列化的数据无意义的情况；<br><em>如果对象中包装了 Windows 信号量对象，如果它知道要反序列化到同一个进程中，就可决定对它的内核句柄进行序列化，这是因为内核句柄在一个进程中有效。但如果要反序列化到同一台计算机的不同进程中，就可决定对信号量的字符串名称进行序列化。最后，如果要反序列化到不同计算机上的进程，就可决定抛出异常，因为信号量只在一台机器内有效</em></li>
</ul>
<p><strong>StreamingContext 流上下文</strong></p>
<ul>
<li>StreamingContext 结构是一个值类型，提供了以下两个属性：</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230921163258.png"
                     
                ></li>
</ul>
<p>其中 State 的信息表示了序列化或者反序列化的来源：</p>
<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230921163330.png"
                     
                ></li>
</ul>
<p><strong>如何设置标志</strong><br>使用方法：在调用 Serialize 或者 Deserialize 方法之前，将格式化器（BinaryFormatter 或者 SoapFormatter）的 Context 属性进行设置；</p>
<ul>
<li>具体实现原理<ul>
<li>在 IFormatter 接口当中定义了 StreamingContext 类型的属性 Context；</li>
<li>构造格式化器的时候，会初始化 Context 属性，将 State 设置为 All；</li>
<li>格式化器构造好后，即可为 StreamingContext 对象进行赋值。通过设置不同的 StreamingContext 数值，可以实现调用不同的序列化或者反序列化方法时序列化到目标流；</li>
</ul>
</li>
</ul>
<h1 id="2-类型序列化为不同类型"><a href="#2-类型序列化为不同类型" class="headerlink" title="2 类型序列化为不同类型"></a>2 类型序列化为不同类型</h1><p><strong>为什么要将类型序列化成不同的类型</strong></p>
<ul>
<li>原因一：对单实例的序列化，只应进行一次实例化，其他时候传引用<ul>
<li>比如 System. DBNull 和 System. Reflection. Missing 这些类型，其设计成每个 AppDomain 只有一个实例；</li>
<li>给 DBNull 对象的引用序列化和反序列化，不应造成在 AppDomain 中新建一个 DBNull 对象；</li>
<li>因为反序列化后返回的引用应指向 AppDomain 中现有的 DBNull 对象；</li>
</ul>
</li>
<li>原因二：对于某些类型其只能有一个实例<ul>
<li>比如一个数组中的每个元素都引用一个 MemberInfo 对象，序列化和反序列中，还应该是引用的同一个对象，而不是五个；</li>
</ul>
</li>
<li>原因三：远程控制的对象，有时只需要序列化代理<ul>
<li>对于远程控制的对象，CLR 序列化与服务器对象有关的信息；</li>
<li>在客户端上反序列化时会使得 CLR 创建一个代理对象，这个代理对象的类型有别于服务器对象的类型，客户端直接在代理对象上调用实例方法，其代理代码内部会调用远程发送给服务器，由后者实际执行请求的操作；</li>
</ul>
</li>
</ul>
<h1 id="3-序列化代理"><a href="#3-序列化代理" class="headerlink" title="3 序列化代理"></a>3 序列化代理</h1><p><strong>为什么需要序列化代理</strong><br>有时格式化器允许那些<strong>不是类型实现的一部分的代码，覆盖该类型的系列化与反序列化的方式</strong>，主要是因为两部分原因：</p>
<ol>
<li>允许开发人员去序列化那些最初没有设计成要序列化的类型；</li>
<li>允许开发人员提供一种方式，将类型的一个版本映射到类型的一个不同的版本；</li>
</ol>
<ul>
<li>为此，提供了一种代理类型可以接管现有类型的序列化和反序列化行为，这部分类型就是序列化代理；</li>
</ul>
<p><strong>使用前准备流程</strong></p>
<ul>
<li><ol>
<li>准备 ISerializationSurrogate 接口，实现此接口，定制行为；</li>
</ol>
</li>
<li><ol start="2">
<li>创建代理选择器，在代理选择器中将类型与接口绑定；</li>
</ol>
</li>
<li><ol start="3">
<li>向格式化器登记此代理选择器；</li>
</ol>
</li>
</ul>
<h2 id="3-1-ISerializationSurrogate-接口"><a href="#3-1-ISerializationSurrogate-接口" class="headerlink" title="3.1 ISerializationSurrogate 接口"></a>3.1 ISerializationSurrogate 接口</h2><p><strong>System. Runtime. Serialization. ISerializationSurrogate 接口</strong><br>为了实现序列化代理类型，需要继承 ISerializationSurrogate 接口；<br>此接口定义以下两个方法：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISerializationSurrogate</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params">Object obj,SerializationInfo info,StreamingContext context</span>)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function">Object <span class="title">SetObjectData</span>(<span class="params">Object obj,SerializationInfo info,StreamingContext context,ISerializationSurrogate selector</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>通过继承此接口，并且实现两方法，可以定制类型的序列化以及反序列化行为；</p>
<ul>
<li><code>GetObjectData</code> 方法<ul>
<li><code>GetObjectData</code> 方法要获取一个额外的参数 Object obj，这个参数表示序列化的“真实”对象的引用；</li>
<li>其余使用和 ISerializable 接口一致；</li>
</ul>
</li>
<li><code>SetObjectData</code> 方法<ul>
<li>用于反序列化对象，调用此方法时传入一个 SerializationInfo 对象的引用；</li>
<li>使用 <code>SetObjectData </code> 后的反序列化过程<ul>
<li>调用 SetObjectData 方法之前，格式化器分配类型的实例，设置值为 0&#x2F;null；</li>
<li>初始化字段的值，使用传入的 <code>SerializationInfo info</code> 参数中的数值；</li>
</ul>
</li>
<li>传入的第一个 Object obj 参数</li>
</ul>
</li>
</ul>
<h2 id="3-2-SurrogateSelector-代理选择器"><a href="#3-2-SurrogateSelector-代理选择器" class="headerlink" title="3.2 SurrogateSelector 代理选择器"></a>3.2 SurrogateSelector 代理选择器</h2><p><strong>SurrogateSelector 与 AddSurrogate 方法</strong><br><code>SurrogateSelector</code> 与序列化密切相关，因为它允许你自定义序列化和反序列化的过程；</p>
<ul>
<li>它与. NET Framework 中的各种序列化器一起使用，在使用 <code>SurrogateSelector</code> 时，可以指定<ul>
<li>哪些类型的对象应该使用代理进行序列化和反序列化； </li>
<li>使用哪个代理类型来处理它们；<br>比如对于一个 SurrogateSelector 类，可以创建代理选择器，在代理选择器中将类型与接口绑定；<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个SurrogateSelector实例</span></span><br><span class="line">SurrogateSelector surrogateSelector = <span class="keyword">new</span> SurrogateSelector();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个代理类型，以便在序列化和反序列化时使用自定义逻辑</span></span><br><span class="line">surrogateSelector.AddSurrogate(</span><br><span class="line">    <span class="keyword">typeof</span>(MyCustomType),      <span class="comment">// 要处理的类型</span></span><br><span class="line">    <span class="keyword">new</span> StreamingContext(),    <span class="comment">// 序列化上下文</span></span><br><span class="line">    <span class="keyword">new</span> MyCustomTypeSurrogate() <span class="comment">// 自定义的代理类型</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<p><strong>内部哈希表</strong><br>SurrogateSelector 对象的内部维护了一个私有哈希表；</p>
<ul>
<li>调用 <code>AddSurrogate</code> 时，<code>Type</code> 和 <code>StreamingContext</code> 构成了哈希表的键 (key)；<ul>
<li>值为 <code>ISerializationSurrogate</code> 对象，如果已经存在和要添加的 <code>Type/StreamingContext</code> 相同的一个键，<code>AddSurrogate</code> 会抛出一个 ArgumentException；</li>
<li>通过在键中包含一个 <code>StreamingContext</code>，可以登记一个代理类型对象，它知道如何将目标对象的序列化&#x2F;反序列化到一个文件中；</li>
</ul>
</li>
</ul>
<h2 id="3-3-向格式化器登记接口"><a href="#3-3-向格式化器登记接口" class="headerlink" title="3.3 向格式化器登记接口"></a>3.3 向格式化器登记接口</h2><p><strong>向格式化器登记 ISerializationSurrogate 接口</strong><br>以下是向格式化器登记的流程：</p>
<div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> MemoryStream)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//第一步：构造所需要的格式化器</span></span><br><span class="line">	IFormatter formatter = <span class="keyword">new</span> SoapFormatter();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第二步：构造一个代理选择器</span></span><br><span class="line">	SurrogateSelector ss = <span class="keyword">new</span> SurrogateSelector();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三步：告诉代理选择器，为某类型的对象使用此代理。此代理为你自己设计的、继承自ISerializationSurrogate的类型</span></span><br><span class="line">	<span class="comment">//在这代理类型为：TargetSerializationSurrogate</span></span><br><span class="line">	ss.AddSurrogate(<span class="keyword">typeof</span>(TargetClass),formatter.Context,<span class="keyword">new</span> TargetSerializationSurrogate());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第四步：告诉格式化器使用代理选择器</span></span><br><span class="line">	formatter.SurrogateSelector = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>当完成登记之后，对于 <code>TargetClass</code> 类型的序列化以及反序列化，都会使用 TargetSerializationSurrogate 类型中定义的方法；</p>
<h1 id="4-反序列化对象时重写程序集-类型"><a href="#4-反序列化对象时重写程序集-类型" class="headerlink" title="4 反序列化对象时重写程序集&#x2F;类型"></a>4 反序列化对象时重写程序集&#x2F;类型</h1><p><strong>为什么需要反序列化对象时重写程序集&#x2F;类型</strong><br>有的时候 <code>ISerializationSurrogate</code> 机制的灵活性显得有点不足，在下面列举的情形中有必要将对象反序列化成和序列化时不同的类型：</p>
<ul>
<li><ol>
<li>开发人员想把一个类型的实现，从一个程序集移动到另一个程序集；</li>
</ol>
<ul>
<li>例如，程序集版本号的变化造成新程序集有别于原始程序集；</li>
</ul>
</li>
<li><ol start="2">
<li>服务器对象序列化到发送给客户端的流中；</li>
</ol>
<ul>
<li>客户端处理流时，可以将对象反序列化成完全不同的类型，该类型的代码知道如何向服务器的对象发出远程方法调用；</li>
</ul>
</li>
<li><ol start="3">
<li>开发人员创建了类型的新版本，想把已序列化的对象反序列化成类型的新版本；<br>因此，需要使用 <code>System.Runtime.Serialization.SerializationBinder</code> 类来将对象反序列化成不同的类型；</li>
</ol>
</li>
</ul>
<p><strong>实现并使用 SerializationBinder 类型</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230922154937.png"
                     
                ></p>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
        <tag>序列化</tag>
        <tag>流上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>【静态程序分析】Lecture 1：课程导论</title>
    <url>/2023/09/b54817141541.html</url>
    <content><![CDATA[<p><a class="link"   href="https://ranger-nju.gitbook.io/static-program-analysis-book/" >https://ranger-nju.gitbook.io/static-program-analysis-book/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<span id="more"></span>
<h2 id="1-什么是静态程序分析"><a href="#1-什么是静态程序分析" class="headerlink" title="1 什么是静态程序分析"></a>1 什么是静态程序分析</h2><p><strong>静态程序分析在计算机科学领域中的定位</strong></p>
<ul>
<li><strong>静态程序分析</strong>是编程语言中应用层面下的一个细分领域，它是一个非常重要的核心内容；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230912174840.png"
                     
                ></li>
<li>理论部分<ul>
<li>考虑的是如何设计一个语言的语法和语义，如何设计语言的类型系统等等问题；</li>
<li>有了语言的语法、语义和类型系统之后，我们需要支撑语言的运行；</li>
</ul>
</li>
<li>环境部分<ul>
<li>需要考虑如何为运行中的程序提供运行时环境——如何设计编译器，在运行时需要怎样的支持（如内存的分配管理）等等；</li>
</ul>
</li>
<li>应用部分<ul>
<li>则注如何保证语言所写出程序的效率、安全性和可靠性，主要考虑如何对程序进行分析，验证和合成（如何自动合成一个程序）；</li>
<li><strong>静态程序分析是应用下面的一个子分类；</strong></li>
</ul>
</li>
</ul>
<p><strong>静态分析定义</strong><br>在运行一个程序之前，就了解这个程序的所有行为，并判断是否一些属性在运行前可以被满足；</p>
<h3 id="1-1-Sound-与-Complete"><a href="#1-1-Sound-与-Complete" class="headerlink" title="1.1 Sound 与 Complete"></a>1.1 Sound 与 Complete</h3><p><strong>Sound 与 Complete 概念</strong><br>Sound 与 Complete 与事实的关系：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230912180907.png"
                     
                ></p>
<ul>
<li>Sound （全面性）<ul>
<li>Truth 当中有的问题，Sound 当中都有；</li>
<li>对于 Truth 是一个包含关系；</li>
<li>Overapproximate</li>
</ul>
</li>
<li>Complete <ul>
<li>Complete 不可能出现 Truth 当中不存在的；</li>
</ul>
</li>
<li>不可能存在一个即 Sound 也 Complete 的分析方法；</li>
</ul>
<p><strong>静态分析方法的取舍</strong><br>静态分析方法只满足 Sound 或 Complete 当中一个；</p>
<ul>
<li>false negatives：漏报<ul>
<li>妥协；造成一定的漏报，有 Bug 漏报；</li>
</ul>
</li>
<li>false positives：误报<ul>
<li>误报：报告错误的 Bug；</li>
</ul>
</li>
<li><strong>大部分的静态分析，都是要求 false positives：误报；</strong></li>
</ul>
<h3 id="1-2-Soundness-的必要性"><a href="#1-2-Soundness-的必要性" class="headerlink" title="1.2 Soundness 的必要性"></a>1.2 Soundness 的必要性</h3><p><strong>例子：全面性对于静态分析的重要</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230912184810.png"
                     
                ><br>如果是执行的 B 这条路径，那下面的赋值语句可以通过编译；<br>但如果是先执行的 C 类那条路径，则下面的代码将发出 cast bug，程序不安全；</p>
<ul>
<li>Safe Cost 是我们的结论，静态分析应该保证全面性，然后得出是否 safe 的结论；</li>
</ul>
<p><strong>more soundness 总是更好的</strong><br>可以查出更多的问题，对程序更好；</p>
<h3 id="1-3-从概念上理解静态分析"><a href="#1-3-从概念上理解静态分析" class="headerlink" title="1.3 从概念上理解静态分析"></a>1.3 从概念上理解静态分析</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(input)</span><br><span class="line">	x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>
<p>请问 1 和 2 哪个才是正确的：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230912185222.png"
                     
                ><br>答案：1 和 2 都是正确的；</p>
<ul>
<li>第一种：Sound、精确、昂贵</li>
<li>第二种：Sound、不精确、便宜</li>
</ul>
<p><strong>静态分析，需要在保证 soundness 的前提下，在精确和速度之间掌握平衡</strong></p>
<h1 id="2-静态分析的应用与对比"><a href="#2-静态分析的应用与对比" class="headerlink" title="2 静态分析的应用与对比"></a>2 静态分析的应用与对比</h1><h2 id="2-1-编程语言的分类"><a href="#2-1-编程语言的分类" class="headerlink" title="2.1 编程语言的分类"></a>2.1 编程语言的分类</h2><p>当今的计算机世界，面对这样一条恶龙： 👇</p>
<blockquote>
<p>数十年来语言的核心没有变化，但软件的规模和复杂性增长迅速，如何保证程序的可靠性？</p>
</blockquote>
<p>尽管新的语言和特性层出不穷，但现在编程语言无非三大类：</p>
<ul>
<li>命令式（C、C++、JAVA）</li>
<li>函数式（<a class="link"   href="https://www.scala-lang.org/" >Scala <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、<a class="link"   href="https://www.haskell.org/" >Haskell <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）</li>
<li>逻辑式（<a class="link"   href="https://en.wikipedia.org/wiki/Prolog" >Prolog <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）<br>虽然现在语言很多，但语言的内核没有发生太大的变化；</li>
</ul>
<p><strong>为什么需要 PL</strong><br>尽管编程语言没有特别大的变化，但软件变化很大；<br>应用部分的变化很大，软件越来越复杂，因此对于应用的需求越来越大；</p>
<ul>
<li>例：一个程序在运行前，就发现它有没有隐私泄露的可能；</li>
<li>例：任意两个变量，它们有没有可能指向同一块地址；在并发时要提前为其上锁；</li>
<li>等等…</li>
</ul>
<p><strong>PL 的问题</strong><br>虽然 PL 的研究领域很多，但很难确定真正的准确的问题方法；</p>
<ul>
<li>没有完美的静态分析方法；</li>
</ul>
<h2 id="2-2-静态程序分析的应用"><a href="#2-2-静态程序分析的应用" class="headerlink" title="2.2 静态程序分析的应用"></a>2.2 静态程序分析的应用</h2><p><strong>作用领域</strong></p>
<ul>
<li><ol>
<li>提高程序可靠性</li>
</ol>
<ul>
<li>Null pointer dereference, memory leak, etc.</li>
<li>空指针引用与内存泄漏等：几乎每个程序编写者都被这两个问题所困扰过</li>
</ul>
</li>
<li><ol start="2">
<li>提高程序安全性</li>
</ol>
<ul>
<li>Private information leak, injection attack, etc.</li>
<li>隐私信息泄漏：这一问题在移动应用中较为普遍；</li>
<li><a class="link"   href="https://en.wikipedia.org/wiki/Code_injection" >注入攻击 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：这是网络安全中非常常见的议题。不熟悉的读者可以查看<a class="link"   href="https://www.w3schools.com/sql/sql_injection.asp" >W3School <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>或<a class="link"   href="https://en.wikipedia.org/wiki/SQL_injection" >Wiki <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>上关于SQL注入攻击的例子；</li>
</ul>
</li>
<li><ol start="3">
<li>为编译优化提供基础技术</li>
</ol>
<ul>
<li>Dead code elimination, code motion, etc；</li>
<li><a class="link"   href="https://en.wikipedia.org/wiki/Dead_code_elimination" >死代码消除 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：在编译器的机器无关优化环节，将不会对程序执行结果产生影响的代码（即死代码）删除；</li>
<li><a class="link"   href="https://en.wikipedia.org/wiki/Loop-invariant_code_motion" >循环不变量的代码移动 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：在编译器的机器无关优化环节，在保证不影响程序执行结果的情况下，将循环中的特定语句移动到循环外，使得程序运行时执行的语句数减少。更为详细的解释可以参考<a class="link"   href="https://stackoverflow.com/questions/5607762/what-does-code-motion-mean-for-loop-invariant-code-motion" >StackOverFlow上的回答 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>；</li>
</ul>
</li>
<li><ol start="4">
<li>有助于程序理解</li>
</ol>
<ul>
<li>IDE call hierarchy, type indication, etc.</li>
<li>为集成开发环境的功能提供帮助：当你使用VS&#x2F;Idea&#x2F;Clion&#x2F;Eclipse&#x2F;Android Studio等等IDE时，将鼠标悬停在代码上，IDE能够动态地分析并提示你所悬停对象的相关信息，背后使用的技术就是静态程序分析。<br>此外，静态程序分析技术也可以分析多线程程序，这是一个有难度的研究领域。主要困难在于处理多线程间的interleaving；</li>
</ul>
</li>
</ul>
<h2 id="2-3-静态程序分析的市场"><a href="#2-3-静态程序分析的市场" class="headerlink" title="2.3 静态程序分析的市场"></a>2.3 静态程序分析的市场</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230912175706.png"
                     
                ></p>
<ul>
<li>在工业界，国外的 Google，IBM 等大企业已经初步建立了自己的静态程序分析团队；</li>
<li>国内的华为和阿里等企业也正在积极寻找静态程序分析方面的人才；</li>
</ul>
<h2 id="2-4-静态程序分析与类似技术的对比"><a href="#2-4-静态程序分析与类似技术的对比" class="headerlink" title="2.4 静态程序分析与类似技术的对比"></a>2.4 静态程序分析与类似技术的对比</h2><blockquote>
<p>Testing shows the presence, not the absence of bugs. –Edsger W. Dijkstra</p>
</blockquote>
<p>动态的软件测试和形式化语义的验证的作用与静态程序分析类似，这一部分对这三个细分方向做简单的对比。</p>
<h1 id="3-两个词总结静态分析"><a href="#3-两个词总结静态分析" class="headerlink" title="3 两个词总结静态分析"></a>3 两个词总结静态分析</h1><p>两个核心词总结静态分析：<strong>Abstraction + Over - Approximation</strong>；</p>
<p><strong>一个简单的例子</strong><br>例子：检查程序中的变量是不是为 + 、- 、0 等符号；</p>
<ul>
<li><p>由此可以检查出 ： 是否有除零错误；</p>
</li>
<li><p>Abstraction </p>
<ul>
<li>具体的值与抽象的域<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230913180105.png"
                     
                ></li>
<li>对于 <code>v=e</code> 的抽象的值 -&gt; unknown</li>
<li>对于 <code>v=w/0</code> 也要抽象出来；-&gt; unknown</li>
</ul>
</li>
<li>将以上图中左边的具体的值，抽象成我们关注的右边的抽象的值<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230913180301.png"
                     
                ></li>
</ul>
</li>
</ul>
</li>
<li><p>Over-approximate </p>
<ul>
<li>在静态分析中，transfer functions define how to evaluate different program statements on abstract values.</li>
<li>针对程序当中的每一个语句，针对这些抽象值定义其转化规则<ul>
<li>根据程序的语义，以及程序的分析得到规则；</li>
</ul>
</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230913180602.png"
                      alt="转化规则"
                ></li>
</ul>
</li>
</ul>
<p><strong>根据上述转化规则得到其值</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230913180829.png"
                     
                ><br>根据抽象规则，得到红框中每一行代码的抽象计算出结果；</p>
<ul>
<li>由静态分析得到 <ul>
<li>1、可能发生除零错误；</li>
<li>2、p 和 q 可能发生数组下标为 0；</li>
</ul>
</li>
</ul>
<h2 id="3-1-Over-approximate-在控制流当中"><a href="#3-1-Over-approximate-在控制流当中" class="headerlink" title="3.1 Over-approximate 在控制流当中"></a>3.1 Over-approximate 在控制流当中</h2><p>要根据 if 语句的控制流，得到每一个分支的 over-approximate 结果；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230913181137.png"
                     
                ></p>
<ul>
<li>当涉及到控制流时，原本固定的值，会出现不同的分支不同的结果<ul>
<li>y 在执行 <code>z = x + y</code> 时，既有可能是正，也有可能是负；</li>
</ul>
</li>
<li>在控制流绘制的地方，都要对抽象进行合并（通过过近似）；</li>
</ul>
<p><strong>问题：真实程序中分支成千上万，在实践中要枚举所有路径得到所有的分支，通过过近似合并分支的抽象值</strong></p>
]]></content>
      <categories>
        <category>静态程序分析</category>
      </categories>
      <tags>
        <tag>静态程序分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【静态程序分析】Lecture 2：Intermediate Representation</title>
    <url>/2023/09/13ccfbbad41b.html</url>
    <content><![CDATA[<p>编译器是如何理解程序的？需要将程序转化成一个用于编译器理解的格式；</p>
<ul>
<li>在这样的一种格式之上，便于编译器进行分析、研究；</li>
<li>将源代码变成 IR 形式来进行研究；<span id="more"></span></li>
</ul>
<h2 id="2-1-Compilers-And-Static-Analyzers"><a href="#2-1-Compilers-And-Static-Analyzers" class="headerlink" title="2.1 Compilers And Static Analyzers"></a>2.1 Compilers And Static Analyzers</h2><p><strong>编译器和静态分析的关系</strong></p>
<ul>
<li>共同点<ul>
<li>都是在程序编译之前，对程序完成分析、生成；</li>
</ul>
</li>
<li>不同点<ul>
<li>虽然静态分析也可以基于 AST 来进行分析，但大部分情况下，都是基于 3AC 基础之上进行的；</li>
</ul>
</li>
</ul>
<p><strong>什么是编译器</strong><br>编译器不止是一个转化，在编译时还需要报错；</p>
<ul>
<li>前端<ul>
<li>词法分析<ul>
<li><em>Scanner</em></li>
<li>分析单词是否合法，合法时给下一步一个 Tokens</li>
<li>使用正则表达四；</li>
<li><strong>结果：Tokens</strong></li>
</ul>
</li>
<li>语法分析<ul>
<li><em>Parser</em></li>
<li>语法分析器，分析其语法是否合理；上下文敏感的语法；</li>
<li>对于现代编程语法而言，Context-Free Grammar 就够了；</li>
<li>Context-Free Grammar</li>
<li><strong>结果：AST</strong></li>
</ul>
</li>
<li>语义分析<ul>
<li><em>Type Checker</em></li>
<li>主要做的就是类型检查；</li>
<li>使用 Attribute Grammar </li>
<li><strong>结果：Decorated AST</strong></li>
</ul>
</li>
</ul>
</li>
<li>优化器<ul>
<li>转换器<ul>
<li><em>Translator</em></li>
<li><strong>结果：IR</strong> -&gt; 静态分析基于 IR 的部分；<ul>
<li>静态分析之前，首先需要先通过前端的检查之后，再有需要在进行进一步的分析；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>后端<ul>
<li>代码生成<ul>
<li>生成具体的及其代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-AST-VS-IR"><a href="#2-2-AST-VS-IR" class="headerlink" title="2.2 AST VS. IR"></a>2.2 AST VS. IR</h2><blockquote>
<p><strong>AST 存活了这么长时间，为什么要学 IR？</strong></p>
</blockquote>
<p><strong>简单的代码示例</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">do</span> <span class="variable">i</span> <span class="operator">=</span> i + <span class="number">1</span>; <span class="keyword">while</span> (a[i]&lt;v);</span><br></pre></td></tr></table></figure></div>
<p>对应的语法树：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230914184203.png"
                     
                ><br>对应的 IR：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230914184302.png"
                     
                ></p>
<p><strong>AST 与 IR 特性比较</strong></p>
<ul>
<li>AST <ul>
<li>更加高层的语言；</li>
<li>依赖于不同的语言；</li>
<li>很难直接通过读 AST 来读出程序的信息；</li>
<li></li>
</ul>
</li>
<li>IR<ul>
<li>更加贴近机器语言；</li>
<li>和语言的依赖性不高。因为很多语言都可以编译成汇编形式，因此 IR 可以接受各种语言，通过不同的前端实现；</li>
<li>IR 是 Compact 以及 uniform。十分的简介；</li>
<li>IR 的代码具有可读性；比如可以读出上述 IR 代码的控制流，更利于静态分析；</li>
</ul>
</li>
<li>结论：IR 相比于 AST，更适合进行静态分析；</li>
</ul>
<h2 id="2-3-IR-Three-Address-Code"><a href="#2-3-IR-Three-Address-Code" class="headerlink" title="2.3 IR: Three-Address Code"></a>2.3 IR: Three-Address Code</h2><blockquote>
<p>IR：三地址码<br>There is at most one operator on right side of an instruction<br>一条指令就是一个操作；</p>
</blockquote>
<p><strong>为什么叫三地址？</strong><br>三地址指的只是一种概念上的形式；一条指令当中最多可以有三个地址值；</p>
<p><strong>常见形式的三地址码</strong></p>
<ul>
<li>x &#x3D; y <font color="#ff0000">bop</font> z<ul>
<li>bop：二元操作符 -&gt; 逻辑、数值计算；</li>
</ul>
</li>
<li>x &#x3D; <font color="#ff0000">uop</font> y<ul>
<li>uop：一元操作符 -&gt; 取反、casting；</li>
</ul>
</li>
<li>x &#x3D; y</li>
<li>goto L<ul>
<li>无条件跳转指令；比如 for 循环；</li>
</ul>
</li>
<li>if x goto L<ul>
<li>有条件跳转指令；</li>
</ul>
</li>
<li>if x <font color="#ff0000">rop</font> y goto L<ul>
<li>有条件状态跳转指令；</li>
</ul>
</li>
</ul>
<h2 id="2-4-ThreeAC-in-Real-Static-Analyzer-Soot"><a href="#2-4-ThreeAC-in-Real-Static-Analyzer-Soot" class="headerlink" title="2.4 ThreeAC in Real Static Analyzer: Soot"></a>2.4 ThreeAC in Real Static Analyzer: Soot</h2><p><strong>真实的三地址码：Soot and Its IR</strong></p>
<ul>
<li>Soot<ul>
<li>一个流行的静态分析器；</li>
<li>它是一种 typed 的静态分析器；<ul>
<li>基于类型的静态分析器；</li>
</ul>
</li>
</ul>
</li>
<li>Signature：<ul>
<li>包含 class name ，return name，parameter 多个；</li>
<li>这些构成了一个 Method Signature；</li>
</ul>
</li>
</ul>
<h2 id="2-5-Static-Single-Assignment-SSA"><a href="#2-5-Static-Single-Assignment-SSA" class="headerlink" title="2.5 Static Single Assignment (SSA)"></a>2.5 Static Single Assignment (SSA)</h2><p>也是一种 IR 的格式，但有其弊端；其是在 80 年代提出的一种十分经典的技术；<br>所有的定义一个新的名字，再后续的处理当中使用；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230915154409.png"
                     
                ></p>
<ul>
<li>给每个定义，一个新的名字以及下标</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230915154500.png"
                     
                ><br><strong>每个变量有单独的定义</strong><br><strong>和分支有关的会使用专门的表示</strong></li>
</ul>
<p>程序流的信息分析，速度更快</p>
<ul>
<li>缺点<ul>
<li>引入太多的变量；</li>
<li>转换回字节码的时候，会有性能问题；</li>
</ul>
</li>
</ul>
<h2 id="2-6-Basic-Blocks-BB"><a href="#2-6-Basic-Blocks-BB" class="headerlink" title="2.6 Basic Blocks (BB)"></a>2.6 Basic Blocks (BB)</h2><p>这部分是为 CFG 服务的；</p>
<p><strong>BB 就是连续的三地址码指令</strong></p>
<ul>
<li>BB 块起始点要求：这些指令在 BB 的第一条指令，必须为 BB 的入口；<ul>
<li>入口只能有一个；</li>
<li>出口只能有一个；</li>
<li>满足这两个条件的，可以为一个 BB 块；</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230915155013.png"
                     
                ></li>
</ul>
</li>
<li>比如当出现 goto 的时候，其出口已经不止一个了，所以此时有两个出口，出现 goto 的时候可以进行切分，往上的部分为一个 Basic Block；</li>
</ul>
<p><strong>Basic Block 判断方法</strong></p>
<ul>
<li>入口判断<ul>
<li>leader<ul>
<li>指令的开始肯定是入口；</li>
</ul>
</li>
</ul>
</li>
<li>出口<ul>
<li>从入口到出口为 BB；</li>
</ul>
</li>
<li>根据所有的入口以及出口信息，划分不同的 Basic Block；</li>
</ul>
<p><strong>如何在 BB 上建立边？CFG</strong></p>
<h2 id="2-7-Control-Flow-Graphs-CFG"><a href="#2-7-Control-Flow-Graphs-CFG" class="headerlink" title="2.7 Control Flow Graphs (CFG)"></a>2.7 Control Flow Graphs (CFG)</h2><p>CFG 是最终为静态分析器服务的。因为 CFG 作为可达性图，更容易利用图论的知识进行分析；</p>
<ul>
<li>一般 main 作为唯一的一个入口点</li>
<li>但 return 可以有很多个，所以出口点可能会有很多个；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230915162405.png"
                     
                ></li>
</ul>
]]></content>
      <categories>
        <category>静态程序分析</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>静态程序分析</tag>
        <tag>IR</tag>
      </tags>
  </entry>
  <entry>
    <title>【静态程序分析】Lecture 3：Data Flow Analysis 1</title>
    <url>/2023/09/7d009c74b0db.html</url>
    <content><![CDATA[<p>数据流分析：一个十分基础、也十分重要的部分，属于编译器的前端优化的部分；</p>
<ul>
<li>在静态分析当中，数据流分析是十分重要的一部分；<span id="more"></span></li>
</ul>
<h2 id="3-1-Overview-of-Data-Flow-Analysis"><a href="#3-1-Overview-of-Data-Flow-Analysis" class="headerlink" title="3.1 Overview of Data Flow Analysis"></a>3.1 Overview of Data Flow Analysis</h2><p><strong>How Data Flows on CFG</strong></p>
<p><strong>may analysis 目的</strong></p>
<ul>
<li>输入可能为真的所有信息； -&gt; over</li>
<li>Over-approximations</li>
</ul>
<p><strong>must analysis 目的</strong><br>输出那些信息，必须为真；</p>
<p>两者目的：Over - and under-approximations are both for safety of analysis；-&gt; under</p>
<ul>
<li>都是为了分析的结果安全，正确；</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230918202053.png"
                     
                ></li>
</ul>
<p><strong>不同的数据流分析，会有不同的数据抽象来进行应用</strong><br>进而定义不同的转化函数；</p>
<h2 id="3-2-Preliminaries-of-Data-Flow-Analysis"><a href="#3-2-Preliminaries-of-Data-Flow-Analysis" class="headerlink" title="3.2 Preliminaries of Data Flow Analysis"></a>3.2 Preliminaries of Data Flow Analysis</h2><p>数据流分析当中基本的概念知识；</p>
<h3 id="3-2-1-基础符号"><a href="#3-2-1-基础符号" class="headerlink" title="3.2.1 基础符号"></a>3.2.1 基础符号</h3><p><strong>输入与输出状态</strong></p>
<ul>
<li>Each execution of an IR statement transforms An input state to a new output state</li>
<li>用 <code>IN[s1]</code> 来表示 s 1 的输入；</li>
<li>用 <code>OUT[s1]</code> 来表示 s1 的输出；</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230918202405.png"
                     
                ></p>
<p><strong>连接操作</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230918212926.png"
                     
                ></p>
<p><strong>分支操作</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230918212941.png"
                     
                ></p>
<p><strong>汇聚操作</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230918213022.png"
                     
                ></p>
<h3 id="3-2-2-分析应用符号"><a href="#3-2-2-分析应用符号" class="headerlink" title="3.2.2 分析应用符号"></a>3.2.2 分析应用符号</h3><blockquote>
<p>In each data-flow analysis application, we associate with every Program point a data-flow value that represents an abstraction of the Set of all possible program states that can be observed for that point.</p>
</blockquote>
<p>在数据流当中，使用并留存下来的数据，只有哪些在后续数据分析当中会使用到的抽象数据，而不需要给出所有的具体数据；</p>
<p><strong>Domain</strong><br>The set of possible data-Flow values is the domain For this application；</p>
<ul>
<li>值域：当前每个 Node 的数值的值域；</li>
</ul>
<p>数据流分析就是找到一个解决方法，通过解析一系列的基于转化的约束规则，最后得到一个结论，关联一个 DataFlow 关系；</p>
<p><strong>Forward Analysis</strong><br>按照顺序，向下分析； -&gt; 前向分析；<br>公式：OUT[s] &#x3D; fs (IN[s])  -&gt; 表达以下过程：s 的输出，是由转换的函数 fs 导致的；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230918213724.png"
                     
                ></p>
<p><strong>Backward Analysis</strong><br>逆向分析；向上分析（反向分析）；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230918213842.png"
                     
                ></p>
<h3 id="3-2-3-数据流约束表示"><a href="#3-2-3-数据流约束表示" class="headerlink" title="3.2.3 数据流约束表示"></a>3.2.3 数据流约束表示</h3><p><strong>一个 Basic Block 之内的</strong><br>Basic Block：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230918214127.png"
                     
                ><br>构建出的关系：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230918214105.png"
                     
                ></p>
<p><strong>多个 BB 之间</strong><br>对 B 这个 BB 当中的每个 statement，都求其 IN 的来源，回溯答案；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230918214349.png"
                     
                ></p>
<p>输出时有多个分支：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230918214551.png"
                     
                ></p>
<h2 id="3-3-Reaching-Definitions-Analysis"><a href="#3-3-Reaching-Definitions-Analysis" class="headerlink" title="3.3 Reaching Definitions Analysis"></a>3.3 Reaching Definitions Analysis</h2><p><strong>可达性定义分析</strong></p>
<blockquote>
<p>Definition d at program point p reaches a point q if there is a path From p to q such that d is not “killed” along that path</p>
</blockquote>
<p>有一个变量，定义 v 在一段域 d 当中，定义能否从 p 达到另外的 q 一点；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../image/Pasted%20image%2020230920183758.png"
                     
                ></p>
<ul>
<li>要求<ul>
<li>v 不可以重复定义，中间的数值不可以被 v 拦截；</li>
<li>中间的 v 不可以有重复的；</li>
</ul>
</li>
</ul>
<p><strong>可达性定义分析作用</strong><br>可达性分析可以用于检测是否有可能的未定义变量；</p>
<ul>
<li>比如：当前有一个未定义的变量 v 位于 CFG 的进入点，如果这个 v 到达了点 p 并且 v 是被使用的，那 v 就可能有一条路径是没有被定义的；</li>
<li>有一条 path，到达 p 的时候，v 这个点可能没有被初始化，即 v 有一条可能是一个未定义的变量；</li>
</ul>
<p><strong>如何理解可达性定义分析</strong><br>加入有 100 个 bit 定义，要抽象出关注的数据；</p>
<h2 id="3-4-Live-Variaples-Analysis"><a href="#3-4-Live-Variaples-Analysis" class="headerlink" title="3.4 Live Variaples Analysis"></a>3.4 Live Variaples Analysis</h2><h2 id="3-5-Available-Expressions-Analysis"><a href="#3-5-Available-Expressions-Analysis" class="headerlink" title="3.5 Available Expressions Analysis"></a>3.5 Available Expressions Analysis</h2>]]></content>
      <categories>
        <category>静态程序分析</category>
      </categories>
      <tags>
        <tag>静态程序分析</tag>
      </tags>
  </entry>
  <entry>
    <title>【商业系列】商业计划书大纲与内容</title>
    <url>/2023/08/efa8d1f054ea.html</url>
    <content><![CDATA[<p><strong>商业计划书大纲</strong></p>
<ul>
<li>1、 团队简介</li>
<li>2、 项目内容</li>
<li>3、 团队组成</li>
<li>4、 市场规模与分析</li>
<li>5、 商业模式</li>
<li>6、 战略规划<span id="more"></span></li>
</ul>
<h1 id="1-内容大纲"><a href="#1-内容大纲" class="headerlink" title="1.内容大纲"></a>1.内容大纲</h1><ul>
<li>1、 团队简介</li>
<li>2、 项目内容<ul>
<li>1、项目介绍</li>
<li>2、核心优势</li>
</ul>
</li>
<li>3、 团队组成</li>
<li>4、 市场规模与分析<ul>
<li>1、 市场分析</li>
<li>2、 竞品分析</li>
</ul>
</li>
<li>5、 商业模式<ul>
<li>1、 商业模式介绍</li>
<li>2、 相关数据</li>
</ul>
</li>
<li>6、 战略规划<ul>
<li>1、 战略目标</li>
<li>2、 实现路径</li>
</ul>
</li>
</ul>
<h1 id="2-各部分编写思路"><a href="#2-各部分编写思路" class="headerlink" title="2.各部分编写思路"></a>2.各部分编写思路</h1><h2 id="2-1-团队简介"><a href="#2-1-团队简介" class="headerlink" title="2.1 团队简介"></a>2.1 团队简介</h2><p><strong>内容构成</strong>：一句话介绍 + 50~100字团队简介</p>
<p><strong>一句话介绍</strong><br>内容尽可能简短、清晰，直接了当的了解当前团队的：</p>
<ol>
<li>核心业务内容</li>
<li>核心优势</li>
</ol>
<p><strong>团队简介</strong><br>简要介绍团队业务以及数据规模等内容；</p>
<h2 id="2-2-项目内容"><a href="#2-2-项目内容" class="headerlink" title="2.2 项目内容"></a>2.2 项目内容</h2><h3 id="2-2-1-项目介绍"><a href="#2-2-1-项目介绍" class="headerlink" title="2.2.1 项目介绍"></a>2.2.1 项目介绍</h3><p><strong>编写内容核心</strong><br>把此业务最吸引人、最有发展潜力的部分展现出来；</p>
<ul>
<li>分析方法<ul>
<li>简介：先确定此项目属于哪一种类型，然后再根据此类型的核心点，编写文字内容</li>
<li><ol>
<li>增长型项目（还没开始或刚开始）</li>
</ol>
<ul>
<li>侧重增长，大量数据放在此项目板块的<strong>发展潜力以及我们的优势</strong>上面</li>
</ul>
</li>
<li><ol start="2">
<li>运营型项目（已经开始）</li>
</ol>
<ul>
<li>侧重盈利，大量文字放在介绍当前流量的<strong>转化率以及盈利能力</strong>上</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>图片展示</strong><br>技术型项目给出吸引人的文字图片内容，吸引浏览者观看；</p>
<h3 id="2-2-2-核心优势"><a href="#2-2-2-核心优势" class="headerlink" title="2.2.2 核心优势"></a>2.2.2 核心优势</h3><p><strong>分析方法</strong><br>分析目前团队的开发能力当中，和竞品相比最具有优势的部分；</p>
<ul>
<li>流量矩阵：<ul>
<li>自媒体流量（自带宣传流量）</li>
<li>开发团队（丰富开发经验）</li>
<li>项目案例（Unity3D）</li>
</ul>
</li>
</ul>
<h2 id="2-3-团队组成"><a href="#2-3-团队组成" class="headerlink" title="2.3 团队组成"></a>2.3 团队组成</h2><p><strong>分析方法</strong><br>根据核心优势部分分析的结果，部分的去过滤团队介绍部分所需要呈现的内容；<br>只呈现优势的一面，劣势或不加分的一面要慎重描写</p>
<h2 id="2-4-市场规模与分析"><a href="#2-4-市场规模与分析" class="headerlink" title="2.4 市场规模与分析"></a>2.4 市场规模与分析</h2><h3 id="2-4-1-市场分析"><a href="#2-4-1-市场分析" class="headerlink" title="2.4.1 市场分析"></a>2.4.1 市场分析</h3><p><strong>数据采集</strong><br>要有明确、清晰的数据来源<br>在此数据来源之上，筛选出对项目有利的信息</p>
<ul>
<li>真实的数据，但是是部分的真实</li>
</ul>
<h3 id="2-4-2-竞品分析"><a href="#2-4-2-竞品分析" class="headerlink" title="2.4.2 竞品分析"></a>2.4.2 竞品分析</h3><p><strong>竞品确定</strong><br>竞品不一定得是完全相同的行业，重点是商业的逻辑；<br>确定一个牛逼的竞品，即展示当前项目天花板很高，然后再分析当前项目所处市场以及再哪些地方超越了竞品。</p>
<h2 id="2-5-商业模式"><a href="#2-5-商业模式" class="headerlink" title="2.5 商业模式"></a>2.5 商业模式</h2><p><strong>什么是商业模式</strong></p>
<ol>
<li>项目如何盈利？</li>
<li>项目的流量模式？</li>
<li>获客转化的路径？</li>
<li>是否具有可持续性？</li>
<li>增长的空间以及可能？</li>
</ol>
<p><strong>内容编写</strong><br>基于业务本身的内容，对模式进行介绍；</p>
<h2 id="2-6-战略规划"><a href="#2-6-战略规划" class="headerlink" title="2.6 战略规划"></a>2.6 战略规划</h2><p><strong>内容</strong></p>
<ol>
<li>确定战略目标，展现当前项目的发展前景</li>
<li>确定项目发展的实现路径，并且确定不同情况下的风险预案</li>
</ol>
]]></content>
      <categories>
        <category>商业</category>
      </categories>
      <tags>
        <tag>商业</tag>
        <tag>创业</tag>
      </tags>
  </entry>
  <entry>
    <title>【法理学】Lecture 1：何为法律</title>
    <url>/2023/09/a6275619b200.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h2 id="1-1-哲学上的定义"><a href="#1-1-哲学上的定义" class="headerlink" title="1.1 哲学上的定义"></a>1.1 哲学上的定义</h2><p><strong>什么是法律：哲学上的定义</strong><br>学术定义：以国家强制力保证的、上升为国家意志（统治阶级的意志体现）的法律；</p>
<ul>
<li>国家<ul>
<li>表示的是统治阶级的意志；</li>
</ul>
</li>
<li>强制力<ul>
<li>必须要依靠暴力来进行最后的支撑（最后）；</li>
<li>虽然一直在宏观的文明、道德之上，分析法律，但法律到最后一步一定会以暴力作为支撑；</li>
</ul>
</li>
</ul>
<h2 id="1-2-操作上的定义"><a href="#1-2-操作上的定义" class="headerlink" title="1.2 操作上的定义"></a>1.2 操作上的定义</h2><p><strong>什么是法律：操作上的定义</strong><br>由国家的权力机关指定的、由法院适用的、执法机关实际执行的规则或者说社会规范。</p>
<ul>
<li>人大<ul>
<li>人大不只是立法机关，也是最高权力机关；</li>
<li>和国外不一样：美国国会是立法机关，但不是权力机关；</li>
</ul>
</li>
<li>立法机关<ul>
<li>全国人大制定的；各级人大、司法机构；</li>
<li>按照立法机关，按照它的流程制定的、文字和其他符号形式的一般性的行为规则；</li>
<li>规则的一般性：一般是不能针对某一个人来制定规则；但是也会收到一些经验上的挑战：汶川地震、奥运会、疫情，出台的专门的法律；</li>
</ul>
</li>
<li>其他机关 <ul>
<li>其他有权力的权力机关也可能会制定规则</li>
<li>政府的行政命令；</li>
<li>外交部的外交权力；</li>
<li>地方规章</li>
</ul>
</li>
<li>法官造法<ul>
<li>在实践生活当中创建出法律；<ul>
<li>很多英美的法律都是由法官创造出来的；</li>
</ul>
</li>
<li>对案例、经验进行解释，扩大定义；<ul>
<li>通过一次次的实践，把定义扩大或缩小；</li>
</ul>
</li>
<li>英美法系很看重过去的法律判决；</li>
<li><strong>遵循先例制度</strong>：可以根据以往的类似的案例来对现在自己的案例，进行重新判例；<ul>
<li>判决书是一次使用的，但法律是多次适用的；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-3-法律与习惯法"><a href="#1-3-法律与习惯法" class="headerlink" title="1.3 法律与习惯法"></a>1.3 法律与习惯法</h2><p><strong>什么是习惯法</strong><br>习惯就是条规则，你必须遵守。它曾经有道理，但被人遗忘；</p>
<ul>
<li>许多法律就是对习惯法的确定；</li>
<li>很多现在法律的理解，其实是根据习惯法而来的； <ul>
<li>法律当中的很多概念都是习惯而来的；</li>
<li>习惯是由社会生活来界定的；</li>
</ul>
</li>
<li>中国的法官，面对广大的社会群众，必须了解其中的规则、习惯，而不只是法律；<ul>
<li>界定法一定不能涵盖所有情况；</li>
</ul>
</li>
</ul>
<p><strong>情理与法理</strong><br>法理和情理是同一个事情；</p>
<ul>
<li>法理只不过是法学家把这件事情说清楚了而已；<ul>
<li>把道理讲清楚才能是法理；</li>
</ul>
</li>
<li>例子：彩礼钱能不能退<ul>
<li>国家之前不支持：买卖婚姻</li>
<li>但彩礼更像定金</li>
<li>传统社会下的彩礼制度</li>
</ul>
</li>
</ul>
<h2 id="1-4-自然法"><a href="#1-4-自然法" class="headerlink" title="1.4 自然法"></a>1.4 自然法</h2><p><strong>哲学上的定义：永恒不变的理性、世界永恒不变的规则，并且所有制定法律必须符合最基本的规则</strong></p>
<p><strong>经验上的定义：广大的社会，长期稳定、主流的存在法</strong></p>
<ul>
<li>其实就是习惯法；</li>
<li>在中国古代就是天理；自然法；<br>优点：</li>
<li>对于自由、平等等等品质，保证；</li>
<li>因为自然界不是如此；</li>
</ul>
<p><strong>自然法在现代的主要继承人：人权</strong></p>
<ul>
<li>言论自由</li>
<li>宗教信仰自由</li>
</ul>
<p><strong>对自然法的批判</strong></p>
<ul>
<li>最大的问题：自然被赋予了道德色彩；<ul>
<li>但自然不是一个道德的自然；</li>
<li>自然就是自然，但在现在却具有以下功能</li>
</ul>
</li>
<li>道德的功能：<ul>
<li>修辞功能</li>
<li>压迫功能：自然法用来打击女性，少性族裔；</li>
</ul>
</li>
<li>自然法并不是给你个用于正确的观念来确定的；<ul>
<li>最开始的自然：上帝之爱</li>
<li>达尔文主义的自然：弱肉强食</li>
</ul>
</li>
<li>而且自然法能解决的领域有限<ul>
<li>刑法、民法还可以使用</li>
<li>商法、知识产权等等法律都无法使用自然法解决<ul>
<li>很多都是一个技术问题，不是用道德的观点可以解决的；</li>
</ul>
</li>
<li>自然法 <ul>
<li>直接和人的感受有关联</li>
<li>甚至很多不是和思维有关，而是和身体有关</li>
</ul>
</li>
</ul>
</li>
<li>生命政治：很多的真理其实是身体的产物<ul>
<li>所有的真理其实是身体的产物，和其生命力的旺盛有很大的关系；</li>
<li>身体 -&gt; 容器 -&gt; 感觉 -&gt; 思维 -&gt; 符号 -&gt; 主义</li>
<li>在这当中，没有柏拉图式的、原子意义上的、精神上具有神性的、不可分的、小写的“人”；</li>
</ul>
</li>
</ul>
<p><strong>和职业性的法律关系不大</strong></p>
<ul>
<li>可以帮助我们，用一个正常人的心态来思考某些问题；</li>
<li>自然法反对法律的职业化，专业化；</li>
</ul>
<h2 id="1-5-法律与裁量"><a href="#1-5-法律与裁量" class="headerlink" title="1.5 法律与裁量"></a>1.5 法律与裁量</h2><p><strong>法律并不只是具体的、细则的规则，还可能是一定范围内的自由裁量</strong></p>
<ul>
<li>即使是非常细的规则，也可以有裁量权；</li>
<li>裁量权不是和法律无关的事情。执法者、立法者都可能会有裁量；</li>
</ul>
<p>重点不在于 ought to be，而在于 to be</p>
<p><strong>为什么要争法律定义？</strong><br><strong>法律人是要爱自己的理想，还是爱这个国家上土地，以及土地上的人民</strong><br><strong>学术上的争辩是思维游戏，但是一旦思维走进现实，就会变成利益之争。定义之争就是利益之争</strong></p>
]]></content>
      <categories>
        <category>人文课程</category>
        <category>法理学</category>
      </categories>
      <tags>
        <tag>法理学</tag>
        <tag>法律</tag>
        <tag>人文</tag>
      </tags>
  </entry>
  <entry>
    <title>【法理学】Lecture 2：法律的功能与特点</title>
    <url>/2023/09/31623ee61574.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h2 id="2-1-什么是功能"><a href="#2-1-什么是功能" class="headerlink" title="2.1 什么是功能"></a>2.1 什么是功能</h2><p><strong>什么是功能</strong><br>这里的功能，指的是其实际上起的作用，而不是概念上起的作用；</p>
<ul>
<li>法律经常发挥不到，其意图中的作用</li>
<li>所以法律系统，<strong>在社会当中实际起到的作用，就是法律的功能</strong></li>
<li>法律实际上起到的作用，很难用函数式的因果关系来进行作用的推导；<ul>
<li>任何一个因素：经济、文化等等，都可能会影响法律的作用；</li>
</ul>
</li>
<li>例子：劳动合同法<ul>
<li>目的：为了使得劳动中”弱势者”</li>
<li>当时一个法律：无固定期限劳动合同<ul>
<li>当工作一定时间之后，必须签订无固定期限劳动合同；</li>
<li>在很多法律学家看来这是对的，但其他领域的人不一定这么看；</li>
</ul>
</li>
<li>法律的前提：雇主是强势地位，劳动是弱势地位<ul>
<li>保护了相对强势的群体；</li>
<li>雇员和雇员之间，也有强势弱势的关系；</li>
</ul>
</li>
</ul>
</li>
<li>意图产生的事情和实际产生的效果不一样；<ul>
<li>看其实际在经验生活中的作用；</li>
<li>比如生活中有很多机会主义者；</li>
</ul>
</li>
</ul>
<p><strong>功能主义</strong><br>不讲究因果关系，只要社会有需求，就给出某种东西；</p>
<h2 id="2-2-法律第一功能：维护秩序"><a href="#2-2-法律第一功能：维护秩序" class="headerlink" title="2.2 法律第一功能：维护秩序"></a>2.2 法律第一功能：维护秩序</h2><p><strong>法律起到什么功能？</strong></p>
<ul>
<li>最核心的功能：法律最根本的不是维护权利，而是维护秩序；<ul>
<li>法律不是为了个人使用的，法律是为了整个社会使用的；</li>
<li>使得个人能够实现个人的预期；</li>
<li>如果社会没有秩序，则个人的价值创建将不存在；</li>
<li>所以法律比较难处理突发危机：疫情、地震、金融危机；</li>
</ul>
</li>
<li><strong>法律使得社会生活保证秩序</strong>；<ul>
<li><strong>社会的意义系统，来自于社会的结构性内容</strong>；</li>
<li><strong>意义与结构的关系</strong></li>
</ul>
</li>
<li>法律保证社会生活有预期。有预期是意义系统的构建结果，体现的是社会的结构；</li>
</ul>
<h3 id="2-2-1-意义与结构"><a href="#2-2-1-意义与结构" class="headerlink" title="2.2.1 意义与结构"></a>2.2.1 意义与结构</h3><p><strong>意义的产生来源于社会结构</strong><br>社会的结构会符号化程象征届的语言体系，这些体系通过想象界的转喻机制成为人身体的机能反应；<br>社会结构构建的意义产生了预期：法律保护这些预期；</p>
<p><strong>社会结构|秩序的保证来源</strong></p>
<ul>
<li>法律<ul>
<li>只是给哪些无法执行的东西，给与一个国家的强制力，给予执行；</li>
<li><strong>法律只有在社会比较常规的状态下才能起作用</strong>；</li>
</ul>
</li>
<li>人与人的新任</li>
<li>个体的暴力</li>
<li>技术</li>
<li>习惯</li>
</ul>
<p><strong>法律与结构的关系</strong><br>先是有社会结构的变化，再有法律跟进的变化；<br>法律维护预期的秩序；</p>
<ul>
<li>法律是回应社会生活的；</li>
</ul>
<h2 id="2-3-法律第二功能：界定权利-产权"><a href="#2-3-法律第二功能：界定权利-产权" class="headerlink" title="2.3 法律第二功能：界定权利|产权"></a>2.3 法律第二功能：界定权利|产权</h2><p><strong>产权</strong></p>
<ul>
<li>产权不是财产权，而是指得个人的权利；</li>
</ul>
<p><strong>人的潜在需求是远大于社会产出</strong></p>
<ul>
<li>社会的产值是有限的，但人的潜在需求是无限的；</li>
<li>需要对权利进行界定；<ul>
<li>人的资源：也在随着时间变化</li>
</ul>
</li>
</ul>
<p><strong>为什么要对权利进行界定</strong></p>
<ul>
<li>当不对基本的原则|权利进行界定时，当两个人发生冲突的时候，最终的选择是由<strong>个人力量的大小</strong>来得到的；</li>
<li>因此，国家收取个人的部分权利，通过暴力机关，执行权利；<ul>
<li>所以文字本身是没有力量的；</li>
</ul>
</li>
<li><strong>没有公权力时，裁决主要通过个人力量来达成</strong>；</li>
</ul>
<p><strong>补充：权利的保护是需要达到一定数额的</strong><br>在一定的金额、数量下，才可以立案；</p>
<ul>
<li>法律不是保护一切权利；</li>
<li>有法律公权力界定比较大的、重要的产权；</li>
</ul>
<p><strong>界定权利的作用</strong></p>
<ul>
<li>作用一：<ul>
<li>可以帮助公民更加充分的配置资源；</li>
<li>使得资源更为有效的使用；</li>
</ul>
</li>
<li>作用二：<ul>
<li>可以界定资源是否有用，进而</li>
<li>支持资源的转让 -&gt; 社会资源更加有效的使用 -&gt; 贸易进而可以出现；</li>
</ul>
</li>
<li>作用三：<ul>
<li>使得交易可以出现，并且使得交易费用降低；</li>
<li>但是：当交易费用超过交易物品价值本身时，就无法产生交易；</li>
<li>产权界定清晰时，可以降低交易费用；</li>
</ul>
</li>
</ul>
<h2 id="2-4-法律的特点"><a href="#2-4-法律的特点" class="headerlink" title="2.4 法律的特点"></a>2.4 法律的特点</h2><p>概念性总结：<strong>普遍性、公平性、稳定性、保守性</strong>；</p>
<p><strong>法律特点一：虽然法律是维护个人权利而使用的，但从总体而言，法律是一种天下之公平</strong></p>
<ol>
<li>维护整个社会的秩序；使得社会可以有预期，使得人民可以进行各种投资：智力投资、经济投资；</li>
<li>针对普遍性的世界；在不同的人、事件之间都可以进行使用；</li>
</ol>
<ul>
<li><strong>法律不是为了维护某一个人的权利。而是为了维护整个社会的秩序。</strong></li>
<li><strong>例子：从一而忠</strong><ul>
<li>在古代社会，虽然对女子要求从一而忠，使得女子丧失了尊严，但也保护了女性的生活权利；</li>
<li>对于哪些没有任何资产的女性，从一而终相当于是一种保险；</li>
</ul>
</li>
</ul>
<p><strong>法律特点二：普遍性与保守性</strong><br>虽然需要通过法律来通过改革，但法律是为了维护稳定 -&gt; 稳定也就代表了保守；</p>
<ul>
<li>法律经常修改 -&gt; 代表了法律没有作用；</li>
</ul>
<p><strong>马克思的观点：法律就是对现状加以神圣化</strong></p>
<ul>
<li>法律人要以普通人的角度进行思考</li>
</ul>
<p><strong>法律特点三：法律是暴力</strong></p>
<ul>
<li>法律的所有实行，最终都可能需要暴力进行支撑；</li>
<li>举例：法律判决的判决书<ul>
<li>对于当事人而言，判决书更多不是体现的法律本身语义；</li>
<li>更多是体现法律背后的暴力；</li>
</ul>
</li>
</ul>
<p><strong>法律特点四：法律关注人们的行为，不关注人们的想法</strong></p>
<ul>
<li>法律规制人们的行为，而不在乎人们心中的想法<ul>
<li>关注的是人们日常行为的稳定性；</li>
<li>规制的是人们会影响到他人的行为；</li>
</ul>
</li>
<li>结论：-&gt; 法律其实是尽可能最大保留人们的自由，只要它不影响他人；</li>
</ul>
<h2 id="2-5-后果主义"><a href="#2-5-后果主义" class="headerlink" title="2.5 后果主义"></a>2.5 后果主义</h2><p><strong>海德格尔：任何法律都需要在社会生活中证明其合法性</strong><br>通过有效来进行证明；</p>
<p><strong>英美法：救济先于权利</strong><br>社会如果先可以进行救济，那就先进行救济；<br>救济实现不了时，在保证基本权利；</p>
<ul>
<li>这实际上就是一种后果主义</li>
<li>先考虑后果，再从法律条文当中去找对应的法律，看能不能支持这种后果；</li>
</ul>
<p><strong>后果主义例子：王海”知假打假”案</strong><br>王海知道货物是假货，还去买假货，还上诉要求赔偿；</p>
<ul>
<li>消费者权益保护法：消费者是为了消费而购买的才是消费者</li>
<li>王海不符合消费者的定义；但是因为给予赔偿的后果更好，因此依然把定义进行扩充，让王海进行胜诉；</li>
<li>后果主义；</li>
</ul>
<p><strong>真实世界的律师和法官都是从后果主义的角度来思考的</strong></p>
<ul>
<li>真实世界的人是基于后果来考虑的；</li>
</ul>
]]></content>
      <categories>
        <category>人文课程</category>
        <category>法理学</category>
      </categories>
      <tags>
        <tag>法理学</tag>
        <tag>人文</tag>
        <tag>后果主义</tag>
      </tags>
  </entry>
  <entry>
    <title>【法理学】Lecture 5：自由主义与个人主义</title>
    <url>/2023/09/d7479f1fa30b.html</url>
    <content><![CDATA[<p>讲解一些法律的基本理论；</p>
<ul>
<li>现代的法律，基本上是按照自由主义发展出来的；</li>
<li>并且自由主义和现代的生活紧密联系在一起；<span id="more"></span></li>
</ul>
<h2 id="5-1-基本观点"><a href="#5-1-基本观点" class="headerlink" title="5.1 基本观点"></a>5.1 基本观点</h2><p><strong>个人生活优先，强调个人权利、人权</strong><br>对于现代社会当中的各个需要的法律部分，都有着系统的理论**</p>
<p><strong>基本观点：人人生来自由，并且也追求自由</strong><br>这<strong>不是一个经验命题</strong>，而这是一个假定；</p>
<ul>
<li>生来不自由和生来自由，都可以作为假定；</li>
<li>自由主义只是以此为假定，进行推导，然后建构出一套理论体系；</li>
<li>由此推导出人的自然权利，这种自然权利其实没有褒义与贬义；</li>
<li>因为人人都可以追求自由，人都有这种本能的欲望，在这种渴望的起点上 -&gt; 追求自由是平等的-&gt; 人是平等的；<ul>
<li>普遍的人权；</li>
<li>同时人并不完美；</li>
</ul>
</li>
</ul>
<p><strong>几个前提</strong></p>
<ul>
<li>人和人之间的联系<ul>
<li>虽然是以个人为前提，但个人是不完美的，个人的生存、繁衍都需要和他人进行合作；</li>
</ul>
</li>
<li>人和人之间拥有智力、体力等的差异<ul>
<li>所有动物都平等，但有些动物更平等；</li>
<li><em>让羊和狮子都平等，实际上就是对于狮子的不平等</em>；</li>
<li>因此出现以弱欺小 -&gt; 问题；</li>
</ul>
</li>
</ul>
<h3 id="5-1-1-自由状态推演致自由主义"><a href="#5-1-1-自由状态推演致自由主义" class="headerlink" title="5.1.1 自由状态推演致自由主义"></a>5.1.1 自由状态推演致自由主义</h3><p><strong>产生的问题</strong><br>不受约束的自由，可能会导致所有人对所有人的战争；</p>
<ul>
<li>自由需要收到约束<ul>
<li>完全自然权利的状态并不好；</li>
<li>按照行驶自由权利进行，会导致大量的冲突；</li>
</ul>
</li>
<li>为了使得个人拥有更大的自由，因此需要签订社会契约<ul>
<li>社会契约论也只是一个理论上的假定，并不是真正谁和谁签订契约；</li>
<li>成立社会与国家；</li>
</ul>
</li>
<li>国家的最低责任和最高责任，都是保护个人的自由，使得每个人都享有同等的权利，并且不产生冲突时，达成社会的最大自由；<ul>
<li>生命、安全、财产 -&gt; 最基本的权利 -&gt; 不可转让的权利 -&gt; 可以转让的权利就是可以贬值的权利；</li>
</ul>
</li>
<li>所以需要保障基本权利<ul>
<li>自由 &lt;-&gt; 法制</li>
<li>两者紧密相连；</li>
</ul>
</li>
<li>过大的自由<ul>
<li><em>过大的自由可能会导致社会上缺少价值判断</em></li>
<li>过大的自由会导致个人主义 -&gt; 每个人有追求自由的平等 &amp; 每个人都能充分完全自由 &amp; 每个人的自由的价值一致 -&gt; 完全个人主义；<ul>
<li>大家完全一样；无法对个人的偏好进行评价，从个人评价而言都是一致的 -&gt; 国家和每个人就应该对每一个人的偏好尽可能保持满足；</li>
<li>这是一种多元主义；</li>
</ul>
</li>
</ul>
</li>
<li>对求整个社会的更大的自由 -&gt; 制度主义；<ul>
<li>国家有义务，提供一种可能性，保证每个人尽可能更大的平等的自由 -&gt; 福利主义国家；<ul>
<li>出现弱势群体 -&gt; 为弱者的援助；</li>
<li>新自由主义者 -&gt; 强调个人福利的自由主义者；<ul>
<li>奥巴马的医疗法案；</li>
</ul>
</li>
</ul>
</li>
<li><strong>中国从 90 年代的自由主义，到现在的转向大国家的福利主义，甚至福利社会主义</strong></li>
</ul>
</li>
</ul>
<h3 id="5-1-2-两种自由主义"><a href="#5-1-2-两种自由主义" class="headerlink" title="5.1.2 两种自由主义"></a>5.1.2 两种自由主义</h3><p><strong>自由和平等的价值问题</strong><br>就社会形态上说：自由和平等是无法兼容的；</p>
<ul>
<li>自由指的是追求个人权利，是自由的；</li>
<li>但每个人之间的条件、状态不一样 -&gt; 同等的去追求自由，就会不平等；</li>
<li>想要平等 -&gt; 社会福利、保障制度，弥补不平等 -&gt; 大政府福利制度 -&gt; 不自由；</li>
<li><strong>因为自由竞争就是会导致更大的不平等</strong>；<ul>
<li>导致贫富差距越来越大 -&gt; 自由主义认为这没什么问题；</li>
</ul>
</li>
</ul>
<p><strong>古典自由主义</strong><br>古典自由主义承认以上问题：自由导致的更大的不平等；</p>
<ul>
<li>古典自由主义认为，国家的最低责任和最高责任，都是保护个人的自由，使得每个人都享有同等的权利；</li>
<li>国家只提供最基本的社会保障，然后让个人去充分竞争 -&gt; 市场经济；<ul>
<li>国家保证基本权利，不相信革命可以改变制度 -&gt; 制度是由社会慢慢发展而来的；<ul>
<li>承认一些坏的不平等，只要这是社会自然发展出俩的；<strong>古典保守主义</strong></li>
<li>不相信通过立法、福利来改变社会；</li>
</ul>
</li>
<li>不相信革命：认为革命只是一段时间把这些东西打乱了，然后过段时间就重新慢慢发展出来；</li>
</ul>
</li>
<li>古典自由主义是一种变色龙，拥有很多变化；</li>
</ul>
<p><strong>古典自由主义与新自由主义对比</strong></p>
<ul>
<li>古典自由主义<ul>
<li>相信市场经济；</li>
<li>相信政府少干预；</li>
<li>公民有更多自由去创造；</li>
</ul>
</li>
<li>新自由主义 <ul>
<li>要对自由主义进行更多的干预；</li>
<li>保护民生，注重社会福利；</li>
<li>基本上就是服务少部分利益<ul>
<li>大的企业家</li>
<li>少数族裔</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-2-自由与法制的关系"><a href="#5-2-自由与法制的关系" class="headerlink" title="5.2 自由与法制的关系"></a>5.2 自由与法制的关系</h2><p><strong>观点一：自由主义既是起点，也是终点</strong></p>
<p><strong>观点二：所有东西不是为了社会，而是为了个人的自由</strong><br>因为要满足个人的自由，因此需要社会、政府。保障个人的自由；</p>
<p><strong>观点三：需要法制，因为需要法制来限制政府，使得个人拥有更大的自由</strong><br>强调个人的自由 -&gt; 每个人都有独立的情况下，才可能存在；<br>法制是一个必然且不可缺少的元素；</p>
<ul>
<li>虽然现在我们是社会主义国家，但也有大量自由主义的价值；<ul>
<li>婚姻自由；</li>
<li>宗教自由；</li>
</ul>
</li>
<li>随着各种自由主义的发展，逐渐发展出基本的权利<ul>
<li>普遍的公民权；<ul>
<li>但这不是生来就有的，很长一段时间里面，是根据财产的多少来决定公民权的大小的；</li>
</ul>
</li>
<li>法律面前人人平等；<ul>
<li>三个最重要的基本权利：<strong>生命、安全、财产</strong>；</li>
</ul>
</li>
<li>这些都是自由主义原则推导出来的<ul>
<li>受教育、劳动等等权利，都是发展出来的；</li>
<li>言论自由；<ul>
<li>从来都没有绝对的言论自由；</li>
</ul>
</li>
<li>罪刑法定</li>
<li>私有财产神圣不可侵犯；</li>
<li>契约自由</li>
<li>无论如何：不能干涉那些仅仅干扰自己的自由<ul>
<li>不明显产生伤害；</li>
<li>发表言论的时候，或多或少都可能对他人产生影响；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>政治制度</strong></p>
<ul>
<li>直接民主与代议制民主</li>
<li>三权分立；</li>
<li>法院；</li>
<li>联邦主义；<ul>
<li>大政府太可怕，所以地方的政府都拥有一定的权利；</li>
</ul>
</li>
<li>法制</li>
</ul>
<h3 id="5-2-1-自由的概念在不同国家的理解"><a href="#5-2-1-自由的概念在不同国家的理解" class="headerlink" title="5.2.1 自由的概念在不同国家的理解"></a>5.2.1 自由的概念在不同国家的理解</h3><p>从历史上来，一直都是有概念上的讨论；<br>现在大部分都接受的英美的观点；</p>
<ul>
<li>英美的法律更加容易接受；</li>
<li>德国的法律对于民主的素质要求过高；</li>
<li>法国的法律容易将暴政合理化；</li>
<li>但都强调了：自由是在法律之下完备的，并且法律是普遍立法，以人为目的</li>
</ul>
<p><strong>英美传统的自由</strong></p>
<blockquote>
<p>是一种基于经验给出的观点，基于英国逐渐百年形成的自由；<br>因为自由会发出冲突，所以自由在制度之下；</p>
</blockquote>
<p>你不干涉我，我也不干涉你；<br>并不是完全的随心所欲，因此需要建立国家。<br>在英美国家当中，建立国家的时候，认为个人放弃了两项自由：</p>
<ol>
<li>立法权</li>
<li>行政权</li>
</ol>
<ul>
<li>决定做什么事情的权利 -&gt; <strong>立法权</strong><ul>
<li>司法权被归在了立法权下面；</li>
<li>虽然美国是三权分立，但很多国家都不是；</li>
</ul>
</li>
<li>做什么事情的权利 -&gt; <strong>行政权</strong></li>
</ul>
<p><strong>德国传统的自由</strong></p>
<blockquote>
<p>自由是对必然的认识<br>自由是与人相关的概念 -&gt; 受到原因，因此导致什么样的结果 -&gt; 不是自由的；人要获得自由，是要认识原因进而获得自由的；<br>人在日程生活中，是作为原因产生结果的，因此人拥有自由 -&gt; 原因与结果都是被观测出来的结果，但决定观测什么，是人的自由；<br>根据人的目的，做出一个符合必然的、符合道德律的选择，这是才是自由的；</p>
</blockquote>
<ul>
<li>自目的的和目的性；<ul>
<li>原因和结果会引发出机械论的问题；</li>
<li>但机械论的过程，实际上是人解释的结果；</li>
<li>因此会什么进行解释，实际上是人提供的原因<ul>
<li>人提供的原因 -&gt; 基于价值的原因，做出对于原因的假设 -&gt; 生理性的存在与符号系统叠加的结果；</li>
</ul>
</li>
<li>然后由于有解释的动机，此时得出本身就和目的性的结果；<ul>
<li>因为实际上都是语言转喻过程；</li>
</ul>
</li>
</ul>
</li>
<li>道德律与选择<ul>
<li>当做出选择的时候，与道德律的关系</li>
<li>人的自由是：对于道德律的认识后，按照自己的对于道德律的理解，再做出的选择，才是自由的；<ul>
<li>因此康德支持死刑：你是基于自由选择做出的杀人选择，因此在知道这种前提的情况下还去杀人，为了尊准它的选择，因此要杀掉它（私信）；</li>
</ul>
</li>
<li>问题：假设了人是完全理性的动物 -&gt; 抽出了人肉体的前提；</li>
<li>中国人的死刑 -&gt; 基于怜悯产生的</li>
</ul>
</li>
</ul>
<p><strong>法国传统的自由</strong><br>代表人物：卢梭</p>
<ul>
<li>自由是对于自己制定的法律的服从也是<strong>对公意的服从</strong></li>
<li>社会通过社会契约<ul>
<li>公意：代表了群众长期的利益；</li>
</ul>
</li>
<li>因此服从法律是，自己才是自由的<ul>
<li>被法律的制裁不是不自由，遵循被制裁也是自由；</li>
<li>这种公意很容易导致暴政；</li>
</ul>
</li>
<li>很多假定<ul>
<li>社会契约 </li>
<li>能够辨别出公意 -&gt; 一种抽象的人类理性；</li>
</ul>
</li>
</ul>
<h3 id="5-2-2-自由与社会的概念"><a href="#5-2-2-自由与社会的概念" class="headerlink" title="5.2.2 自由与社会的概念"></a>5.2.2 自由与社会的概念</h3><p><strong>自由是关于社会的概念，不只是完全个人的概念</strong><br>自由的界定总是社会状态下进行的推导；自由是一个社会的概念；</p>
<ul>
<li>自由在中国的概念<ul>
<li>没有什么自由的概念；</li>
<li>比较相近的：逍遥游；</li>
</ul>
</li>
<li>中国没有英美传统的自由<ul>
<li>中国是没有法律的自由；</li>
</ul>
</li>
</ul>
<h2 id="5-3-自由的意义"><a href="#5-3-自由的意义" class="headerlink" title="5.3 自由的意义"></a>5.3 自由的意义</h2><p><strong>自由是一种生存的本能</strong><br>自由是一种本能的状态，每个人都希望自己做出决定；</p>
<ul>
<li>Freedom - liberty - independence<ul>
<li>这三个词十分相近</li>
</ul>
</li>
<li>自由的概念对于人无需界定，可以通过自由认知</li>
<li>人的自由是一种生活得常态；<ul>
<li>即使是不了解自由得概念的人，也都可以进行自由；</li>
<li>自由是生命本来的要求 -&gt; 是人生来的价值；</li>
</ul>
</li>
</ul>
<p><strong>功利主义论述：自由并不只是体现了人的人格，还有社会公用的</strong><br>只有这样才能使得社会整体变得更加富有；<br>只有给与人更多自由，才能有更多的创造 -&gt; 自由是创造公民的；</p>
<ul>
<li>公民：有承担责任感的自由</li>
<li>并且自由必须接受结果 -&gt; 培养人接受责任的结果；</li>
<li>因此自由主义通常都是直接和经济制度相联系的；</li>
</ul>
<p><strong>哈耶克：自由还有可能是一种创造</strong><br>自由能产生很多可能，因此更能通过环境的适应；</p>
<ul>
<li>实际上还是一种功利主义；</li>
</ul>
<h2 id="5-4-自由的限制"><a href="#5-4-自由的限制" class="headerlink" title="5.4 自由的限制"></a>5.4 自由的限制</h2><ul>
<li>哲学的游戏… 哈哈哈哈</li>
<li>消极自由<ul>
<li><strong>Freedom From</strong></li>
<li>古典的自由主义</li>
<li>只要你不干预我就可以 -&gt; 政府的消极；</li>
</ul>
</li>
<li>积极自由<ul>
<li><strong>Freedom To</strong></li>
<li>为了获得什么；</li>
<li>提供更多的福利帮助；</li>
</ul>
</li>
</ul>
<p><strong>自由的限度</strong><br>不伤害他人的情况下行使自由 </p>
<ul>
<li>但界定伤害很困难；</li>
<li>权利的相互行 -&gt; 任何的行为都具有相互性；<ul>
<li>权利之间的互相冲突；</li>
</ul>
</li>
<li>自由主义十分强调责任 -&gt; 自由的做出选择，然后承担选择的责任；<ul>
<li>自由主义其实是对于人格的要求很高的 -&gt; 很强的责任承担；</li>
</ul>
</li>
</ul>
<p><strong>是否能够承担自由</strong><br><em>一段宗教的教文：人永远不可获得自由；人类软弱、苦恼、弱小，因此人需要遵循一个无可争议的、已经被崇拜的对象，跟随着别人不需要做出自由的选择，人可以在群体中感受到自己的力量。人们必须找到一个对象，把自己的自由交给它</em></p>
<ul>
<li>个人主义&#x2F;自由主义很多时候是十分残酷的，有着十分大的责任！</li>
<li>自由主义 -&gt; 个人对自己承担大量的责任 -&gt; 这样才能训练出真正的公民；<ul>
<li>因此民主在这个时代会兴起 -&gt; 民主可以把部分个人的责任进行推卸；</li>
<li>不是所有人都有能力承担这份自由；</li>
<li><strong>不管别人再怎么爱你，你死亡的时候，只能你自己去接受死亡，别人不能陪着你一起去</strong> -&gt; 人必须在自己的境遇中形成自己的世界；</li>
</ul>
</li>
<li>但现代社会需要给与一定的自由 -&gt; 形成个人的责任感；<ul>
<li>入学的时候：发现你自己的热爱；</li>
<li>离校的时候：责任高于热爱；</li>
</ul>
</li>
</ul>
<p><strong>自由主义与个人主义关系</strong><br>自由主义可以理解成一种社会哲学，个人主义更加作为：</p>
<ol>
<li>方法论的含义：研究社会的问题必须从个人开始 -&gt; 你要理解整体的时候，必须从个体开始</li>
<li>政治哲学上的个人主义；<br>自由主义和个人主义经常混为一谈，但个人主义始终强调自我支配、自由主义理想当中个人的特点，是自由主义可以实现的基础；</li>
</ol>
<ul>
<li>对于个人主义的描述<ul>
<li>希望和别人不一样，希望自己是独特的，希望实验，希望当烈士，希望漫无目的的漫游，希望不受人打扰，希望不卷入别人的打扰当中，希望不被别人打扰，希望引起别人的关注，希望自己对他们很神秘，希望自己拥有秘密，希望自己是不明确的，希望不受拖累，希望是为了自我而去判断，希望感到真实，而不是茫然，希望去生活，而不是终身去扮演一个角色，或一项职能。不希望别人约束自己，希望超越自己的限制，希望不断超越自己的限制，希望留下、积累起不同的经验，希望塑造自己生命，但不是把自己的生命装进一个美好的故事当中（不是把自己的生活构成一种艺术品）。希望是真实的自我，要成为自己理想中的我，而不是他人理想中的自我（个人主义是一种奢侈品）。希望来生还做我自己。</li>
<li>个人主义是一种强大的奢侈品。<ul>
<li>有经济基础的更容易产生个人主义；</li>
<li>城市人更容易产生个人主义；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>个人主义的问题</strong><br>虽然经常宣传个人主义，但社会上绝大部分都没有办法享受个人主义；</p>
<ul>
<li>能力、财富、前天情况</li>
<li>所有的主义背后都有经济基础<ul>
<li>不是你信仰一个主义，就能变成某一种人，你变不成那种东西；</li>
<li>社会经济条件塑造的；</li>
</ul>
</li>
<li>强调个人主义的好处：鼓励社会创造、创新；<ul>
<li>因此现在社会创新力量不够的原因 -&gt; 社会经济条件还不够；</li>
<li>因此不是能通过教育可以培养出来的 -&gt; 越教育越培养不出来；</li>
</ul>
</li>
<li>同时也是个人主义的发展，也能进一步拉开人和人之间的距离；</li>
<li>既要约束个人主义，也要鼓励个人主义，达成平衡；</li>
</ul>
<p><strong>个人主义的发生</strong><br>现代的个人主义实际上是资本的产物；</p>
<ul>
<li>为什么现在个人主义倾向变大 -&gt; 社会经济发生变化</li>
<li>共产党宣言<ul>
<li>原本是在一个人际关系十分紧密的关系当中，生活在这种环境当中，使得你只有归属在这个村落当中时，才能感受到是自我的；</li>
</ul>
</li>
<li>资本主义<ul>
<li>人员是高度流动的，大工业生产，把大量人的进入城市生活，每个人的文化环境都不一样；所有这些背景都不一样了。方言也不重要了。</li>
<li>市场把人和人之间的关系打破，用市场经济衡量 -&gt; 平等的观念 -&gt; 自由主义发展；</li>
</ul>
</li>
</ul>
<h2 id="5-5-自由与市场经济"><a href="#5-5-自由与市场经济" class="headerlink" title="5.5 自由与市场经济"></a>5.5 自由与市场经济</h2><p><strong>市场经济要求这样的自由</strong><br>因为市场经济需要这样的自由，因此人民的思想需要逐渐转变；</p>
<ul>
<li>市场要求简便、迅速的进行交易：因此需要人和人之间平等、具有自由<ul>
<li>比如印度的分等级制度 -&gt; 它们的社会市场需要这样的制度；</li>
</ul>
</li>
<li>比如现在的签字制度 -&gt; 签字制度就是个人主义、强调个人对责任的负责；</li>
</ul>
<p><strong>社会塑造了个人，因此出现了”作者”（福柯指出），作者实际上成为了商标的意义</strong><br>商标的作用 -&gt; 减少了人们进行交易时候，信息获取的费用；</p>
<ul>
<li>个人主义当中会产生很多奇观现象 -&gt; 个人作为商标；</li>
<li>资本主义使得女性地位提高：<ul>
<li>农耕时期，女性劳动力低下，需要依附男性进行生活</li>
<li>工业化（尤其现代信息化工业）时期，女性用于更高的生产力，产生白领阶层，可以不依赖男性而生存；</li>
</ul>
</li>
</ul>
<p><strong>婚姻关系的契约行为</strong><br>现代婚姻作为经济性的行为；</p>
<ul>
<li>婚前婚后财产的分配</li>
<li>把蒙在家庭之上神圣的面纱撕毁掉了；</li>
</ul>
<p><strong>法律的整体变化趋势 ：个人主义与自由主义，在市场经济的驱动下兴起，进而在理论与实践层面共同推动立法变更</strong></p>
<ul>
<li>不负债子还<ul>
<li>父子的经济关系独立</li>
</ul>
</li>
<li>社会的流动性 -&gt; 婚姻的自由</li>
<li>城市或农村<ul>
<li>农村：各自的人情关系</li>
<li>城市的流动关系；</li>
</ul>
</li>
</ul>
<p><strong>现代社会的法律以及政治基本制定在自由主义与个人主义基础之上</strong></p>
<ul>
<li>所以有很多的法律，在农村行不通；</li>
<li>政治<ul>
<li>代议制民主、直接民主，也都建立在自由主义之上；</li>
<li>一人一票；</li>
</ul>
</li>
<li>并且民族主义也是建立在自由主义基础之上；<ul>
<li>因为每个人自由平等的，所以民族之间都是平等的；</li>
<li>是民族主义的重要思想来源；</li>
</ul>
</li>
<li>通过法律与政治改革<ul>
<li>知识产权、私有产权、全球化、世俗化（支持了启蒙发展）；</li>
<li>很多这些内容</li>
</ul>
</li>
<li>民法三大原则 &lt;- 自由主义思想推动<ul>
<li>契约自由，意志自治；</li>
<li>私有财产神圣不可侵犯； </li>
<li>过错原则；<ul>
<li>必须要有个人的原则在里面</li>
</ul>
</li>
<li>例子：对于个人权利分的越来越细<ul>
<li>拍一张照片，卖给别人</li>
<li>我：肖像权，摄影师：著作权，别人：物权</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-6-自由主义问题"><a href="#5-6-自由主义问题" class="headerlink" title="5.6 自由主义问题"></a>5.6 自由主义问题</h2><p><strong>问题一：个人与社会的问题</strong><br>因为个人主义假定：个人权利优先；<br>对于社会而言，作为人类来说，很难回答个人还是权利优先；</p>
<ul>
<li>补充：很多理论，重点不在于其假设是否正确，重点在于：假设建立之后，围绕在这个假设背后实际推行的行为，是否有用</li>
</ul>
<p><strong>问题二：自由需要一定的财产基础</strong><br>对于大部分人而言，都是好死不如赖活着；<br>没有一定财产基础时，大家都是先追求温饱，然后再追求其他权利；</p>
<ul>
<li>自由经常会有不可两平的情况：需要满足基本生存，而放弃自由</li>
<li>推断结论：自由不是唯一的价值，自由不是至高无上的价值；<ul>
<li>各个阶层，有这个阶层自己的价值前提；</li>
<li>知识分子：靠言论吃饭，需要言论自由；<ul>
<li>因此知识分子经常会把自己的自由推广到整个社会；</li>
</ul>
</li>
<li>商人：靠交易吃饭，需要交易自由；</li>
</ul>
</li>
<li>人总处在某个位置上</li>
</ul>
<p><strong>问题三：自由主义不是一个完整的治理国家的哲学</strong><br>很多基本的现代国家问题无法回答：</p>
<ul>
<li>为什么要税收；<ul>
<li>财产的再分配</li>
<li>例子：什么是人民内部矛盾，就是可以用人民币解决的矛盾；</li>
<li>售卖有争议的权利</li>
</ul>
</li>
<li>会有很多家长制的法律，自由主义无法解决这些问题<ul>
<li>自由主义虽然实际上是支持民主制，但民主制很多时候都会限制自由；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>人文课程</category>
        <category>法理学</category>
      </categories>
      <tags>
        <tag>法理学</tag>
        <tag>自由主义</tag>
        <tag>个人主义</tag>
        <tag>法系</tag>
      </tags>
  </entry>
  <entry>
    <title>【法理学】Lecture 3：复仇与法律起源</title>
    <url>/2023/09/48ed04caa6ee.html</url>
    <content><![CDATA[<ul>
<li>法理学的核心问题</li>
<li>法律的起源：<ul>
<li>所有起源的出现，都是理论的构建，伪装成历史的理论；<ul>
<li>基于理论构建，去历史当中找对应物；</li>
</ul>
</li>
<li>法律与复仇<ul>
<li>整个现代的法律制度，尤其是刑法制度，还是建立在复仇的基础上；</li>
<li><em>本能：法律的基础建构在复仇基础之上</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="3-1-纠纷"><a href="#3-1-纠纷" class="headerlink" title="3.1 纠纷"></a>3.1 纠纷</h2><p><strong>情况一：一个人的情况</strong><br>在没有社会结构的情况下，无法建构价值系统，无纠纷的情况；</p>
<p><strong>情况二：两个人签订条约，双方清楚条约内容 -&gt; 第二方执行</strong></p>
<ul>
<li>签订的所有条约，都是不完整条约；</li>
<li>进而<strong>复仇</strong>就进而出现；<ul>
<li>两个人的协定，但是有一方认为另一方没有遵守协议 -&gt; 使用暴力迫使对方遵守协议 -&gt; 复仇的出现；</li>
</ul>
</li>
</ul>
<p><strong>情况三：两个人发生纠纷，第三方执行-&gt;社会、经济、法律学家</strong></p>
<ul>
<li>司法、法律、仲裁等等；</li>
<li>但第三种情况是最少出现的；</li>
</ul>
<h2 id="3-2-复仇"><a href="#3-2-复仇" class="headerlink" title="3.2 复仇"></a>3.2 复仇</h2><p><strong>复仇是一种本能</strong></p>
<ul>
<li>复仇是一种本能<ul>
<li>是一种基因当中的本能；如果一种生物不具有复仇的本能，就不能存活下来；</li>
<li><strong>应当说是：保留自我、扩张自我的权利的倾向</strong>；</li>
</ul>
</li>
<li>例子：对物诉讼<ul>
<li>对动物、植物等等进行惩罚；</li>
</ul>
</li>
</ul>
<p><strong>伤害-&gt;复仇</strong><br>什么是伤害：既有身体上的，也有虚假的、精神上的；</p>
<ul>
<li>复仇是一种推迟的报复；</li>
</ul>
<p><strong>复仇的社会功能：维护自己的权利</strong></p>
<ul>
<li>权利感：实际上权力感不是由社会定义出来的，而是本身就有的；<ul>
<li>权力意志；保存自我的本能；</li>
<li>权利的生物性原因；</li>
<li><strong>权利感来自于生物性，法律只是对此进行包装</strong>；</li>
</ul>
</li>
<li><ol>
<li>复仇 -&gt; 维护权利感；</li>
</ol>
</li>
<li><ol start="2">
<li>复仇虽然是为了自己的权利，但客观上也维护了社会的秩序；</li>
</ol>
<ul>
<li>防止复仇行为产生 -&gt; 对于他人权利的认同 -&gt; 对于自己权利的认同 -&gt; 保存自我；</li>
</ul>
</li>
<li><ol start="3">
<li>促进创造</li>
</ol>
<ul>
<li>复仇促进创造；</li>
<li>因为复仇行为的存在，促使人去通过其他的行为获得资源 -&gt; 机会成本的考量；</li>
<li>整个社会的创造增加；<ul>
<li>不仅是物质财富，还有精神财富；</li>
</ul>
</li>
<li>报复的能力可以促进创造；<ul>
<li>和平的竞争替代为暴力的竞争；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>复仇的弱点</strong><br>当使用暴力的时候，是一种毁灭社会财产，甚至残疾人；</p>
<ul>
<li>复仇最大的问题：<strong>资源的浪费</strong>；</li>
<li>问题二：复仇时，复仇的主体能力不一样；<ul>
<li>复仇可能会导致自己的伤害更高；</li>
<li>复仇是很难做到的；</li>
<li>复仇很难当场做到；</li>
<li>当是一个弱小者时，可能是会产生伤及无辜；<ul>
<li>打不过直接伤害者时，可能伤害无辜的人；</li>
</ul>
</li>
</ul>
</li>
<li>问题三：强烈的情绪性<ul>
<li>因为强烈的情绪性，可能会产生不对等的伤害；</li>
</ul>
</li>
<li>问题四：复仇依靠情绪来激励，当情绪平息下来时，不一定还会复仇；<ul>
<li>如何保证每个人在很弱的情况下，还会有复仇的情绪；</li>
</ul>
</li>
</ul>
<p>由于复仇的弱点，使得复仇的行为被制度制约；</p>
<h3 id="3-2-1-复仇在不同情况"><a href="#3-2-1-复仇在不同情况" class="headerlink" title="3.2.1 复仇在不同情况"></a>3.2.1 复仇在不同情况</h3><p><strong>复仇与以多胜少</strong><br>虽然当时无法复仇，但可以事后依靠人数、智力取胜；</p>
<p><strong>复仇与复仇激情</strong><br>机会主义可能会使得复仇无法得到实现；</p>
<p><strong>复仇与政治性因素</strong><br>组织大量的人力，变成了政治性组织 -&gt; 家族 -&gt; 政治性组织；<br>这种复仇可能更加血腥、更加大规模；</p>
<ul>
<li>每次失败又是每次进步，每次进步有到达新的失败；</li>
</ul>
<p><strong>同代复仇</strong><br>以牙还牙，以眼还眼；</p>
<ul>
<li>但是事实上无法真正达成；</li>
<li>最大问题：很多事情无法以牙还牙，以眼还眼；<ul>
<li>在经验层面无法证实；</li>
</ul>
</li>
<li>这是历史学家想象出来的结果，而不是真正实现</li>
<li>孔子的思想：以德报德、以怨报怨<ul>
<li>No，以德报德，以直报怨；</li>
<li>以正直的惩罚实现；</li>
</ul>
</li>
<li>重点：如何防止复仇的扩大；</li>
</ul>
<p><strong>复仇与家庭因素</strong><br>为了防止自己的家族的成员收到伤害，所以防止家族当中成员去惹别人；</p>
<ul>
<li>家族 -&gt; 纪律 -&gt; 公权力 -&gt; 组织化&amp;政治化；</li>
</ul>
<p><strong>复仇与意识形态</strong><br>复仇是个人思想的内容，无法进直接通过生殖进行；</p>
<ul>
<li>因此需要通过一些教育的因素，使得其可以保留下来；</li>
<li>制度、家庭教育、社会鼓励复仇的政治体制 -&gt; 社会对复仇的支持；</li>
</ul>
<h3 id="3-2-2-正义的产生"><a href="#3-2-2-正义的产生" class="headerlink" title="3.2.2 正义的产生"></a>3.2.2 正义的产生</h3><p><strong>对于复仇政治化的价值判断：正义</strong><br>对于复仇的价值判断 -&gt; 既是对于复仇的约束，也是对于复仇的正当化；</p>
<ul>
<li>正义的概念尤其强调复仇的政治概念 -&gt; 社会正义的概念 -&gt; 国家力量的出现（国家高于个人力量的绝对观念）；<ul>
<li>国家垄断复仇权力；</li>
</ul>
</li>
<li>以直报怨 -&gt; 政治性的概念：是否正义</li>
<li>当复仇可以保证社会制度时，复仇就是社会结构的一部分；<ul>
<li>高度分散的、执法权利高度分布式的微型权力关系；</li>
</ul>
</li>
<li><strong>复仇是一种高度分散的权利关系</strong></li>
</ul>
<p><strong>复仇的劳动分工</strong><br>在社会的分工不完全的情况下，复仇是需要大量个人准备的（简单的分工） -&gt; 无法很细致的分工；</p>
<ul>
<li>因为社会没有剩余的劳动生产 -&gt; 复仇需要剩余的劳动产品，然后才让其他人去负责这部分分工；</li>
<li>现代复仇制度：复仇的高度分工<ul>
<li><strong>只有在生产劳动有剩余时，才可能对复仇进行分工 -&gt; 因此才能产生法律制度以及实施法律制度；</strong></li>
<li>在过去因为劳动力水平低下，没有中央集中的权力机构进行法律的执行；</li>
</ul>
</li>
<li>进而产生法治分工 -&gt; 复仇开始被贬低 -&gt; 对制度的促进作用；<ul>
<li>人类的社会生活产生了变化，进而才产生了不同的法律制度，而不是考某一个思想家制造出了法律制度；</li>
</ul>
</li>
</ul>
<h2 id="3-3-法律出现的三个前提"><a href="#3-3-法律出现的三个前提" class="headerlink" title="3.3 法律出现的三个前提"></a>3.3 法律出现的三个前提</h2><p><strong>前提一：劳动分工</strong><br>社会当中两个人发生矛盾时，如果互相直接解决时会使得伤害进一步扩大，或者无法实施；此时就需要第三者来进行待执行；</p>
<ul>
<li>第三者：一部分人，专门通过创造安定、和平的社会来进行工作，乘坐第三人：律师、法官；</li>
<li>劳动分工的前提：第三者解决纠纷的人，需要能通过社会给予的财产来完成生存；</li>
</ul>
<p><strong>前提二：剩余劳动</strong><br>剩余劳动产生剩余产品；<br>首先是国家发展水平的提高，才进一步产生法律；</p>
<p><strong>前提三：国家统一</strong><br>此前提并不是所有情况都需要；</p>
<ul>
<li>当需要通过法官来形成判断时，背后必须要有对应的政治制度 -&gt; 需要有国家统一；<ul>
<li>并且，国家还会逐渐扩大公权力 -&gt; 如何达成？<strong>对于暴力的垄断</strong>；<ul>
<li>把民众的武器进行控制；</li>
</ul>
</li>
</ul>
</li>
<li>并且：需要让每个人在发生纠纷时都去找法官，这种事情需要被人们接受，也需要漫长的过程；<ul>
<li>让每个人把法律当作理所当然：需要很多时间；</li>
<li>人本性的东西被逐渐社会化；通过制度压制复仇的本能；</li>
</ul>
</li>
</ul>
<h2 id="3-4-现代法律的新问题"><a href="#3-4-现代法律的新问题" class="headerlink" title="3.4 现代法律的新问题"></a>3.4 现代法律的新问题</h2><p><strong>问题一：代理问题</strong><br>为他人解决问题的人是：代表社会利益的代理人 -&gt; Agent 选择的问题；</p>
<ul>
<li>三大问题：懈殆、偏私、腐败；<ul>
<li><em>法制是创建腐败的制度</em></li>
</ul>
</li>
<li>懈怠：<ul>
<li>对于解决矛盾的第三人而言，不是自己的事情，因此可能会产生懈怠；</li>
</ul>
</li>
<li>偏私<ul>
<li>某个人由于种种原因，导致偏向某一边；</li>
<li>熟人关系总是不自觉地偏向某个人 -&gt; 所有人都是一个地方的人，尤其是在小县城，互相都很熟悉 -&gt; 如何找到一个人，可以公正；</li>
<li>过于熟悉，对地方、人产生情感 -&gt; 偏私   VS  完全不熟悉 -&gt; 难以展开工作；</li>
</ul>
</li>
<li>腐败<ul>
<li>腐败是因为法律的出现，才能发生；<ul>
<li>因为出现了第三方人的制度 -&gt; 第三方人掌管权力 -&gt; 权力产生腐败；</li>
<li>当一个人长期处于掌管所有人中间权力的位置，所有人都有权于他时 -&gt; 产生腐败；<ul>
<li><em>所以现在强调多元化纠纷解决方式</em> -&gt; 多元化调节机制，可以减少腐败产生；</li>
<li>法官的等级制度问题 -&gt; 解决腐败后 -&gt; 解决懈怠问题；</li>
</ul>
</li>
</ul>
</li>
<li><strong>竞争性腐败</strong>：当腐败、贿赂开始竞争；</li>
<li>长期的社会矛盾：<strong>代理与腐败 – 代理与暴力</strong> <ul>
<li>所以代理问题，也是一个司法独立问题；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>问题二：信息问题</strong><br>相比于复仇而言：信息问题</p>
<ul>
<li>复仇时：不存在事实争议问题；</li>
<li>但请第三方进行处理时 -&gt; 第三方无法参与事件的全过程的情况下，需要来做出一个判断 -&gt; 如何让第三方获得信息？<ul>
<li>并且由于现代社会越来越陌生化的情况下，获得信息更难；产生准确、可靠的信息？</li>
<li>产生的问题：<strong>程序正义与事实正义的问题</strong></li>
</ul>
</li>
<li>程序正义与事实正义 <ul>
<li>程序正义，很大程度上是在信息不足的情况下，掩盖事实正义；</li>
<li>因为当时人要找法官，就是希望法官通过法律程序，使其可以获得实质性意义上的事实正义；</li>
<li>因为<strong>程序正义事实上是高话语权群体，基于整体考虑而不是基于个人当事人考虑的结果</strong>；</li>
<li><strong>而这一切都是因为信息问题</strong>；</li>
</ul>
</li>
<li>因为信息问题，因此才会进一步产生公安、检察院、法医、专家证人；<ul>
<li>公安取证；</li>
<li>检察院核实；</li>
<li>法医鉴定；</li>
<li>因此，很多事情都是信息问题：<ul>
<li>暴力取证：因为暴力取证得到的有真的、有假的，因此一律以假的对待；</li>
<li>追诉期：因为时间长了之后，很多证据消失，取证困难 -&gt; 信息问题；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-5-法律与意识形态问题"><a href="#3-5-法律与意识形态问题" class="headerlink" title="3.5 法律与意识形态问题"></a>3.5 法律与意识形态问题</h2><p><strong>法律宣传与意识形态问题</strong><br>需要大量的人去使用法律，才可以养活那么多的人，才可以进一步扩大法律；</p>
<ul>
<li>必须到老百姓中去宣传 -&gt; 法律的宣传与利益集团关系；<ul>
<li>大家使用一种法律；</li>
</ul>
</li>
<li>并且需要使用意识形态，来通过软实力，达到不同地区人的协同；<ul>
<li>使得人们觉得很多事情可以通过法律解决；</li>
</ul>
</li>
<li>但意识形态也会约束：新技术情况下，创造力的产生；<ul>
<li>意识形态很难处理新的东西：在现在体制下；</li>
<li>因此很多时候通过成立新的法律来达成；</li>
</ul>
</li>
</ul>
<h2 id="3-6-规则统一"><a href="#3-6-规则统一" class="headerlink" title="3.6 规则统一"></a>3.6 规则统一</h2><p>比较小的规则可以统一，但是当规模扩大时，如何保证规则进行；</p>
<ul>
<li>规则统一十分重要；<ul>
<li>需要一个制度来确定；</li>
<li>通过一个制度，来确保法律能够统一，规则能够统一；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>人文课程</category>
        <category>法理学</category>
      </categories>
      <tags>
        <tag>法理学</tag>
      </tags>
  </entry>
  <entry>
    <title>【法理学】Lecture 4：法系</title>
    <url>/2023/09/a2c89473cdff.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h2 id="4-1-法律与规则的统一"><a href="#4-1-法律与规则的统一" class="headerlink" title="4.1 法律与规则的统一"></a>4.1 法律与规则的统一</h2><p><strong>法律为什么要统一？为什么产生法系？重点是背后的为什么问题</strong><br>在很大的社会下，如何进行统一？规则的统一问题；</p>
<p><strong>第一：法律的统一，首先是政治上的统一</strong><br>必须国家的公权力先深入到规则使用的地方，才可以推行对应的法律；</p>
<p><strong>第二：法律的统一，奠定了稳定、统一经济的基础</strong></p>
<p><strong>第三：法律规则与效率问题</strong><br>如果每个地方的法律都不一样，那会增加很多的学习成本，导致效率变低；</p>
<ul>
<li>规则的统一，也是一个效率的问题；</li>
</ul>
<p><strong>统一与不统一</strong><br>当一个地方统一之后，也就造成了和其他文化、国家的更不统一；</p>
<p><strong>为什么会有法系</strong><br>法系就是面对不同地方情况时，进行统一的问题；</p>
<ul>
<li>很多问题是全人类当中都一样的，但解决问题的方法是不一样的；</li>
<li>英美法系和大陆法系都在解决这个问题：<strong>如何建立规则的统一</strong><ul>
<li>英美法系：以司法为中心的法律；</li>
<li>大陆法系：以成文法、条款为中心的；</li>
</ul>
</li>
</ul>
<h2 id="4-2-法系制度概览"><a href="#4-2-法系制度概览" class="headerlink" title="4.2 法系制度概览"></a>4.2 法系制度概览</h2><p><strong>英美法系</strong><br>强调以司法为中心，强调遵循先例，制定一个制度；</p>
<p><strong>大陆法系</strong><br>强调以立法为中心，以公正法典为中心；</p>
<p><strong>两个法系的核心</strong><br>是核心，但不是本质；</p>
<ul>
<li>本质是不存在的；本质就是表象之表现 -&gt; 人看到的只有经验，在经验的辩证法中涌现出所谓的”本质”；</li>
<li>核心：<strong>都是为了保证现实世界，能够使用统一的规则，建立一个能被使用的制度；</strong></li>
</ul>
<h2 id="4-3-大陆法系"><a href="#4-3-大陆法系" class="headerlink" title="4.3 大陆法系"></a>4.3 大陆法系</h2><p><strong>大陆法系的优缺点分析</strong></p>
<ul>
<li>优点<ul>
<li>编撰一个法律所需要的时间比较短，不需要大量的司法实践来形成；</li>
<li>可以快速替代各个地方当地的规则，可以快速形成一个统一的国家；</li>
<li>很多法律制定出来的时候，很多时候并不需要太考虑法律的后果，因为<strong>很多是基于政治上的考虑，而非法律上的考虑</strong>；</li>
<li>便于进行移植，翻译容易，可以短暂时间内进行建立；</li>
</ul>
</li>
<li>缺点<ul>
<li>对于强制性非常需求；<ul>
<li>各个地方的规则不统一时，必须以强有力的行政力量为核心，来执行下去；</li>
</ul>
</li>
<li>这种法制一般都是在封建专制时期形成的 -&gt; 绝对主义时期；</li>
</ul>
</li>
</ul>
<p><strong>大陆法系特点</strong></p>
<ul>
<li>特点<ul>
<li>以法学家进行编纂，然后以行政力量为核心，进行执行；</li>
<li>不以法官为核心，以行政力量为核心；</li>
<li>法官一般偏向于政府<ul>
<li>法官没有司法审查权；</li>
<li>司法的配置问题；</li>
</ul>
</li>
<li>要求能够通过文字来传播；<ul>
<li>文字要求比较精确 -&gt; 传到各个地方的时候，各个地方需要能够准确执行 -&gt; 需要精确；</li>
<li>精确是对于意思表达的精确，而不是文字本身是否精细；</li>
</ul>
</li>
<li>由立法机关进行制定，允许有限的判例，但判例也是依附于条款；</li>
<li>对于案件进行分析时，很多时候不需要对于案件的经验本身需要有很深的理解，更多是概念上对于法律条文的技术性计算；</li>
</ul>
</li>
<li>大陆法律背后的技术机制<ul>
<li>由法学家、学者进行编纂，然后以行政力量为核心，进行执行；</li>
<li><strong>不是以法官为核心</strong>-&gt;法官只有在纠纷时，才出现；</li>
</ul>
</li>
<li>很多法律的存在，不是因为好坏，单纯只是因为需要一个统一的规定</li>
</ul>
<p><strong>大陆法系使用国家</strong></p>
<ul>
<li>使用国家：德国、法国、中国、日本；<ul>
<li>比如中国的法律<ul>
<li>对于法律的颁布很快；</li>
<li>制定一个法律，几年时间就够了；</li>
<li>象征性的做点调查，开几个座谈会，提点意见，全国人大代表反之也不太懂，然后就通过了…</li>
</ul>
</li>
<li>法国：拿破仑法典 -&gt; 强权人物</li>
<li>德国：铁血宰相 -&gt; 通过强权进行统一；</li>
<li>日本</li>
</ul>
</li>
</ul>
<h2 id="4-4-英美法系"><a href="#4-4-英美法系" class="headerlink" title="4.4 英美法系"></a>4.4 英美法系</h2><p><strong>英美法的核心特点</strong></p>
<ul>
<li>遵循先例</li>
<li>法官造法</li>
<li>根据具体案件得出判决<ul>
<li>现在的案件要遵循过去案件的判决</li>
<li>下级法院要遵循上级法院的判决</li>
<li>同级法院的判决可以互相参照；</li>
</ul>
</li>
</ul>
<p><strong>英美法特点</strong></p>
<ul>
<li>以法官为核心进行创制<ul>
<li>英美法是以法官为核心，而不是以立法、执法机构为核心；</li>
<li>英美法当中有很多伟大的、知名的法官；</li>
<li>法官以具体的案件来进行思考，得出符合的规则。同时应该尽可能保存过去的规则，对过去的规则重新解释，进行修补；</li>
</ul>
</li>
<li>每一个规则都和大量具体的案例联系在一起；</li>
<li>更加灵活，更能适应本地的情况 -&gt; 英美法更加强调地方的法律；<ul>
<li>ag ：医疗事故的判断，是按照本地的医疗水平来进行判断是否是医疗事故；</li>
</ul>
</li>
<li>需要很漫长的时间来形成<ul>
<li>在十一世纪逐渐开始；</li>
<li>在十九世纪逐渐完善；</li>
</ul>
</li>
<li>法官既是一个法学家，也是一个独立的政治家；</li>
<li>国会虽然也会制定法律，但每一条法律都还会到法官那里去重新解释；</li>
</ul>
<p><strong>英美法产生</strong><br>英国 -&gt; 当时中央派出大量的法官到地方，然后各个法官根据地方的特点，得出地方的<strong>普通法</strong>规则；</p>
<ul>
<li>问题：规则不统一</li>
<li>因此需要通过上级法院，选择哪个地方的规则更有道理，或者进行中和得出新的规则；<ul>
<li>只能由一个最高法院，最高法院即使错了，也得遵守；</li>
</ul>
</li>
<li>长期的按照这种机制进行运作，逐渐得到合理的统一的制度；</li>
</ul>
<p><strong>部分问题</strong></p>
<ul>
<li>规则不统一，要进行上诉；</li>
<li>有些问题只是地方的问题，无法上诉，还是会有地方的特色；</li>
</ul>
<p><strong>英美法与制度竞争</strong><br>法官必须要面对实际；在同一级别的法官逐渐，各自得出判决；<br>然后得出判决之后，上级法院可以对下级法院做出的判决进行评判，形成制度竞争；</p>
<ul>
<li>遵循一个认知：前辈是聪明的，然后在前辈没有遇到的问题前，进行我的思考<ul>
<li>智慧一长串的进行积累；每一代人都可以对上一代人的智力进行遵循；</li>
</ul>
</li>
<li>累计历史的智慧，好的判决慢慢累积下来<ul>
<li>并且集中了当代的智慧；即使是有错误的判决，也有存在的意义；</li>
<li>在司法意义上，没有严格意义上的错误；</li>
</ul>
</li>
<li>因为有制度竞争，案例参考与上级法院制度，因此法官并不只是对于条文的技术性工作，更多还是对于事实、经验的考虑、甚至是政治性的工作；<ul>
<li>美国伟大的法学家，都是法学家并且具有政治头脑，知道什么事情对于国家最有整体性的利益；</li>
</ul>
</li>
<li>激励法官去进行制度创新；<ul>
<li>当一个问题经常要遵循先例，但总是有问题，总是要上诉到最高法院时，最高法院就需要反思这个问题是不是对的； -&gt; 迫使其进行反思；</li>
</ul>
</li>
</ul>
<p><strong>英美法的弱点</strong><br>最致命的弱点：这是无法移植的法律的体制；</p>
<ul>
<li>很多案例的情况是和当地具体的情况高度耦合的，需要对整个英美法非常了解才可以理解；</li>
<li>法官很难培训，需要花大量的时间；</li>
<li>虽然也有部分国家使用过英美法：印度、菲律宾、香港<ul>
<li>但这是殖民的产物，不是制度的产物；</li>
<li>印度、香港的法官，还是都是讲英文的；</li>
<li>同时把地方精英都纳入的它那个制度里面；</li>
</ul>
</li>
</ul>
<h2 id="4-5-中国的法系选择"><a href="#4-5-中国的法系选择" class="headerlink" title="4.5 中国的法系选择"></a>4.5 中国的法系选择</h2><p>总体上使用大陆法；</p>
<ul>
<li>因为中国如果要进行法律的现代化，同时还要兼带着政治的现代化、经济的现代化；</li>
<li>大陆法易于学习，律师好培养；</li>
<li>中国的变法、改革，以及它的军队，来确保它的法律遵循下来<ul>
<li>军队是中国最早现代化的制度；</li>
</ul>
</li>
</ul>
<p><strong>中国必须使用大陆法</strong><br>中国疆域太大，民族很多，法律要适合经济发展、各个地方区别，要允许创造性，试错的过程中需要进行试错；</p>
<p><strong>中国现在是否可以使用大陆法？</strong><br>也不行；中国人太讲究宏观，不讲究细节；<br>只要有先例，一定直接使用先例；本来一个判例的每个细节都应该进行索引，但是这种索引的技术十分的复杂；在中国很难实施，很容易造成司法的腐败；</p>
]]></content>
      <categories>
        <category>人文课程</category>
        <category>法理学</category>
      </categories>
      <tags>
        <tag>法理学</tag>
        <tag>法律</tag>
        <tag>法系</tag>
        <tag>大陆法系</tag>
        <tag>英美法系</tag>
      </tags>
  </entry>
  <entry>
    <title>【实时渲染】Lecture 1：介绍与导论</title>
    <url>/2023/09/47c6d08bc12c.html</url>
    <content><![CDATA[<p>关于课程：三个关键词</p>
<ul>
<li>实时</li>
<li>高质量</li>
<li>渲染<span id="more"></span></li>
</ul>
<h1 id="1-内容介绍"><a href="#1-内容介绍" class="headerlink" title="1 内容介绍"></a>1 内容介绍</h1><h2 id="1-1-主要目标"><a href="#1-1-主要目标" class="headerlink" title="1.1 主要目标"></a>1.1 主要目标</h2><p><strong>什么是实时</strong><br>标准：做到每秒钟生成三十帧，可以被称之为实时；</p>
<ul>
<li>VR&#x2F;AR 的标准可能更高，需要 90 FPS；</li>
<li>实时渲染的目标 ：互动性</li>
</ul>
<p><strong>什么是高质量</strong><br>核心：营造真实感；<br>为了保证实时渲染，通常都会牺牲一些质量；<br>但实时渲染就是全都要！既要效率，也要高质量；</p>
<ul>
<li>物理上也得保证正确； </li>
<li>正确性需要保证 -&gt; 无法控制的艺术效果失误，在实时渲染当中的要求更高；</li>
</ul>
<p><strong>什么是渲染</strong><br>把三维的一个场景，通过计算的方式，模拟光线在场景当中反射之后如何产生画面；</p>
<h2 id="1-2-内容组成部分"><a href="#1-2-内容组成部分" class="headerlink" title="1.2 内容组成部分"></a>1.2 内容组成部分</h2><p><strong>四个话题</strong></p>
<ul>
<li>阴影</li>
<li>全局光照</li>
<li>基于物理的着色</li>
<li>实时光线追踪<br>特点：知识十分的分散</li>
</ul>
<p><strong>阴影与环境光</strong><br>可以描述来自环境的四处八分的光照；</p>
<ul>
<li>Interactive Global 光照；</li>
<li>预计算；</li>
<li>实时光线追踪；</li>
<li>非真实感渲染；</li>
<li>实时光线追踪背后的时间、空间发展；<ul>
<li>时间上的抗锯齿技术；</li>
<li>英伟达的 DLSS 技术；</li>
</ul>
</li>
</ul>
<h1 id="2-实时渲染目的"><a href="#2-实时渲染目的" class="headerlink" title="2 实时渲染目的"></a>2 实时渲染目的</h1><p>在合理的性能范围内，达成尽可能真实的画面；</p>
<ul>
<li>做出一定的假设；</li>
<li>在假设更少的前提下，得出更好的画面；</li>
</ul>
<h2 id="2-1-很重要的技术"><a href="#2-1-很重要的技术" class="headerlink" title="2.1 很重要的技术"></a>2.1 很重要的技术</h2><p><strong>可编程渲染管线</strong><br>涉及到图形学的相关科学部分，不需要特别深的科学的知识**</p>
<p><strong>预计算</strong><br>把很多复杂的需要的技术，在渲染前先计算，使得在运行时可以达到实时；</p>
<p><strong>Interactive Ray Tracing</strong><br>使用 GPU 绘制模糊的画面，然后再使用降噪的算法得到高画质的内容；</p>
<ul>
<li>未来或许也可以使用到实时渲染；</li>
</ul>
<h1 id="3-实时渲染发展史"><a href="#3-实时渲染发展史" class="headerlink" title="3 实时渲染发展史"></a>3 实时渲染发展史</h1><p><strong>20 年前：最终幻想 7</strong><br>反恐精英、最终幻想 7；</p>
<p><strong>10 年高速发展：可编程渲染管线的技术出现</strong><br>因为出现了可编程的渲染管线，因此编程人员对画面可以进行深度定制，所以大幅提升画质；</p>
<p><strong>现在的追求：Stunning Graphics</strong><br>并且：实时渲染被使用的范围更广了</p>
<ul>
<li>虚拟现实、增强现实</li>
<li>用实时渲染技术，制作电影、连续剧；</li>
</ul>
]]></content>
      <categories>
        <category>游戏引擎</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【实时渲染】Lecture 2：Recap of CG Basic</title>
    <url>/2023/09/634272ba6acf.html</url>
    <content><![CDATA[<p>Basic GPU hardware pipeline</p>
<ul>
<li>OpenGL</li>
<li>OpenGL Shading Language (GLSL)</li>
<li>The Rendering Equation</li>
<li>Calculus：微积分<span id="more"></span></li>
</ul>
<h2 id="2-1-渲染管线"><a href="#2-1-渲染管线" class="headerlink" title="2.1 渲染管线"></a>2.1 渲染管线</h2><p>这种传统的渲染管线，对于直接的光线处理还算可以，但是对于光线的复杂处理、真实感模拟还是不够；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230919172107.png"
                     
                ></p>
<h2 id="2-2-OpenGL"><a href="#2-2-OpenGL" class="headerlink" title="2.2 OpenGL"></a>2.2 OpenGL</h2><p><strong>是什么</strong><br>其就是一套 API 框架，就是在 CPU 执行的代码，控制 GPU 来进行处理、做什么样的操作；</p>
<ul>
<li>缺点<ul>
<li>OpenGL 的版本十分繁杂<ul>
<li>因为其是社区维护的，在一个平缓的过渡中有大量的版本；</li>
</ul>
</li>
<li>其是 CPU 端的代码，完全是 C 风格的代码，十分不好用，不好 Debug；</li>
</ul>
</li>
</ul>
<p><strong>OpenGL 绘制画面</strong><br>Important analogy: oil painting<br>A. Place objects&#x2F;models<br>B. Set position of an easel<br>C. Attach a canvas to the easel<br>D. Paint to the canvas<br>E. (Attach other canvases to the easel and continue painting)<br>F. (Use previous paintings for reference) </p>
<h3 id="2-2-1-Place-objects-models"><a href="#2-2-1-Place-objects-models" class="headerlink" title="2.2.1 Place objects&#x2F;models"></a>2.2.1 Place objects&#x2F;models</h3><ol>
<li>先确定使用什么模型；</li>
<li>把物体和模型放置到场景上，进行物体的 Transform；</li>
<li>使用 VBO 存储模型；<ol>
<li>VBO：存一堆顶点的位置，以一定的格式来存储物体；</li>
</ol>
</li>
<li>使用 OpenGL 构建矩阵；<ol>
<li>GlTranslate</li>
</ol>
</li>
</ol>
<h3 id="2-2-2-Set-position-of-an-easel"><a href="#2-2-2-Set-position-of-an-easel" class="headerlink" title="2.2.2 Set position of an easel"></a>2.2.2 Set position of an easel</h3><p>放置画家；</p>
<ul>
<li><ol>
<li>View Transformation</li>
</ol>
</li>
<li><ol start="2">
<li>放置一个摄像机，设置相机的基础属性；</li>
</ol>
<ul>
<li><ol>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230919181132.png"
                     
                ></li>
</ol>
</li>
<li>设置相机的近裁平面和远裁平面；</li>
</ul>
</li>
</ul>
<h3 id="2-2-3-Attach-a-canvas-to-the-easel"><a href="#2-2-3-Attach-a-canvas-to-the-easel" class="headerlink" title="2.2.3 Attach a canvas to the easel"></a>2.2.3 Attach a canvas to the easel</h3><p>在画架上面固定一个画布；</p>
<ul>
<li>可以通过换不同的画布，就可以渲染不同的画面</li>
<li>用一个 framebuffer 可以渲染很多个不同的纹理；<ul>
<li>并且可以制定不同的纹理，同时输出好多纹理，通过 framebuffer 渲染；</li>
</ul>
</li>
<li>framebuffer 就是画架；<ul>
<li>画架上的画布可以有很多张；</li>
</ul>
</li>
<li>渲染一次场景，可以得到很多不同的东西，由 framementshader 决定输出到哪个纹理上；</li>
</ul>
<h3 id="2-2-4-Paint-to-the-canvas"><a href="#2-2-4-Paint-to-the-canvas" class="headerlink" title="2.2.4 Paint to the canvas"></a>2.2.4 Paint to the canvas</h3><p>需要做 Shadings；</p>
<ul>
<li>每个顶点进行的操作<ul>
<li>MVP 映射；</li>
<li>插值；</li>
</ul>
</li>
<li>片段着色器</li>
<li>OpenGL 进行光栅化，编程一个个像素；</li>
<li>对每个片段进行着色<ul>
<li>基于片段着色器的要求；</li>
</ul>
</li>
</ul>
<h3 id="2-2-5-OpenGL-所作行为总结"><a href="#2-2-5-OpenGL-所作行为总结" class="headerlink" title="2.2.5 OpenGL 所作行为总结"></a>2.2.5 OpenGL 所作行为总结</h3><p><strong>总结：OpenGL 的每一次提交</strong></p>
<ul>
<li>指定具体的 objects，camera，MVP；</li>
<li>指定具体的 framebuffer，input 与 output texture；</li>
<li>指定具体的片段着色器和顶点着色器；</li>
<li>可能会有多次的 passes！ <ul>
<li>多趟的渲染；</li>
</ul>
</li>
</ul>
<h2 id="2-3-GLSL-着色器语言"><a href="#2-3-GLSL-着色器语言" class="headerlink" title="2.3 GLSL 着色器语言"></a>2.3 GLSL 着色器语言</h2><p>用来描述着色器如何进行操作，最后如何进行输出；</p>
<p><strong>什么是着色器语言</strong><br>很像 C 语言，可以对 GPU 进行简单编程；</p>
<ul>
<li>最早的 Shading 语言：直接对 GPU 写汇编十分困难，因此需要一种语言可以简单编写，然后可以编译成 GPU 的指令；</li>
<li>最终还是会编译成机器上的汇编，让 GPU 执行；</li>
</ul>
<p><strong>写 Shader 语言</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GLuint initshaders (GLenum type, const char *filename) &#123;</span><br><span class="line">// Using GLSL shaders, OpenGL book, page 679</span><br><span class="line">GLuint shader = glCreateShader(type) ;</span><br><span class="line">GLint compiled ;</span><br><span class="line">string str = textFileRead (filename) ;</span><br><span class="line">GLchar * cstr = new GLchar[str.size()+1] ;</span><br><span class="line">const GLchar * cstr2 = cstr ; // Weirdness to get a const char</span><br><span class="line">strcpy(cstr,str.c_str()) ;//C风格的代码</span><br><span class="line">//设置Shader语言源代码</span><br><span class="line">glShaderSource (shader, 1, &amp;cstr2, NULL);</span><br><span class="line">//编译Shader</span><br><span class="line">glCompileShader (shader) ;</span><br><span class="line">glGetShaderiv (shader, GL_COMPILE_STATUS, &amp;compiled) ;</span><br><span class="line">if (!compiled) &#123;</span><br><span class="line">shadererrors (shader) ;</span><br><span class="line">throw 3 ;</span><br><span class="line">&#125;</span><br><span class="line">return shader ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>Shader 初始化</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">GLuint <span class="title function_">initprogram</span> <span class="params">(GLuint vertexshader, GLuint fragmentshader)</span></span><br><span class="line">&#123;</span><br><span class="line">	GLuint program = glCreateProgram() ;</span><br><span class="line">	GLint linked ;</span><br><span class="line">	glAttachShader(program, vertexshader) ;</span><br><span class="line">	glAttachShader(program, fragmentshader) ;</span><br><span class="line">	glLinkProgram(program) ;</span><br><span class="line">	glGetProgramiv(program, GL_LINK_STATUS, &amp;linked) ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (linked) </span><br><span class="line">		glUseProgram(program) ;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		programerrors(program) ;</span><br><span class="line">		throw <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> program ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>一个简单的顶点 Shader</strong></p>
<ul>
<li>varying：opengl 中的变量；</li>
<li>unifom：opengl 中的全局变量；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230919190219.png"
                     
                ></li>
</ul>
<p><strong>一个简单的片段 Shader</strong></p>
<ul>
<li>Sample 2 D 表示一个材质<ul>
<li>其可以定义采样的各个顶点的要使用的材质；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230919190631.png"
                     
                ></li>
</ul>
</li>
</ul>
<h3 id="2-3-1-如何去-Debug-Shader"><a href="#2-3-1-如何去-Debug-Shader" class="headerlink" title="2.3.1 如何去 Debug Shader"></a>2.3.1 如何去 Debug Shader</h3><p><strong>老版本的情况</strong><br>需要在多个 GPU 的情况下，才可以对 GLSL 进行 Debug；<br>需要有硬件的模拟的情况下，才可以对 HLSL 进行模拟；</p>
<p><strong>原因</strong><br>在 GPU 上允许，因此很难进行打断点、看状态，获得程序的状态、一步步的调试；</p>
<ul>
<li>因此很难 Debug；</li>
</ul>
<p><strong>现在</strong></p>
<ul>
<li>提供了 Nsight Graphics</li>
<li>RenderDoc</li>
<li>不知道这两款软件是否可以调试 WebGL；</li>
</ul>
<p><strong>远古时代的 Debug 的方法</strong></p>
<ul>
<li>对当前程序的状态打印出来，使用不同的颜色；<ul>
<li>How？</li>
</ul>
</li>
<li>直接对现在输出的颜色，进行Debug；<ul>
<li>Show values as color；</li>
</ul>
</li>
</ul>
<h2 id="2-4-渲染方程"><a href="#2-4-渲染方程" class="headerlink" title="2.4 渲染方程"></a>2.4 渲染方程</h2><p><strong>Rendering Equation</strong></p>
<ul>
<li>描述光线的传播<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230919191410.png"
                     
                ></li>
</ul>
<p><strong>实时渲染的对于 BRDF 的两个区别</strong><br>实时渲染里面说的 BRDF 有两种：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230919191517.png"
                     
                ></p>
<ul>
<li>Visibitity 的区域<ul>
<li>对于发出的光线，是否可以看到；</li>
</ul>
</li>
</ul>
<p><strong>环境光照 Environment Lighting</strong><br>Representing incident lighting from all directions</p>
<ul>
<li>Usually represented as a cube map or a sphere map (texture)</li>
<li>We’ll introduce a new representation in this course<br>可以使用一个 CubeMap 或者是一个展开的呈现；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230919191700.png"
                     
                ><br>环境光照的渲染难度：</li>
</ul>
<ul>
<li>复杂在对于每一个点都要计算渲染方程的积分；</li>
</ul>
]]></content>
      <categories>
        <category>游戏引擎</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【实时渲染】Lecture 3：Real - Time Shadow</title>
    <url>/2023/09/2dcef16ebde0.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h2 id="3-1-Shadow-Mapping"><a href="#3-1-Shadow-Mapping" class="headerlink" title="3.1 Shadow Mapping"></a>3.1 Shadow Mapping</h2><p><strong>对于 Shadow Mapping 的简单回顾</strong><br>对于点光源开始；</p>
<p><strong>Shadow Mapping 基本算法</strong><br>对于场景计算两遍；</p>
<ul>
<li>第一遍：从灯光的位置开始，往场景进行射线发射，生成深度图 -&gt; shadow map；</li>
<li>第二遍：从相机的位置出发，渲染场景，并且基于第一遍的结果，计算一点是否会渲染应用；</li>
</ul>
<p>其是完全基于图像的算法</p>
<ul>
<li>缺点<ul>
<li>会出现较多的锯齿；</li>
</ul>
</li>
<li>一种十分有名的算法<ul>
<li>基础的阴影技术</li>
</ul>
</li>
</ul>
<h3 id="3-1-1-具体算法"><a href="#3-1-1-具体算法" class="headerlink" title="3.1.1 具体算法"></a>3.1.1 具体算法</h3><p><strong>第一步</strong><br>对能看到的物体，记录能看到的最浅的深度，将这张图存储在一张 shadow map 当中；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230920194125.png"
                     
                ></p>
<p><strong>第二步</strong><br>从眼睛出发，看这个物体是否可以被阴影照到，并且输出是否可见；<br>比较连线的点，其记录的深度相比较时，哪个大那个小；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230920194321.png"
                     
                ></p>
<p>生成的深度图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230920194427.png"
                     
                ><br>和相机看到的互相比较：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230920194448.png"
                     
                ></p>
<p><strong>关于深度</strong><br>投影视图当中的结果，对于阴影的结果也要进行同样的变化吗；<br>只要深度一致即可；</p>
<h3 id="3-1-2-Shadow-Map-的问题：自遮挡"><a href="#3-1-2-Shadow-Map-的问题：自遮挡" class="headerlink" title="3.1.2 Shadow Map 的问题：自遮挡"></a>3.1.2 Shadow Map 的问题：自遮挡</h3><p><strong>可能会产生自遮挡的问题</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230920194859.png"
                     
                ><br>在 Light 的视角，地板就是这样一个个面朝其的离散的小平面，因此可能会出现自遮挡的情况；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230920195219.png"
                     
                ><br><strong>当 Light 与地面的角度非常小，即灯光非常偏时，就是自遮挡问题最大的时候</strong></p>
<p><strong>如何避免</strong><br>深度的比较 -&gt; 必须得超过一定范围的大小，才可以判断为遮挡；</p>
<ul>
<li>加上一段 bias 的数值，来解决这样的情况；</li>
<li>又有了新的问题 -&gt; <strong>阴影漂浮</strong>；<ul>
<li>设置的容错范围过大，物体表面生成阴影；</li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230920195232.png"
                     
                ></li>
</ul>
</li>
</ul>
<p>实时渲染不相信复杂度<br><strong>实时渲染不相信复杂度，只相信绝对的速度</strong></p>
<h3 id="3-1-3-Shadow-Map-的问题：走样"><a href="#3-1-3-Shadow-Map-的问题：走样" class="headerlink" title="3.1.3 Shadow Map 的问题：走样"></a>3.1.3 Shadow Map 的问题：走样</h3><p><strong>为什么会走样</strong><br>Shadow Map 是一个有一定分辨率的内容，因此当分辨率不够的时候，就会产生走样；</p>
<h2 id="3-2-Shadow-Mapping-背后的数学"><a href="#3-2-Shadow-Mapping-背后的数学" class="headerlink" title="3.2 Shadow Mapping 背后的数学"></a>3.2 Shadow Mapping 背后的数学</h2><p>在图形学当中用到的很多等式，其实都是不等式…<br>只要近似等于，就可以进行使用：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230920201057.png"
                     
                ></p>
<p><strong>Shadow Map 背后的约等式</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230920201412.png"
                     
                ></p>
<p>这部分会在环境光遮蔽当中进行使用；</p>
<h2 id="3-3-Percentage-closer-soft-shadows：PCSS"><a href="#3-3-Percentage-closer-soft-shadows：PCSS" class="headerlink" title="3.3 Percentage closer soft shadows：PCSS"></a>3.3 Percentage closer soft shadows：PCSS</h2><p><strong>为什么有这种方法</strong><br>因为 shadow map 产生的硬阴影，而 PSCC 是软阴影；<br>软阴影更加的自然，在过渡的部分更加平滑；</p>
<ul>
<li>从本影到无影的部分存在：半影</li>
</ul>
<p><strong>PCF</strong><br>PCF 最开始是用来做抗锯齿的，并不是用来做软阴影；<br>但后背发现 PCF 可以用来生成软阴影，所以出现 PCSS；</p>
<ul>
<li>过滤这个 shadow 比较的结果；</li>
<li>不是对 shadow map 进行的比较；<ul>
<li>在阴影判断的时候进行比较；</li>
<li>并不是得到一个反走样的结果后，再进行 PCSS；</li>
</ul>
</li>
<li>做法<ul>
<li>在做阴影的判断时候，原本是用深度进行比较 -&gt; 一次比较；</li>
<li>对于 shadow point，也要进行比较，但同时还要找这个像素周围一圈的像素（比如 7×7），再把这些值都平均出来；</li>
<li>去一个对这九个数的平均值<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230921183154.png"
                     
                ></li>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230921183146.png"
                     
                ></li>
</ul>
</li>
<li>这是对很多阴影进行重复采样得到的结果；<ul>
<li>对一个区域内进行多次比较的结果；</li>
</ul>
</li>
</ul>
</li>
<li>问题：开销大<ul>
<li>原本查一次的事情，现在要查 7✖7&#x3D;49（如果采样范围是 7×7）；</li>
</ul>
</li>
</ul>
<p><strong>PSCC 处理深度</strong></p>
<ul>
<li>Key Conclusion<ul>
<li>如果要对一片区域计算软阴影，需要对硬阴影很多个区域做出它的 Filter Size &lt; - &gt;  Block Distance 的距离；</li>
<li>相对的、平均的、投射的遮挡的深度；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230921193446.png"
                     
                ></li>
</ul>
</li>
<li>Light 是点光源，穿过 Blocker 的区域后，在平面上投影大小 W；</li>
<li>当 Light 距离 Block 越小，这个 W 的大小就越大 -&gt; 阴影也就更软；</li>
<li>计算<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230921193646.png"
                     
                ></li>
</ul>
</li>
</ul>
<p><strong>过滤的范围多大</strong><br>取决于 Light 本身的大小，以及 Block 本身的距离；</p>
<p><strong>计算算法过程</strong></p>
<ul>
<li>第一步：Blocker Search<ul>
<li>获得特定区域内 Block 的平均深度值；</li>
<li>判断在阴影里，即为一个 Block；</li>
<li>把每个 Block 都记录下来，保留 Block 的深度图；</li>
</ul>
</li>
<li>第二步：Penumbra Estimation<ul>
<li>知道了各处的 filiter 的大小，就可以利用此过滤的大小然后和硬阴影一样，处理阴影；</li>
</ul>
</li>
<li>第三步：PCF<ul>
<li>Percentage Closer Filtering</li>
</ul>
</li>
</ul>
<h2 id="3-4-Basic-filiter-techniques"><a href="#3-4-Basic-filiter-techniques" class="headerlink" title="3.4 Basic filiter techniques"></a>3.4 Basic filiter techniques</h2>]]></content>
      <categories>
        <category>游戏引擎</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>阴影</tag>
      </tags>
  </entry>
  <entry>
    <title>【Game Engine】P1：引擎事件系统</title>
    <url>/2023/08/3dac16a26c48.html</url>
    <content><![CDATA[<p>引擎事件系统框架编写</p>
<span id="more"></span>

<h2 id="1-1-事件类型基础"><a href="#1-1-事件类型基础" class="headerlink" title="1.1 事件类型基础"></a>1.1 事件类型基础</h2><h3 id="1-1-1-事件类型枚举"><a href="#1-1-1-事件类型枚举" class="headerlink" title="1.1.1 事件类型枚举"></a>1.1.1 事件类型枚举</h3><p>描述事件系统的基础事件类型，用枚举表示。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">EventType</span></span><br><span class="line">&#123;</span><br><span class="line">	None = <span class="number">0</span>,</span><br><span class="line">	WindowClose, WindowResize, WindowFocus, WindowLostFocus, WindowMoved,</span><br><span class="line">	AppTick, AppUpdate, AppRender,</span><br><span class="line">	KeyPressed, KeyReleased,</span><br><span class="line">	MouseButtonPressed, MouseButtonReleased, MouseMoved, MouseScrolled</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="1-1-2-事件分类"><a href="#1-1-2-事件分类" class="headerlink" title="1.1.2 事件分类"></a>1.1.2 事件分类</h3><p>定义了事件分类，并且可以向0进行过滤、偏移；</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EventCategory</span></span><br><span class="line">&#123;</span><br><span class="line">	None = <span class="number">0</span>,</span><br><span class="line">	EventCategoryApplication = <span class="built_in">BIT</span>(<span class="number">0</span>),</span><br><span class="line">	EventCategoryInput = <span class="built_in">BIT</span>(<span class="number">1</span>),</span><br><span class="line">	EventCategoryKeyboard = <span class="built_in">BIT</span>(<span class="number">2</span>),</span><br><span class="line">	EventCategoryMouse = <span class="built_in">BIT</span>(<span class="number">3</span>),</span><br><span class="line">	EventCategoryMouseButton = <span class="built_in">BIT</span>(<span class="number">4</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>BIT的定义如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT(x) (1 &lt;&lt; x)</span></span><br></pre></td></tr></table></figure></div>

<h2 id="1-2-Event-基类设计"><a href="#1-2-Event-基类设计" class="headerlink" title="1.2 Event 基类设计"></a>1.2 Event 基类设计</h2><ul>
<li>内容：<ul>
<li>m_Handled：用于表示此内容是否已经被处理过；</li>
<li>IsInCategory：现在处理的事件，是否是属于类型的部分；使用此方法快速的进行过滤； </li>
<li>GetName：仅用在Debug模式；</li>
<li>ToString：默认输出名字，也可以继承后修改以及扩展此行为；<ul>
<li>实现细节：stringstream的性能很差，但目前Debug模式可以先不考虑；</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> Event</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">EventDispatcher</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> EventType <span class="title">GetEventType</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetCategoryFlags</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetName</span>(); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsInCategory</span><span class="params">(EventCategory category)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GetCategoryFlags</span>() &amp; category;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">bool</span> m_Handled = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="1-2-1-抽象函数的实现宏"><a href="#1-2-1-抽象函数的实现宏" class="headerlink" title="1.2.1 抽象函数的实现宏"></a>1.2.1 抽象函数的实现宏</h3><p>因为在Event当中有抽象函数需要实现，每一个子类都需要手动进行实现的话会导致浪费。可以将其写成一个宏函数，在子类当中只需传入类型，既可以自动实现其子类的抽象函数的实现；</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_CLASS_TYPE(type) static EventType GetStaticType() &#123; return EventType::##type; &#125;\</span></span><br><span class="line"><span class="meta">								virtual EventType GetEventType() const override &#123; return GetStaticType(); &#125;\</span></span><br><span class="line"><span class="meta">								virtual const char* GetName() const override &#123; return #type; &#125;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="1-3-KeyEvent-类设计"><a href="#1-3-KeyEvent-类设计" class="headerlink" title="1.3 KeyEvent 类设计"></a>1.3 KeyEvent 类设计</h2><p><strong>KeyEvent概念</strong><br>需要处理案件的事件。并且按键的事件至少具有以下三种状态：</p>
<ol>
<li>第一次按下</li>
<li>按下中</li>
<li>第一次抬起<br>KeyEvent需要能够处理并表达这三种状态。</li>
</ol>
<p><strong>继承</strong><br>KeyEvent是其他更多按键事件的父类，是Event类的子类；</p>
<p><strong>KeyEvent代码</strong><br>此代码的内容类似于是抽象类，只是用于提供继承；不能实例化一个Key Event；</p>
<ul>
<li>内容：<ul>
<li>构造函数：构造函数被设置为protected，表示此类作用为提供继承；</li>
<li>Get Key Code：返回KeyCode数值；<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> KeyEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetKeyCode</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_KeyCode; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryKeyboard | EventCategoryInput)</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">KeyEvent</span>(<span class="type">int</span> keycode)</span><br><span class="line">		: <span class="built_in">m_KeyCode</span>(keycode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_KeyCode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<p><strong>EVENT_CLASS_CATEGORY内容</strong><br>因为KeyBoard键盘输入同时也是一般Input的一种，因此其进行分类时同属于这两种类型；</p>
<h3 id="1-3-1-KeyPressedEvent-类设计"><a href="#1-3-1-KeyPressedEvent-类设计" class="headerlink" title="1.3.1 KeyPressedEvent 类设计"></a>1.3.1 KeyPressedEvent 类设计</h3><p>此类是一个可以被实际实例化的类；</p>
<p><strong>构造函数</strong><br>此类的构造函数传入repeatCount，表示此按键的重复次数。当此数值不为0时，此内容表示当前Event在被重复按下；</p>
<p><strong>ToString重写</strong><br>输出”KeyPressedEvent: “ 加上 KeyCode 的数值；</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> KeyPressedEvent : <span class="keyword">public</span> KeyEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">KeyPressedEvent</span>(<span class="type">int</span> keycode, <span class="type">int</span> repeatCount)</span><br><span class="line">		: <span class="built_in">KeyEvent</span>(keycode), <span class="built_in">m_RepeatCount</span>(repeatCount) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetRepeatCount</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_RepeatCount; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;KeyPressedEvent: &quot;</span> &lt;&lt; m_KeyCode &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; m_RepeatCount &lt;&lt; <span class="string">&quot; repeats)&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(KeyPressed)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_RepeatCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-2-KeyReleasedEvent-类设计"><a href="#1-3-2-KeyReleasedEvent-类设计" class="headerlink" title="1.3.2 KeyReleasedEvent 类设计"></a>1.3.2 KeyReleasedEvent 类设计</h3><p>和Pressed类基本一致，只不过没有repeatCount的计数内容；</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> KeyReleasedEvent : <span class="keyword">public</span> KeyEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">KeyReleasedEvent</span>(<span class="type">int</span> keycode)</span><br><span class="line">		: <span class="built_in">KeyEvent</span>(keycode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;KeyReleasedEvent: &quot;</span> &lt;&lt; m_KeyCode;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(KeyReleased)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="1-4-EventDispatcher"><a href="#1-4-EventDispatcher" class="headerlink" title="1.4 EventDispatcher"></a>1.4 EventDispatcher</h2><p><strong>作用</strong><br>让我们可以实际的去发布一个事件，基于需要发布事件的类型；<br>创建一个Dispatcher的实例，并且拥有一个Event的引用。在这个Dispatcher中拥有一个Dispatch()方法，可以接受一个EventFn函数。然后如果类型一致，可以实际的在Dispatch中运行这个EventFn的函数。</p>
<p><strong>构造函数</strong><br>Event基类作为参数，接受各种事件类型，赋值在私有的Event变量上；</p>
<p><strong>Dispatch()方法</strong><br>在此方法内需要使用上Event，进行判断泛型传入的类型T的事件类型，和当前Dispatch中存储的Event的类型是否一致（通过GetEventType()方法，调用GetStaticType()方法）；<br>一致时，会调用EventFn中存储的函数，并返回bool；</p>
<p><strong>EventFn函数</strong><br>使用std的function，并且返回bool类型，接受T&amp;引用（可以为任何类型的Event）作为参数；</p>
<ul>
<li>补充：<strong>std::function()</strong><ul>
<li>可以把std::function看做一个函数对象，用于表示并存储函数这个抽象概念。</li>
<li>std::function的实例可以存储、复制和调用任何可调用对象（函数指针，类成员函数指针，bind表达式等等），存储的可调用对象称为std::function的目标，若std::function不含目标，则称它为空</li>
</ul>
</li>
</ul>
<p>代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventDispatcher</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">using</span> EventFn = std::function&lt;<span class="built_in">bool</span>(T&amp;)&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">EventDispatcher</span>(Event&amp; event)</span><br><span class="line">		: <span class="built_in">m_Event</span>(event)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="type">bool</span> <span class="title">Dispatch</span><span class="params">(EventFn&lt;T&gt; func)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Event.<span class="built_in">GetEventType</span>() == T::<span class="built_in">GetStaticType</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			m_Event.m_Handled = <span class="built_in">func</span>(*(T*)&amp;m_Event);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Event&amp; m_Event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="1-5-MouseEvent-设计"><a href="#1-5-MouseEvent-设计" class="headerlink" title="1.5 MouseEvent 设计"></a>1.5 MouseEvent 设计</h2><p><strong>MouseMovedEvent</strong><br>传入x、y表示两个坐标位置，用于存储鼠标移动事件所需要的信息；<br>同理MouseScrolledEvent。<br>下面内容基本类似，主要关注构造函数中传入的参数的差别，代表了此种类型事件所实际需要使用到的数据。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseMovedEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MouseMovedEvent</span>(<span class="type">float</span> x, <span class="type">float</span> y)</span><br><span class="line">		: <span class="built_in">m_MouseX</span>(x), <span class="built_in">m_MouseY</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_MouseX; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetY</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_MouseY; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;MouseMovedEvent: &quot;</span> &lt;&lt; m_MouseX &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; m_MouseY;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(MouseMoved)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryMouse | EventCategoryInput)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> m_MouseX, m_MouseY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseScrolledEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MouseScrolledEvent</span>(<span class="type">float</span> xOffset, <span class="type">float</span> yOffset)</span><br><span class="line">		: <span class="built_in">m_XOffset</span>(xOffset), <span class="built_in">m_YOffset</span>(yOffset) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetXOffset</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_XOffset; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetYOffset</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_YOffset; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;MouseScrolledEvent: &quot;</span> &lt;&lt; <span class="built_in">GetXOffset</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="built_in">GetYOffset</span>();</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(MouseScrolled)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryMouse | EventCategoryInput)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> m_XOffset, m_YOffset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseButtonEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetMouseButton</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Button; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryMouse | EventCategoryInput)</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">MouseButtonEvent</span>(<span class="type">int</span> button)</span><br><span class="line">		: <span class="built_in">m_Button</span>(button) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Button;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseButtonPressedEvent : <span class="keyword">public</span> MouseButtonEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MouseButtonPressedEvent</span>(<span class="type">int</span> button)</span><br><span class="line">		: <span class="built_in">MouseButtonEvent</span>(button) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;MouseButtonPressedEvent: &quot;</span> &lt;&lt; m_Button;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(MouseButtonPressed)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> MouseButtonReleasedEvent : <span class="keyword">public</span> MouseButtonEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MouseButtonReleasedEvent</span>(<span class="type">int</span> button)</span><br><span class="line">		: <span class="built_in">MouseButtonEvent</span>(button) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;MouseButtonReleasedEvent: &quot;</span> &lt;&lt; m_Button;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(MouseButtonReleased)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="1-6-ApplicationEvent-设计"><a href="#1-6-ApplicationEvent-设计" class="headerlink" title="1.6 ApplicationEvent 设计"></a>1.6 ApplicationEvent 设计</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> WindowResizeEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">WindowResizeEvent</span>(<span class="type">unsigned</span> <span class="type">int</span> width, <span class="type">unsigned</span> <span class="type">int</span> height)</span><br><span class="line">		: <span class="built_in">m_Width</span>(width), <span class="built_in">m_Height</span>(height) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Width; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Height; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;WindowResizeEvent: &quot;</span> &lt;&lt; m_Width &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; m_Height;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(WindowResize)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_Width, m_Height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> WindowCloseEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">WindowCloseEvent</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(WindowClose)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> AppTickEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AppTickEvent</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(AppTick)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> AppUpdateEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AppUpdateEvent</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(AppUpdate)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> AppRenderEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AppRenderEvent</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(AppRender)</span><br><span class="line">		<span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryApplication)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>游戏引擎</category>
        <category>游戏引擎原理</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
        <tag>事件</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【Game Engine】P2：Precompiled Header</title>
    <url>/2023/08/e071a8f05b89.html</url>
    <content><![CDATA[<p>很多代码当中都会有include其他库的代码，可以把这部分代码全部写在一个.h文件当中，并统一的为项目添加。</p>
<span id="more"></span>
<h2 id="2-1-编写预编译头"><a href="#2-1-编写预编译头" class="headerlink" title="2.1 编写预编译头"></a>2.1 编写预编译头</h2><p><strong>C++中的PCH</strong><br>很多代码当中都会有include其他库的代码，可以把这部分代码全部写在一个.h文件当中，并统一的为项目添加。以下是负责的.h代码；</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HZ_PLATFORM_WINDOWS</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<h2 id="2-2-将预编译头内容加入到-premake"><a href="#2-2-将预编译头内容加入到-premake" class="headerlink" title="2.2 将预编译头内容加入到 premake"></a>2.2 将预编译头内容加入到 premake</h2><p>加入到Premake中<br>需要把内容加入到premake当中：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">project <span class="string">&quot;Satsuki&quot;</span></span><br><span class="line"></span><br><span class="line">    location <span class="string">&quot;Satsuki&quot;</span></span><br><span class="line"></span><br><span class="line">    kind <span class="string">&quot;SharedLib&quot;</span></span><br><span class="line"></span><br><span class="line">    language <span class="string">&quot;C++&quot;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">targetdir</span> (<span class="string">&quot;bin/&quot;</span>..outputdir..<span class="string">&quot;/%&#123;prj.name&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">objdir</span> (<span class="string">&quot;bin-int/&quot;</span>..outputdir..<span class="string">&quot;/%&#123;prj.name&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    pchheader <span class="string">&quot;skpch.h&quot;</span></span><br><span class="line"></span><br><span class="line">    pchsource <span class="string">&quot;Satsuki/src/skpch&quot;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    files</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;%&#123;prj.name&#125;/src/**.h&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;%&#123;prj.name&#125;/src/**.cpp&quot;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    includedirs</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;%&#123;prj.name&#125;/src&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;%&#123;prj.name&#125;/vendor/spdlog/include&quot;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>游戏引擎</category>
        <category>游戏引擎原理</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
        <tag>C++</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>【Game Engine】P3：Window抽象与GLFW</title>
    <url>/2023/09/6d0b784b6d94.html</url>
    <content><![CDATA[<ol>
<li>GLFW与premake文件</li>
<li>项目Premake代码修改</li>
<li>Window 代码设计与实现<span id="more"></span></li>
</ol>
<h2 id="3-1-GLFW-与-premake-文件"><a href="#3-1-GLFW-与-premake-文件" class="headerlink" title="3.1 GLFW 与 premake 文件"></a>3.1 GLFW 与 premake 文件</h2><p>文件包含代码：<br>引用了项目需要用到的和GLFW相关的代码文件（for windows）</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">files</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="string">&quot;include/GLFW/glfw3.h&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;include/GLFW/glfw3native.h&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;src/glfw_config.h&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;src/context.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;src/init.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;src/input.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;src/monitor.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;src/vulkan.c&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;src/window.c&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>以下是完整premake代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">project &quot;GLFW&quot;</span><br><span class="line">    kind &quot;StaticLib&quot;</span><br><span class="line">    language &quot;C&quot;</span><br><span class="line">    </span><br><span class="line">	targetdir (&quot;bin/&quot; .. outputdir .. &quot;/%&#123;prj.name&#125;&quot;)</span><br><span class="line">    objdir (&quot;bin-int/&quot; .. outputdir .. &quot;/%&#123;prj.name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">	files</span><br><span class="line">	&#123;</span><br><span class="line">        &quot;include/GLFW/glfw3.h&quot;,</span><br><span class="line">        &quot;include/GLFW/glfw3native.h&quot;,</span><br><span class="line">        &quot;src/glfw_config.h&quot;,</span><br><span class="line">        &quot;src/context.c&quot;,</span><br><span class="line">        &quot;src/init.c&quot;,</span><br><span class="line">        &quot;src/input.c&quot;,</span><br><span class="line">        &quot;src/monitor.c&quot;,</span><br><span class="line">        &quot;src/vulkan.c&quot;,</span><br><span class="line">        &quot;src/window.c&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	filter &quot;system:windows&quot;</span><br><span class="line">        buildoptions &#123; &quot;-std=c11&quot;, &quot;-lgdi32&quot; &#125;</span><br><span class="line">        systemversion &quot;10.0.17134.0&quot;</span><br><span class="line">        staticruntime &quot;On&quot;</span><br><span class="line">        </span><br><span class="line">        files</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;src/win32_init.c&quot;,</span><br><span class="line">            &quot;src/win32_joystick.c&quot;,</span><br><span class="line">            &quot;src/win32_monitor.c&quot;,</span><br><span class="line">            &quot;src/win32_time.c&quot;,</span><br><span class="line">            &quot;src/win32_thread.c&quot;,</span><br><span class="line">            &quot;src/win32_window.c&quot;,</span><br><span class="line">            &quot;src/wgl_context.c&quot;,</span><br><span class="line">            &quot;src/egl_context.c&quot;,</span><br><span class="line">            &quot;src/osmesa_context.c&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		defines </span><br><span class="line">		&#123; </span><br><span class="line">            &quot;_GLFW_WIN32&quot;,</span><br><span class="line">            &quot;_CRT_SECURE_NO_WARNINGS&quot;</span><br><span class="line">		&#125;</span><br><span class="line">    filter &#123; &quot;system:windows&quot;, &quot;configurations:Release&quot; &#125;</span><br><span class="line">        buildoptions &quot;/MT&quot;</span><br></pre></td></tr></table></figure></div>

<p><strong>给项目添加GLFW代码</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230905010507.png"
                     
                ></p>
<h2 id="3-2-项目-premake-代码修改"><a href="#3-2-项目-premake-代码修改" class="headerlink" title="3.2 项目 premake 代码修改"></a>3.2 项目 premake 代码修改</h2><p><strong>增加代码，引用GLFW到Satsuki项目</strong></p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">-- Include directories relative to root folder (solution directory)</span><br><span class="line"></span><br><span class="line">IncludeDir = <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">IncludeDir<span class="punctuation">[</span><span class="string">&quot;GLFW&quot;</span><span class="punctuation">]</span> = <span class="string">&quot;Satsuki/vendor/GLFW/include&quot;</span></span><br><span class="line"></span><br><span class="line">include <span class="string">&quot;Satsuki/vendor/GLFW&quot;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>include “Satsuki&#x2F;vendor&#x2F;GLFW”<ul>
<li>将GLFW中的premake代码直接粘贴到这个位置；</li>
</ul>
</li>
<li>IncludeDir[“GLFW”] &#x3D; “Satsuki&#x2F;vendor&#x2F;GLFW&#x2F;include”<ul>
<li>增加编译时引用的路径；</li>
</ul>
</li>
</ul>
<p><strong>link设置</strong><br>GLFW作为静态链接库，被项目引用；</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">includedirs</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="string">&quot;%&#123;prj.name&#125;/src&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;%&#123;prj.name&#125;/vendor/spdlog/include&quot;</span></span><br><span class="line">	<span class="string">&quot;%&#123;prj.name&#125;/vendor/spdlog/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;%&#123;IncludeDir.GLFW&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">links</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;GLFW&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="string">&quot;opengl32.lib&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="3-3-Window-代码设计与实现"><a href="#3-3-Window-代码设计与实现" class="headerlink" title="3.3 Window 代码设计与实现"></a>3.3 Window 代码设计与实现</h2><h3 id="3-3-1-抽象-Window-类实现"><a href="#3-3-1-抽象-Window-类实现" class="headerlink" title="3.3.1 抽象 Window 类实现"></a>3.3.1 抽象 Window 类实现</h3><p><strong>Windows 类解析</strong><br>此类的作用是用于被其他具体的平台实现，因此都是抽象函数或者函数指针，并不实际拥有数据；</p>
<ul>
<li>回调函数<ul>
<li>在 Windows 类当中，有一个 EventCallbackFn 函数指针；</li>
</ul>
</li>
<li>Create 函数<ul>
<li>等待被实现，用于在不同的平台创建 Window ；</li>
</ul>
</li>
<li>其余都是抽象接口，等待被实现</li>
</ul>
<p><strong>WindowProps 类</strong><br>用于存储和 Window 相关的属性数据；</p>
<ul>
<li>标题</li>
<li>高度、宽度</li>
<li>默认属性</li>
</ul>
<p>完整 Window.h 代码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;skpch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Satsuki/Core.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Events/Event.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Satsuki &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">WindowProps</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::string Title;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> Width;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> Height;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">WindowProps</span>(<span class="type">const</span> std::string&amp; title = <span class="string">&quot;Satsuki Engine&quot;</span>,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> width = <span class="number">1280</span>,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> height = <span class="number">720</span>)</span><br><span class="line">			: <span class="built_in">Title</span>(title), <span class="built_in">Width</span>(width), <span class="built_in">Height</span>(height)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Interface representing a desktop system based Window</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> Window</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">using</span> EventCallbackFn = std::function&lt;<span class="built_in">void</span>(Event&amp;)&gt;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Window</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Window attributes</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetEventCallback</span><span class="params">(<span class="type">const</span> EventCallbackFn&amp; callback)</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetVSync</span><span class="params">(<span class="type">bool</span> enabled)</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsVSync</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">static</span> Window* <span class="title">Create</span><span class="params">(<span class="type">const</span> WindowProps&amp; props = WindowProps())</span></span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3-2-Windows-Window-具体类实现"><a href="#3-3-2-Windows-Window-具体类实现" class="headerlink" title="3.3.2 Windows Window 具体类实现"></a>3.3.2 Windows Window 具体类实现</h3><p><strong>Window Data 结构体</strong><br>用于传输 Window 的数据，并且可以将其传入 GLFW 当中；</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">WindowData</span></span><br><span class="line">&#123;</span><br><span class="line">	std::string Title;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> Width, Height;</span><br><span class="line">	<span class="type">bool</span> VSync;</span><br><span class="line"></span><br><span class="line">	EventCallbackFn EventCallback;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>WindowsWindow 类（头文件）</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Satsuki/Window.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Satsuki &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">WindowsWindow</span> : <span class="keyword">public</span> Window</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">WindowsWindow</span>(<span class="type">const</span> WindowProps&amp; props);</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">WindowsWindow</span>();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_Data.Width; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_Data.Height; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Window attributes</span></span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SetEventCallback</span><span class="params">(<span class="type">const</span> EventCallbackFn&amp; callback)</span> <span class="keyword">override</span> </span>&#123; m_Data.EventCallback = callback; &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">SetVSync</span><span class="params">(<span class="type">bool</span> enabled)</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">IsVSync</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		GLFWwindow* m_Window;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">WindowData</span></span><br><span class="line">		&#123;</span><br><span class="line">			std::string Title;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> Width, Height;</span><br><span class="line">			<span class="type">bool</span> VSync;</span><br><span class="line"></span><br><span class="line">			EventCallbackFn EventCallback;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		WindowData m_Data;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>WindowsWindow 类实现（CPP 文件）</strong></p>
<ul>
<li>Create 函数实现<ul>
<li>返回一个具体的 WindowsWindow 类的实例；</li>
</ul>
</li>
<li>构造函数<ul>
<li>实例化一个 WindowsWindow 的 Proc ；</li>
</ul>
</li>
<li>Init 函数<ul>
<li>设置基础的属性；</li>
<li>虽然需要创建多个窗口，但需要保证 GLFW 只被实例化一次；<br>创建一个 Window 在 GLFW 中：<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">m_Window = <span class="built_in">glfwCreateWindow</span>((<span class="type">int</span>)props.Width, (<span class="type">int</span>)props.Height, m_Data.Title.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(m_Window);</span><br><span class="line"><span class="built_in">glfwSetWindowUserPointer</span>(m_Window, &amp;m_Data);</span><br><span class="line"><span class="built_in">SetVSync</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<p>以下是完整代码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;skpch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;WindowsWindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Satsuki/Log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Satsuki &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">bool</span> s_GLFWInitialized = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Window* <span class="title">Window::Create</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsWindow</span>(props);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	WindowsWindow::<span class="built_in">WindowsWindow</span>(<span class="type">const</span> WindowProps&amp; props)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Init</span>(props);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	WindowsWindow::~<span class="built_in">WindowsWindow</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Shutdown</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WindowsWindow::Init</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Data.Title = props.Title;</span><br><span class="line">		m_Data.Width = props.Width;</span><br><span class="line">		m_Data.Height = props.Height;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">SK_CORE_INFO</span>(<span class="string">&quot;Creating window &#123;0&#125; (&#123;1&#125;, &#123;2&#125;)&quot;</span>, props.Title, props.Width, props.Height);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!s_GLFWInitialized)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> glfwTerminate on system shutdown</span></span><br><span class="line">			<span class="type">int</span> success = <span class="built_in">glfwInit</span>();</span><br><span class="line">			<span class="built_in">SK_CORE_ASSERT</span>(success, <span class="string">&quot;Could not intialize GLFW!&quot;</span>);</span><br><span class="line"></span><br><span class="line">			s_GLFWInitialized = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		m_Window = <span class="built_in">glfwCreateWindow</span>((<span class="type">int</span>)props.Width, (<span class="type">int</span>)props.Height, m_Data.Title.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">		<span class="built_in">glfwMakeContextCurrent</span>(m_Window);</span><br><span class="line">		<span class="built_in">glfwSetWindowUserPointer</span>(m_Window, &amp;m_Data);</span><br><span class="line">		<span class="built_in">SetVSync</span>(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WindowsWindow::Shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">glfwDestroyWindow</span>(m_Window);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WindowsWindow::OnUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(m_Window);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WindowsWindow::SetVSync</span><span class="params">(<span class="type">bool</span> enabled)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (enabled)</span><br><span class="line">			<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">glfwSwapInterval</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		m_Data.VSync = enabled;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">WindowsWindow::IsVSync</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Data.VSync;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-3-2-1-补充：ASSERT-与-Log-h"><a href="#3-3-2-1-补充：ASSERT-与-Log-h" class="headerlink" title="3.3.2.1 补充：ASSERT 与 Log.h"></a>3.3.2.1 补充：ASSERT 与 Log.h</h4><p>新增加的输出代码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SK_ENABLE_ASSERTS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SK_ASSERT(x, ...) &#123; <span class="keyword">if</span>(!(x)) &#123; SK_ERROR(<span class="string">&quot;Assertion Failed: &#123;0&#125;&quot;</span>, __VA_ARGS__); __debugbreak(); &#125; &#125;</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SK_CORE_ASSERT(x, ...) &#123; <span class="keyword">if</span>(!(x)) &#123; SK_CORE_ERROR(<span class="string">&quot;Assertion Failed: &#123;0&#125;&quot;</span>, __VA_ARGS__); __debugbreak(); &#125; &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SK_ASSERT(x, ...)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SK_CORE_ASSERT(x, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>内容</strong><br>判断 Assert 当中的 bool 数值是否为假，如果为假，则输出 Asseertion Failed 信息（参数中传入的信息），并且打一个断点（breakpoint）；</p>
<ul>
<li>并且可以轻松的设置，通过 <code>ifdef</code> 代码，可以实现轻松在 Debug 模式和 Release 模式之间的切换，去掉所有的 Asseertion 语句；</li>
</ul>
]]></content>
      <categories>
        <category>游戏引擎</category>
        <category>游戏引擎原理</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
        <tag>C++</tag>
        <tag>OpenGL</tag>
        <tag>GLFW</tag>
      </tags>
  </entry>
  <entry>
    <title>【Game Engine】P4：Window Event</title>
    <url>/2023/09/be66b1e96b19.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h2 id="4-1-什么是-Window-Event"><a href="#4-1-什么是-Window-Event" class="headerlink" title="4.1 什么是 Window Event"></a>4.1 什么是 Window Event</h2><p>对 Window 做的所有操作，都会产生一个 Window Event；</p>
<ul>
<li>能够将自己实现的 Event 系统，和 GLFW 的 Window 联系上，并完成对应的绘制；</li>
</ul>
<p><strong>使用 Event 回调</strong><br>SetEventCallBack 函数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIND_EVENT_FN(x) std::bind(&amp;x,this,std::placeholders::_1)</span></span><br><span class="line"></span><br><span class="line">Application::<span class="built_in">Application</span>() </span><br><span class="line">&#123;</span><br><span class="line">	m_Window = std::<span class="built_in">unique_ptr</span>&lt;Window&gt;(Window::<span class="built_in">Create</span>());</span><br><span class="line">	m_Window-&gt;<span class="built_in">SetEventCallback</span>(<span class="built_in">BIND_EVENT_FN</span>(Application::OnEvent));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="4-1-1-补充：Bind-与函数指针"><a href="#4-1-1-补充：Bind-与函数指针" class="headerlink" title="4.1.1 补充：Bind 与函数指针"></a>4.1.1 补充：Bind 与函数指针</h3><p><strong>1. <code>std::function</code></strong></p>
<p><code>std::function</code>是一组函数对象包装类的模板，其实例可以对<code>普通函数</code>、<code>lambda表达式</code>、<code>函数指针</code>、<code>类的成员函数</code>及<code>其它函数对象</code>等进行存储、复制和调用操作，它实质上是实现了一个泛型的回调机制。</p>
<p><code>std::function</code>不管其实例类型是什么样的，其调用形式是一样的，如下：</p>
<p><strong><code>返回值类型（实参1，实参2，实参3...）</code></strong></p>
<p>在使用<code>std::function</code>的过程中，要包含的头文件为：</p>
<p><code>#include &lt;functional&gt;</code></p>
<p><code>using namespace std;</code></p>
<p><code>using namespace std::placeholders</code> &#x2F;&#x2F;bind的时候会用</p>
<p><strong><code>std::bind</code></strong></p>
<p><code>std::bind</code>一般接受一个函数，生成一个具有一个或多个参数的函数对象，例如如下形式：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span>,<span class="type">char</span>,<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> ff = std::<span class="built_in">bind</span>(f,_1,<span class="string">&#x27;c&#x27;</span>,<span class="number">2.2</span>);</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">ff</span>(<span class="number">10</span>);     <span class="comment">//f(10,&#x27;c&#x27;,2.2)</span></span><br></pre></td></tr></table></figure></div>

<p>其中，<code>_1</code>是一个占位符对象，用于表示当函数<code>f</code>通过函数<code>ff</code>进行调用时，函数<code>ff</code>的第一个参数在函数<code>f</code>参数列表中的位置。第二个参数为<code>_2</code>，第三个参数为<code>_3</code>，依次类推。例如：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span>,<span class="type">char</span>,<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> reflect = std::<span class="built_in">bind</span>(f,_3,_2,_1);     <span class="comment">//翻转参数顺序</span></span><br><span class="line"><span class="type">int</span> result = <span class="built_in">reflect</span>(<span class="number">2.2</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">10</span>);    <span class="comment">// f(10,&#x27;c&#x27;,2.2); </span></span><br></pre></td></tr></table></figure></div>

<p><code>std::bind</code>无法绑定一个重载函数的参数，我们必须显式地绑定重载函数的版本：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有这样的重载函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">good</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">good</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> result = std::<span class="built_in">bind</span>(good,_1);      <span class="comment">//错误形式，不知道调用哪一个good函数</span></span><br><span class="line"><span class="comment">//正确的做法，但是比较复杂</span></span><br><span class="line"><span class="keyword">auto</span> result_1 = std::<span class="built_in">bind</span>(<span class="built_in">double</span>(*)(<span class="type">double</span>)good, _1); </span><br><span class="line"><span class="comment">//这是更好的方式</span></span><br><span class="line"><span class="keyword">auto</span> result_2 = std::<span class="built_in">bind</span>&lt;<span class="type">double</span>&gt;(good, _1);   <span class="comment">//指定函数的返回类型</span></span><br></pre></td></tr></table></figure></div>

<h2 id="4-2-发出-Window-Event-回调"><a href="#4-2-发出-Window-Event-回调" class="headerlink" title="4.2 发出 Window Event 回调"></a>4.2 发出 Window Event 回调</h2><p><strong>在 WindowsWindow 中发出回调</strong><br>resize 窗口界面的回调；</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwSetWindowSizeCallback</span>(m_Window, [](GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span><br><span class="line">&#123;</span><br><span class="line">	WindowData&amp; data = *(WindowData*)<span class="built_in">glfwGetWindowUserPointer</span>(window);</span><br><span class="line">	data.Width = width;</span><br><span class="line">	data.Height = height;</span><br><span class="line"></span><br><span class="line">	WindowResizeEvent <span class="built_in">event</span>(width, height);</span><br><span class="line">	data.<span class="built_in">EventCallback</span>(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>窗口关闭的回调；</p>
]]></content>
      <categories>
        <category>游戏引擎</category>
        <category>游戏引擎原理</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title>【Game Engine】P5：Layer Stack</title>
    <url>/2023/09/402716ff4b25.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h2 id="5-1-什么是-Layer"><a href="#5-1-什么是-Layer" class="headerlink" title="5.1 什么是 Layer"></a>5.1 什么是 Layer</h2><p><strong>和 PS 对比</strong><br>类似于 PS 中当中的 Layer，拥有一系列的 Layer Stack，基于此 Layer Stack 来决定渲染渲染什么物体；<br>Layer 在游戏引擎当中，同样是一个对于时间以及逻辑更新十分重要的事情；</p>
<p><strong>应用一：渲染与覆盖</strong></p>
<ul>
<li>比如在 Run 函数当中进行 Game Loop，当一个 Layer 是不可用后，可以对此 Layer 的所有画面进行更新；</li>
<li>并且当后续有大量的 UI 以及其他元素（比如 Gizmo 或者 Debug）时，经常需要 OverLay 元素，此时就需要 LayerStack 来区分 Layer 之间的列表；</li>
</ul>
<p><strong>应用二：Layer 与 Event</strong><br>不同的可以进行事件交互的 UI 元素以及物体，可能只有最上面的 Layer 的物体需要产生交互事件，而其底下的物体不需要；此时需要 Layer 来进行定义；</p>
<p><strong>什么是 Layer</strong><br>定义不同的 Layer，来决定</p>
<ul>
<li>Rendering</li>
<li>Event Receive<br>比如通常有以下 Layer：</li>
<li>UI Layer<ul>
<li>对于 UI 的点击，不应该透过 UI 进入其下的 Layer；</li>
</ul>
</li>
<li>Debug </li>
<li>GameScene</li>
</ul>
<h2 id="5-2-Layer-代码"><a href="#5-2-Layer-代码" class="headerlink" title="5.2 Layer 代码"></a>5.2 Layer 代码</h2><p>Layer.h</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Satsuki/Core.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Events/Event.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Satsuki &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">SATSUKI_API</span> Layer</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Layer</span>(<span class="type">const</span> std::string&amp; name = <span class="string">&quot;Layer&quot;</span>);</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Layer</span>();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnAttach</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnDetach</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnEvent</span><span class="params">(Event&amp; event)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_DebugName; &#125;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		std::string m_DebugName;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>OnAttach 方法表示当此 Layer 被 push 到 stack 当中时，调用的方法；同样还有 OnDetach 方法；</li>
<li>OnEvent：接受 Event 方法；</li>
<li>当需要设计自己的 Layer 时，只需要继承自此 Layer 类，对其各个方法实现即可；</li>
</ul>
<p>Layer.cpp</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;skpch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Layer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Satsuki &#123;</span><br><span class="line"></span><br><span class="line">	Layer::<span class="built_in">Layer</span>(<span class="type">const</span> std::string&amp; debugName)</span><br><span class="line">		: <span class="built_in">m_DebugName</span>(debugName)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Layer::~<span class="built_in">Layer</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>很简单，只是存储 Layer 的 name；</p>
<h2 id="5-3-LayerStack-代码"><a href="#5-3-LayerStack-代码" class="headerlink" title="5.3 LayerStack 代码"></a>5.3 LayerStack 代码</h2><p><strong>LayerStack 类</strong></p>
<ul>
<li>核心：对于 Layer 构成的 Stack 的类型对象的实现；</li>
<li>存储指向一个个 Layer 实例的指针的 <code>std::vector&lt;Layer*&gt;</code> 结构；<br>Layer 会存活整个应用程序的生存周期，不会因为 LayerStack 的 <code>Pop</code> 方法执行而摧毁 Layer；它只是会从 vector 中移除；<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayerStack::PopLayer</span><span class="params">(Layer* layer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> it = std::<span class="built_in">find</span>(m_Layers.<span class="built_in">begin</span>(), m_Layers.<span class="built_in">end</span>(), layer);</span><br><span class="line">	<span class="keyword">if</span> (it != m_Layers.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		m_Layers.<span class="built_in">erase</span>(it);</span><br><span class="line">		m_LayerInsert--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>注意：overlayer 永远会在 layer 之后；<ul>
<li>方法中的区别：<code>PushLayer</code> 和 <code>PushOverlay</code> 方法；</li>
</ul>
</li>
</ul>
<p><strong>完整.cpp 代码</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;skpch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LayerStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Satsuki &#123;</span><br><span class="line"></span><br><span class="line">	LayerStack::<span class="built_in">LayerStack</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_LayerInsert = m_Layers.<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LayerStack::~<span class="built_in">LayerStack</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (Layer* layer : m_Layers)</span><br><span class="line">			<span class="keyword">delete</span> layer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">LayerStack::PushLayer</span><span class="params">(Layer* layer)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_LayerInsert = m_Layers.<span class="built_in">emplace</span>(m_LayerInsert, layer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">LayerStack::PushOverlay</span><span class="params">(Layer* overlay)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Layers.<span class="built_in">emplace_back</span>(overlay);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">LayerStack::PopLayer</span><span class="params">(Layer* layer)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = std::<span class="built_in">find</span>(m_Layers.<span class="built_in">begin</span>(), m_Layers.<span class="built_in">end</span>(), layer);</span><br><span class="line">		<span class="keyword">if</span> (it != m_Layers.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			m_Layers.<span class="built_in">erase</span>(it);</span><br><span class="line">			m_LayerInsert--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">LayerStack::PopOverlay</span><span class="params">(Layer* overlay)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = std::<span class="built_in">find</span>(m_Layers.<span class="built_in">begin</span>(), m_Layers.<span class="built_in">end</span>(), overlay);</span><br><span class="line">		<span class="keyword">if</span> (it != m_Layers.<span class="built_in">end</span>())</span><br><span class="line">			m_Layers.<span class="built_in">erase</span>(it);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>游戏引擎</category>
        <category>游戏引擎原理</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>【Game Engine】P6：Modern OpenGL</title>
    <url>/2023/09/39d96f492624.html</url>
    <content><![CDATA[<p>需要一种方式，能够调用 GPU 驱动 DLL 当中的 API，通过一种 C 代码的方式；</p>
<ul>
<li>GLEW &#x2F; But use glad</li>
<li>更加好的 API；更加现代；<span id="more"></span></li>
</ul>
<h1 id="1-ImGUI"><a href="#1-ImGUI" class="headerlink" title="1 ImGUI"></a>1 ImGUI</h1><p><strong>对于软件开发的三个阶段</strong></p>
<ul>
<li>阶段一：make it work</li>
<li>阶段二：make it current</li>
<li>阶段三：make it fast</li>
</ul>
<p><strong>为什么现在需要 UI</strong><br>可以更好的去 Debug 后续的程序，尤其是和 Renderer 相关的功能；</p>
]]></content>
      <categories>
        <category>游戏引擎</category>
        <category>游戏引擎原理</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
        <tag>OpenGL</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏引擎原理】P1：GPU驱动的几何管线</title>
    <url>/2023/08/47c2a01c7a83.html</url>
    <content><![CDATA[<p>传统渲染问题：<br>在CPU端发出一个Draw Call，在此过程中GPU可能会一直在等待Draw Call，因此浪费大量性能；<br>在GPU中设置好数据，还要在CPU中处理各种计算，而且GPU要花费大量的时间在等待CPU的时间中，因为就算是计算一个非常简单的index，也需要把整个Render跑一遍。</p>
<span id="more"></span>
<h2 id="1-传统渲染管线"><a href="#1-传统渲染管线" class="headerlink" title="1 传统渲染管线"></a>1 传统渲染管线</h2><h3 id="1-1-传统渲染问题"><a href="#1-1-传统渲染问题" class="headerlink" title="1.1 传统渲染问题"></a>1.1 传统渲染问题</h3><p><strong>核心：所有的需求是在CPU那端发起</strong><br>在CPU端发出一个Draw Call，在此过程中GPU可能会一直在等待Draw Call，因此浪费大量性能；<br>在GPU中设置好数据，还要在CPU中处理各种计算，而且GPU要花费大量的时间在等待CPU的时间中，因为就算是计算一个非常简单的index，也需要把整个Render跑一遍。<br><strong>Draw Graphics API</strong><br>传统渲染管线跑现代游戏无法满足，现代CPU得先把数据准备好，然后再把数据给到GPU；</p>
<h3 id="1-2-Compute-Shader与GPU驱动管线"><a href="#1-2-Compute-Shader与GPU驱动管线" class="headerlink" title="1.2 Compute Shader与GPU驱动管线"></a>1.2 Compute Shader与GPU驱动管线</h3><p><strong>Compute Shader核心概念</strong><br>计算机不需要再CPU和GPU中来回导数据，所有的计算都在GPU的内部；<br>方法：</p>
<ol>
<li>在GPU中内置一些计算模块，很多计算直接在GPU中完成；把很多只有在CPU中才可以做的通用计算放到GPU上面；</li>
<li>单个Draw Call可以绘制多个Mesh；</li>
</ol>
<p><strong>更加进阶的状态：GPU驱动Render管线</strong><br>GPU控制什么对象该被实际的渲染，包括Lod Selection，Visibility Culling On GPU<br>CPU不触碰GPU的数据，尽量让CPU不那么忙；</p>
<p><strong>GPU驱动Render管线在材质中应用</strong><br>在《刺客信条大革命》中大场景的渲染，大场景当中有大量不可见的物体以及材质；</p>
<ul>
<li>解决方法<ul>
<li>对每个游戏世界中的物体，按照其Mesh把其分成无数个小的Clusters，计算这个小Clusters是否被遮挡</li>
<li>因为这种小粒度的Cluster在GPU中可以被批量处理，因此实际上性能更高，对于三角形有尽可能高的利用率；</li>
</ul>
</li>
</ul>
<p><strong>GPU驱动Pipeline概述</strong><br>流程图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230827161631.png"
                     
                ></p>
<p>CPU阶段进行粗略的Culling，在GPU阶段进行更加精细的Culling，每一个物体被分成不同的Cluster，然后打包进一个非常大的Index Buffer当中。最后一个Draw Call一次性完成计算。<br>核心：通过前面GPU一大堆的计算，一次性将不可见的几何完成绘制；</p>
<p><strong>Work in CPU Side</strong><br>在CPU端只需要</p>
<h2 id="2-Occlusion-Culling与相机以及阴影"><a href="#2-Occlusion-Culling与相机以及阴影" class="headerlink" title="2 Occlusion Culling与相机以及阴影"></a>2 Occlusion Culling与相机以及阴影</h2><p>如何将观测或者光照不到的地方的渲染变得尽可能廉价；</p>
<p><strong>核心概念</strong><br>对于所有基于Cluster渲染的管线而言，Occlusion的计算都是十分关键的部分；<br>而Occlusion的基本思想，就是尽可能快速且低成本的基于当前相机的位置构建index buffer，类似于形成了一层幕布；当想渲染任何一个物体的时候，使用cluster渲染时使用这个index buffer在GPU中快速进行测试，快速将不需要渲染的部分剔除掉；</p>
<h3 id="2-1-Occlusion-Depth-Generation"><a href="#2-1-Occlusion-Depth-Generation" class="headerlink" title="2.1 Occlusion Depth Generation"></a>2.1 Occlusion Depth Generation</h3><p>遮挡深度生成：这个根据场景生成的Depth Buffer可以被重用；</p>
<p><strong>深度Pre-Pass与最好的Occluders在完整的像素当中</strong></p>
<ol>
<li>选择最好的occluders通过艺术资源或者heuristic</li>
<li>重新计算occluder</li>
<li>合并以及重投影与十六分之一的像素版本；</li>
<li>生成Z-Buffer用于GPU Culling计算；</li>
</ol>
<p><strong>两个阶段的Occlusion Culling</strong><br>第一阶段：把上一帧里面的所有物体，依据Z buffer数据测试一遍，对所有通过上一帧Z-Buffer的物体先绘制一遍；把可能可见的物体先跑一遍得出画面；<br>问题：此时得出的z很有可能是错误的，此时应该把所有认为可能不可见的物体也测试一遍Z-Buffer<br>第二阶段：在第一阶段过滤完之后，重新再测试一遍被忽略掉的物体，从而减少大量的渲染量，准确并且高效完成；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230827161702.png"
                     
                ></p>
<h3 id="2-2-可视化内容处理渲染管线"><a href="#2-2-可视化内容处理渲染管线" class="headerlink" title="2.2 可视化内容处理渲染管线"></a>2.2 可视化内容处理渲染管线</h3><p><strong>Visiblity Buffer</strong><br>Visiblity Buffer是一种新的越来越瘦关注的Buffer；<br>如果使用传统的Shading，每一次渲染都需要全部进行处理，处理的数据量非常大，因此可以把这些Texture可以全部打包放到一个Shading当中</p>
<p><strong>Deferred Shading 与 G-Buffer 存在的意义与问题</strong><br>Deffered Shading：在Deferred Shader中处理很多三角形的场景时，其不会保证优先绘制靠近相机的物体，因此对于同一个像素可能会渲染十几次，因为在这个像素上可能会有多个物体在其射线上；<br>大量的对G-Buffer的读写会产生大量的性能浪费；</p>
<p><strong>Visiblity Buffer</strong><br>解决方法：在第一帧渲染的时候，就只把几何数据渲染进去，而不是把Texture等其他数据全部在第一帧弄进去；在获得了这些几何体的位置信息后，再将其手动的把每个顶点该有的信息输入进去；<br>Shading阶段时，把几何体的每个像素位置拿到，反算出来其像素点应该有的反射率等信息，接下来对其进行Shading；<br>其非常适合在场景当中有大量的小物体，而且这些物体经常会被其他物体遮挡住；</p>
<p><strong>Visiblity Buffer与Deferred Shading结合</strong><br>将Visiblity和G-Buffer结合，G-Buffer的数据可以来自于传统渲染管线，也可以来自于Visiblity Buffer渲染管线；</p>
<h2 id="3-Nanite"><a href="#3-Nanite" class="headerlink" title="3 Nanite"></a>3 Nanite</h2><h3 id="3-1-前言"><a href="#3-1-前言" class="headerlink" title="3.1 前言"></a>3.1 前言</h3><p><strong>要解决的问题</strong><br>每个做Render的目标：在虚拟世界中还原现实世界，但现实世界中具有无限的几何细节。实时渲染的人希望在游戏当中实现无限的几何细节；</p>
<p><strong>Nanite基本的源头：Virtual Texture</strong><br>在真实的游戏场景当中拥有大量的texture，在游戏引擎中提出Virtual Texture的思想，即在游戏当中、离Camera的Texture精度高，离Camera远的Texture精度低；即先形成一大张的Virtual Texture；</p>
<p><strong>进一步推到：把几何Geometry也变成Virtual Map</strong><br>需要有一个方法把几何也变成Virtual Map；但这个过程十分困难，因为几何信息的处理比Texture困难很多；</p>
<ul>
<li>Voxels方法？<ul>
<li>难以表达高精度内容</li>
<li>数据量惊人</li>
<li>而且目前主流的艺术资产都不是基于Voxel表达的</li>
</ul>
</li>
<li>Subdivision Surfaces？<ul>
<li>增加几何的精细度</li>
<li>在实时给几何体细分表面</li>
</ul>
</li>
<li>Map-Based Method?<ul>
<li>难以表达表面特性</li>
<li>基于硬件的加密几何</li>
</ul>
</li>
</ul>
<p><strong>最后结果：基于三角形的几何构建</strong></p>
<h3 id="3-2-Virtual-Geometry"><a href="#3-2-Virtual-Geometry" class="headerlink" title="3.2 Virtual Geometry"></a>3.2 Virtual Geometry</h3><p><strong>Nanite中的几何表达</strong><br>无论增加多少的几何复杂度，屏幕上能够展示的几何数量终归是有限的，有像素上有一个或两个三角形就够了；<br>可以通过屏幕像素的精度来决定几何物体的精度；</p>
<ul>
<li>基于Cluster的几何表达<ul>
<li>将几何体分成不同的Cluster</li>
<li>让其根据View来决定Cluster的精度，不同的LOD在Cluster中具有不同的精度</li>
<li>对于屏幕空间最大化的利用<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230827161729.png"
                     
                ></li>
</ul>
</li>
</ul>
<p><strong>Nanite的Cluster细分方法</strong><br>根据View的距离情况，根据LOD进行Cluster的简化，将其合成一份Cluster；<br>因此可以在游戏进行时，可以根据View距离加载不同的LOD；<br><strong>Cluster合并的问题</strong><br>不同LOD等级的物体之间衔接的时候会有问题，即本来是根据同一LOD构建出的几何体现在有部分表面其Cluster变成其他LOD是，分界处衔接有问题；<br>解决方法：把边给锁住；在边缘一直锁着LOD0的边；但是锁边的时候这些边的三角形数量也很高；并且因为人眼对于高频的信号感受力很强，因此对于这种边缘处突然出现的高频信号会有反应；</p>
<p><strong>对Cluster合并问题的解决：Cluster Group</strong><br>只缩Cluster Group的边，里面的Cluster再随意的去简化；<br>保证了在LOD切换的时候，不会在衔接处明显变化；<br>其希望被锁住的LOD的边在切换的时候不会注意到被缩边的Cluster Group;<br>如图是Cluster Group在不同LOD时变化：<br>乱中有序：底层的Cluster上层可能有多个，并且不会和上层的所有Cluster都产生关系；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230827161745.png"
                     
                ></p>
<h3 id="3-3-QEM"><a href="#3-3-QEM" class="headerlink" title="3.3 QEM"></a>3.3 QEM</h3><p>形成Cluster Group的流水线；<br><strong>LOD Selection For Cluster Group In Paralllel</strong><br>能不能让LOD的Selection可不可以被并行化，从左到右或者从右到左的遍历都有可能是不稳定的；<br>把Cluster节点组成的树状的LOD，变成数组的线性的LOD（通过把Cluster其对应父节点的信息存储进来）</p>
<ul>
<li>希望是独立的决策</li>
</ul>
]]></content>
      <categories>
        <category>游戏引擎</category>
        <category>游戏引擎原理</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
        <tag>技术美术</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏引擎原理】现代图形绘制流水线（1） -- Vulkan开发基础</title>
    <url>/2023/09/dffee95a2c19.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h1 id="1-经典渲染管线"><a href="#1-经典渲染管线" class="headerlink" title="1 经典渲染管线"></a>1 经典渲染管线</h1><p><strong>上世纪：早期 OpenGL 与 DirectX</strong><br>应用：主要应用于影视领域的特效；</p>
<ul>
<li>一个简单的想法：如果可以制作一个统一的 API，就可以提高效率<ul>
<li>这就是 OpenGL 的 1.0 版本</li>
</ul>
</li>
</ul>
<p><strong>OpenGL</strong> </p>
<ul>
<li>一个跨平台的、横跨二维与三维的渲染框架；</li>
<li>支持多个平台<br>框架图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230911191654.png"
                     
                ></li>
</ul>
<p><strong>3D 游戏的出现</strong><br>在 1993 年底，逐渐出现了一批 3D 游戏；</p>
<ul>
<li>卡马克：做了 GLQuake<ul>
<li>只支持 OpenGL 接口；</li>
<li>3 dfx Glide 盛级而衰；</li>
</ul>
</li>
</ul>
<p><strong>DirectX</strong><br>由微软推出，使用 C++，并且当时只支持 Windows；</p>
<ul>
<li>微软的执行效率高，经过几年的开发，很快就已经支持很多的 OpenGL 没有的效果；<ul>
<li>逐渐的 DirectX 变成了更先进的引擎；</li>
</ul>
</li>
</ul>
<p><strong>Shader 的出现：可编程的绘制语言</strong><br>标志的绘制管线只可以做一些简单的光照；但可编程的绘制语言可以定制的更加深度；</p>
<ul>
<li>OpenGL 此时就已经落后了，并且其 Shader 语言在 2004 年才进入进来；<ul>
<li>并且因为很多公司共同开发 OpenGL，所以对于标准的制定产生了很多的分歧；</li>
<li>后来由另一个机构领导了 OpenGL；</li>
<li>并且因为 OpenGL 跨平台，所以在手机上很多应用还是 OpenGL；</li>
</ul>
</li>
</ul>
<p><strong>几何着色器的出现</strong><br>几何着色器可以接受图元，并进行绘制；</p>
<ul>
<li>LOD：孤岛危机 2</li>
</ul>
<p><strong>曲面细分技术</strong><br>使用 GPU 参与到曲面细化的画面效果绘制；基于屏幕的细分；</p>
<ul>
<li>制作毛发、细节优化的部分，可以使用此内容；</li>
</ul>
<p><strong>OpenGL 4.0</strong></p>
<ul>
<li>CUDA OpenGL <ul>
<li>想要在所有的平台，做跨平台的并行计算；</li>
</ul>
</li>
<li>OpenGL|ES<ul>
<li>其功能是 OpenGL 的子集；</li>
<li>主要用于手机平台；</li>
</ul>
</li>
<li>WebGL<ul>
<li>把 HTML 和 OpenGL 合在一起；</li>
</ul>
</li>
</ul>
<h1 id="2-现代绘制流水线"><a href="#2-现代绘制流水线" class="headerlink" title="2 现代绘制流水线"></a>2 现代绘制流水线</h1><p>基本情况：以 Vulkan 为主<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230911192556.png"
                     
                ></p>
<p><strong>Vulkan</strong><br>其创始人就是 OpenGL 的创始人；<br>但为什么它放弃了 OpenGL，转为 Vulkan？</p>
<ul>
<li>因为 OpenGL 的历史包袱太重，要兼容太多东西；</li>
</ul>
<p><strong>Vulkan 与 OpenGL 比较</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230911192711.png"
                     
                ></p>
<h1 id="3-混合绘制流水线"><a href="#3-混合绘制流水线" class="headerlink" title="3 混合绘制流水线"></a>3 混合绘制流水线</h1><ol>
<li>由英伟达和另一家公司一起做的；</li>
<li>AI + 绘制</li>
<li>隐式神经场表达：用全可微的场中，进行细分；</li>
<li>神经绘制全局光照：直接用通用的 NPU，进行全局光照计算；</li>
</ol>
<p>整体演变：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230911193007.png"
                     
                ></p>
]]></content>
      <categories>
        <category>游戏引擎</category>
        <category>游戏引擎原理</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
        <tag>渲染管线</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏引擎原理】现代图形绘制流水线（2） -- Vulkan开发基础</title>
    <url>/2023/09/8da45f07ddbd.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
<h1 id="2-1-Vulkan-简介"><a href="#2-1-Vulkan-简介" class="headerlink" title="2.1 Vulkan 简介"></a>2.1 Vulkan 简介</h1><p><strong>定位：下一代的 OpenGL</strong><br>其并不是一个真正的实现，而是依赖于厂家的驱动实现；</p>
<ul>
<li><em>PS：永远不要相信设备提供商声明的 Vulkan 特性支持</em>；</li>
<li>某些功能可能是和设备强相关的事情；</li>
</ul>
<p><strong>RHI 对比</strong><br>传统 RHI</p>
<ul>
<li>RenderingContext：几乎所有的绘制命令都依赖隐式或者显式的 Context 调用；<ul>
<li>每个上下文对于一个线程；（对于多线程不友好）</li>
<li>需要有上下文；</li>
<li>并且是使用状态机进行管理：当状态机发生变化时，外部很难感知到；</li>
</ul>
</li>
<li>驱动帮你干了很多事情。<ul>
<li>意味着你对 GPU 的掌控比较少；</li>
<li>好处：更容易开发；</li>
<li>坏处：对 GPU 控制少；</li>
</ul>
</li>
<li>驱动层一般会比较重</li>
</ul>
<p>现代 RHI</p>
<ul>
<li>D 3 D 12&#x2F;Vulkan&#x2F;Metal</li>
<li>需要自己考虑内存分配的方式；</li>
<li>对于多线程友好</li>
<li>需要自己去理解自己的程序，然后可以去对 GPU 进行掌握；</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230913231050.png"
                     
                ></p>
<h1 id="2-1-初始化-Vulkan"><a href="#2-1-初始化-Vulkan" class="headerlink" title="2.1 初始化 Vulkan"></a>2.1 初始化 Vulkan</h1><h2 id="2-1-1-Vulkan-结构"><a href="#2-1-1-Vulkan-结构" class="headerlink" title="2.1.1 Vulkan 结构"></a>2.1.1 Vulkan 结构</h2><ul>
<li>应用程序下面拥有实例；<ul>
<li>实例拥有物理设备；</li>
<li>物理设备下面可能会有逻辑设备；</li>
<li>逻辑设备下面会有队列；</li>
</ul>
</li>
<li>可以要求不同的实例做不同的事情；<ul>
<li>逻辑设备就是对于队列的实例化；</li>
<li>不同的队列是不同的类型，用于计算不同的内容；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230913231223.png"
                     
                ></li>
</ul>
</li>
</ul>
<h2 id="2-1-2-Vulkan-初始化与-Layer"><a href="#2-1-2-Vulkan-初始化与-Layer" class="headerlink" title="2.1.2 Vulkan 初始化与 Layer"></a>2.1.2 Vulkan 初始化与 Layer</h2><p><strong>创建 Vulkan Instance 初始化 Vulkan Library</strong></p>
<ul>
<li>Instance 是程序和 Vulkan 之间的桥梁；</li>
</ul>
<p><strong>需要指定你需要开启的扩展</strong></p>
<ul>
<li>创建 swapchain 的类型；</li>
</ul>
<p><strong>Vulkan Layer</strong><br>Vulkan 将很多不同的功能放到了不同的 Layer 当中；</p>
<ul>
<li>可以把 Layer 当作是一种函数重载，方便进行Debug；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../image/Pasted%20image%2020230913231828.png"
                     
                ></li>
</ul>
<p><strong>显卡选择</strong><br>在初始化 Vulkan 时，可以选择要使用的显卡；</p>
<ul>
<li>Vulkan 会自动检测当前电脑拥有的显卡；</li>
<li>可以选择使用哪一个；</li>
</ul>
]]></content>
      <categories>
        <category>游戏引擎</category>
        <category>游戏引擎原理</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>游戏引擎</tag>
        <tag>渲染管线</tag>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity系列】游戏资源加载：Lecture 1 课程导论与目标</title>
    <url>/2023/09/8c5b1a2ddb87.html</url>
    <content><![CDATA[<p>内容大纲：</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>游戏引擎</category>
        <category>Unity</category>
        <category>游戏资源加载</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
        <tag>CSharp</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
</search>
